function nT(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const o=Object.getOwnPropertyDescriptor(s,r);o&&Object.defineProperty(n,r,o.get?o:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const o of r)if(o.type==="childList")for(const a of o.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function t(r){const o={};return r.integrity&&(o.integrity=r.integrity),r.referrerPolicy&&(o.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?o.credentials="include":r.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(r){if(r.ep)return;r.ep=!0;const o=t(r);fetch(r.href,o)}})();function sT(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function Ug(n){if(n.__esModule)return n;var e=n.default;if(typeof e=="function"){var t=function s(){return this instanceof s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),t}var Bm={exports:{}},Ei={},Mm={exports:{}},Pe={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var zv;function rT(){if(zv)return Pe;zv=1;var n=Symbol.for("react.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),a=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),p=Symbol.for("react.lazy"),f=Symbol.iterator;function m(L){return L===null||typeof L!="object"?null:(L=f&&L[f]||L["@@iterator"],typeof L=="function"?L:null)}var g={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x=Object.assign,w={};function v(L,H,re){this.props=L,this.context=H,this.refs=w,this.updater=re||g}v.prototype.isReactComponent={},v.prototype.setState=function(L,H){if(typeof L!="object"&&typeof L!="function"&&L!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,L,H,"setState")},v.prototype.forceUpdate=function(L){this.updater.enqueueForceUpdate(this,L,"forceUpdate")};function b(){}b.prototype=v.prototype;function C(L,H,re){this.props=L,this.context=H,this.refs=w,this.updater=re||g}var I=C.prototype=new b;I.constructor=C,x(I,v.prototype),I.isPureReactComponent=!0;var N=Array.isArray,R=Object.prototype.hasOwnProperty,D={current:null},F={key:!0,ref:!0,__self:!0,__source:!0};function V(L,H,re){var ae,ie={},ue=null,he=null;if(H!=null)for(ae in H.ref!==void 0&&(he=H.ref),H.key!==void 0&&(ue=""+H.key),H)R.call(H,ae)&&!F.hasOwnProperty(ae)&&(ie[ae]=H[ae]);var me=arguments.length-2;if(me===1)ie.children=re;else if(1<me){for(var ye=Array(me),Te=0;Te<me;Te++)ye[Te]=arguments[Te+2];ie.children=ye}if(L&&L.defaultProps)for(ae in me=L.defaultProps,me)ie[ae]===void 0&&(ie[ae]=me[ae]);return{$$typeof:n,type:L,key:ue,ref:he,props:ie,_owner:D.current}}function P(L,H){return{$$typeof:n,type:L.type,key:H,ref:L.ref,props:L.props,_owner:L._owner}}function A(L){return typeof L=="object"&&L!==null&&L.$$typeof===n}function T(L){var H={"=":"=0",":":"=2"};return"$"+L.replace(/[=:]/g,function(re){return H[re]})}var W=/\/+/g;function j(L,H){return typeof L=="object"&&L!==null&&L.key!=null?T(""+L.key):H.toString(36)}function Y(L,H,re,ae,ie){var ue=typeof L;(ue==="undefined"||ue==="boolean")&&(L=null);var he=!1;if(L===null)he=!0;else switch(ue){case"string":case"number":he=!0;break;case"object":switch(L.$$typeof){case n:case e:he=!0}}if(he)return he=L,ie=ie(he),L=ae===""?"."+j(he,0):ae,N(ie)?(re="",L!=null&&(re=L.replace(W,"$&/")+"/"),Y(ie,H,re,"",function(Te){return Te})):ie!=null&&(A(ie)&&(ie=P(ie,re+(!ie.key||he&&he.key===ie.key?"":(""+ie.key).replace(W,"$&/")+"/")+L)),H.push(ie)),1;if(he=0,ae=ae===""?".":ae+":",N(L))for(var me=0;me<L.length;me++){ue=L[me];var ye=ae+j(ue,me);he+=Y(ue,H,re,ye,ie)}else if(ye=m(L),typeof ye=="function")for(L=ye.call(L),me=0;!(ue=L.next()).done;)ue=ue.value,ye=ae+j(ue,me++),he+=Y(ue,H,re,ye,ie);else if(ue==="object")throw H=String(L),Error("Objects are not valid as a React child (found: "+(H==="[object Object]"?"object with keys {"+Object.keys(L).join(", ")+"}":H)+"). If you meant to render a collection of children, use an array instead.");return he}function Q(L,H,re){if(L==null)return L;var ae=[],ie=0;return Y(L,ae,"","",function(ue){return H.call(re,ue,ie++)}),ae}function Z(L){if(L._status===-1){var H=L._result;H=H(),H.then(function(re){(L._status===0||L._status===-1)&&(L._status=1,L._result=re)},function(re){(L._status===0||L._status===-1)&&(L._status=2,L._result=re)}),L._status===-1&&(L._status=0,L._result=H)}if(L._status===1)return L._result.default;throw L._result}var ne={current:null},U={transition:null},K={ReactCurrentDispatcher:ne,ReactCurrentBatchConfig:U,ReactCurrentOwner:D};function X(){throw Error("act(...) is not supported in production builds of React.")}return Pe.Children={map:Q,forEach:function(L,H,re){Q(L,function(){H.apply(this,arguments)},re)},count:function(L){var H=0;return Q(L,function(){H++}),H},toArray:function(L){return Q(L,function(H){return H})||[]},only:function(L){if(!A(L))throw Error("React.Children.only expected to receive a single React element child.");return L}},Pe.Component=v,Pe.Fragment=t,Pe.Profiler=r,Pe.PureComponent=C,Pe.StrictMode=s,Pe.Suspense=u,Pe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=K,Pe.act=X,Pe.cloneElement=function(L,H,re){if(L==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+L+".");var ae=x({},L.props),ie=L.key,ue=L.ref,he=L._owner;if(H!=null){if(H.ref!==void 0&&(ue=H.ref,he=D.current),H.key!==void 0&&(ie=""+H.key),L.type&&L.type.defaultProps)var me=L.type.defaultProps;for(ye in H)R.call(H,ye)&&!F.hasOwnProperty(ye)&&(ae[ye]=H[ye]===void 0&&me!==void 0?me[ye]:H[ye])}var ye=arguments.length-2;if(ye===1)ae.children=re;else if(1<ye){me=Array(ye);for(var Te=0;Te<ye;Te++)me[Te]=arguments[Te+2];ae.children=me}return{$$typeof:n,type:L.type,key:ie,ref:ue,props:ae,_owner:he}},Pe.createContext=function(L){return L={$$typeof:a,_currentValue:L,_currentValue2:L,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},L.Provider={$$typeof:o,_context:L},L.Consumer=L},Pe.createElement=V,Pe.createFactory=function(L){var H=V.bind(null,L);return H.type=L,H},Pe.createRef=function(){return{current:null}},Pe.forwardRef=function(L){return{$$typeof:l,render:L}},Pe.isValidElement=A,Pe.lazy=function(L){return{$$typeof:p,_payload:{_status:-1,_result:L},_init:Z}},Pe.memo=function(L,H){return{$$typeof:d,type:L,compare:H===void 0?null:H}},Pe.startTransition=function(L){var H=U.transition;U.transition={};try{L()}finally{U.transition=H}},Pe.unstable_act=X,Pe.useCallback=function(L,H){return ne.current.useCallback(L,H)},Pe.useContext=function(L){return ne.current.useContext(L)},Pe.useDebugValue=function(){},Pe.useDeferredValue=function(L){return ne.current.useDeferredValue(L)},Pe.useEffect=function(L,H){return ne.current.useEffect(L,H)},Pe.useId=function(){return ne.current.useId()},Pe.useImperativeHandle=function(L,H,re){return ne.current.useImperativeHandle(L,H,re)},Pe.useInsertionEffect=function(L,H){return ne.current.useInsertionEffect(L,H)},Pe.useLayoutEffect=function(L,H){return ne.current.useLayoutEffect(L,H)},Pe.useMemo=function(L,H){return ne.current.useMemo(L,H)},Pe.useReducer=function(L,H,re){return ne.current.useReducer(L,H,re)},Pe.useRef=function(L){return ne.current.useRef(L)},Pe.useState=function(L){return ne.current.useState(L)},Pe.useSyncExternalStore=function(L,H,re){return ne.current.useSyncExternalStore(L,H,re)},Pe.useTransition=function(){return ne.current.useTransition()},Pe.version="18.3.1",Pe}var Wv;function Gg(){return Wv||(Wv=1,Mm.exports=rT()),Mm.exports}/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Uv;function oT(){if(Uv)return Ei;Uv=1;var n=Gg(),e=Symbol.for("react.element"),t=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,r=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,o={key:!0,ref:!0,__self:!0,__source:!0};function a(l,u,d){var p,f={},m=null,g=null;d!==void 0&&(m=""+d),u.key!==void 0&&(m=""+u.key),u.ref!==void 0&&(g=u.ref);for(p in u)s.call(u,p)&&!o.hasOwnProperty(p)&&(f[p]=u[p]);if(l&&l.defaultProps)for(p in u=l.defaultProps,u)f[p]===void 0&&(f[p]=u[p]);return{$$typeof:e,type:l,key:m,ref:g,props:f,_owner:r.current}}return Ei.Fragment=t,Ei.jsx=a,Ei.jsxs=a,Ei}var Gv;function aT(){return Gv||(Gv=1,Bm.exports=oT()),Bm.exports}var Ns=aT(),og=Gg(),Pc={},zm={exports:{}},$n={},Wm={exports:{}},Um={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Hv;function iT(){return Hv||(Hv=1,function(n){function e(U,K){var X=U.length;U.push(K);e:for(;0<X;){var L=X-1>>>1,H=U[L];if(0<r(H,K))U[L]=K,U[X]=H,X=L;else break e}}function t(U){return U.length===0?null:U[0]}function s(U){if(U.length===0)return null;var K=U[0],X=U.pop();if(X!==K){U[0]=X;e:for(var L=0,H=U.length,re=H>>>1;L<re;){var ae=2*(L+1)-1,ie=U[ae],ue=ae+1,he=U[ue];if(0>r(ie,X))ue<H&&0>r(he,ie)?(U[L]=he,U[ue]=X,L=ue):(U[L]=ie,U[ae]=X,L=ae);else if(ue<H&&0>r(he,X))U[L]=he,U[ue]=X,L=ue;else break e}}return K}function r(U,K){var X=U.sortIndex-K.sortIndex;return X!==0?X:U.id-K.id}if(typeof performance=="object"&&typeof performance.now=="function"){var o=performance;n.unstable_now=function(){return o.now()}}else{var a=Date,l=a.now();n.unstable_now=function(){return a.now()-l}}var u=[],d=[],p=1,f=null,m=3,g=!1,x=!1,w=!1,v=typeof setTimeout=="function"?setTimeout:null,b=typeof clearTimeout=="function"?clearTimeout:null,C=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function I(U){for(var K=t(d);K!==null;){if(K.callback===null)s(d);else if(K.startTime<=U)s(d),K.sortIndex=K.expirationTime,e(u,K);else break;K=t(d)}}function N(U){if(w=!1,I(U),!x)if(t(u)!==null)x=!0,Z(R);else{var K=t(d);K!==null&&ne(N,K.startTime-U)}}function R(U,K){x=!1,w&&(w=!1,b(V),V=-1),g=!0;var X=m;try{for(I(K),f=t(u);f!==null&&(!(f.expirationTime>K)||U&&!T());){var L=f.callback;if(typeof L=="function"){f.callback=null,m=f.priorityLevel;var H=L(f.expirationTime<=K);K=n.unstable_now(),typeof H=="function"?f.callback=H:f===t(u)&&s(u),I(K)}else s(u);f=t(u)}if(f!==null)var re=!0;else{var ae=t(d);ae!==null&&ne(N,ae.startTime-K),re=!1}return re}finally{f=null,m=X,g=!1}}var D=!1,F=null,V=-1,P=5,A=-1;function T(){return!(n.unstable_now()-A<P)}function W(){if(F!==null){var U=n.unstable_now();A=U;var K=!0;try{K=F(!0,U)}finally{K?j():(D=!1,F=null)}}else D=!1}var j;if(typeof C=="function")j=function(){C(W)};else if(typeof MessageChannel<"u"){var Y=new MessageChannel,Q=Y.port2;Y.port1.onmessage=W,j=function(){Q.postMessage(null)}}else j=function(){v(W,0)};function Z(U){F=U,D||(D=!0,j())}function ne(U,K){V=v(function(){U(n.unstable_now())},K)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(U){U.callback=null},n.unstable_continueExecution=function(){x||g||(x=!0,Z(R))},n.unstable_forceFrameRate=function(U){0>U||125<U?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<U?Math.floor(1e3/U):5},n.unstable_getCurrentPriorityLevel=function(){return m},n.unstable_getFirstCallbackNode=function(){return t(u)},n.unstable_next=function(U){switch(m){case 1:case 2:case 3:var K=3;break;default:K=m}var X=m;m=K;try{return U()}finally{m=X}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(U,K){switch(U){case 1:case 2:case 3:case 4:case 5:break;default:U=3}var X=m;m=U;try{return K()}finally{m=X}},n.unstable_scheduleCallback=function(U,K,X){var L=n.unstable_now();switch(typeof X=="object"&&X!==null?(X=X.delay,X=typeof X=="number"&&0<X?L+X:L):X=L,U){case 1:var H=-1;break;case 2:H=250;break;case 5:H=1073741823;break;case 4:H=1e4;break;default:H=5e3}return H=X+H,U={id:p++,callback:K,priorityLevel:U,startTime:X,expirationTime:H,sortIndex:-1},X>L?(U.sortIndex=X,e(d,U),t(u)===null&&U===t(d)&&(w?(b(V),V=-1):w=!0,ne(N,X-L))):(U.sortIndex=H,e(u,U),x||g||(x=!0,Z(R))),U},n.unstable_shouldYield=T,n.unstable_wrapCallback=function(U){var K=m;return function(){var X=m;m=K;try{return U.apply(this,arguments)}finally{m=X}}}}(Um)),Um}var jv;function lT(){return jv||(jv=1,Wm.exports=iT()),Wm.exports}/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var qv;function uT(){if(qv)return $n;qv=1;var n=Gg(),e=lT();function t(i){for(var c="https://reactjs.org/docs/error-decoder.html?invariant="+i,h=1;h<arguments.length;h++)c+="&args[]="+encodeURIComponent(arguments[h]);return"Minified React error #"+i+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var s=new Set,r={};function o(i,c){a(i,c),a(i+"Capture",c)}function a(i,c){for(r[i]=c,i=0;i<c.length;i++)s.add(c[i])}var l=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),u=Object.prototype.hasOwnProperty,d=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function m(i){return u.call(f,i)?!0:u.call(p,i)?!1:d.test(i)?f[i]=!0:(p[i]=!0,!1)}function g(i,c,h,y){if(h!==null&&h.type===0)return!1;switch(typeof c){case"function":case"symbol":return!0;case"boolean":return y?!1:h!==null?!h.acceptsBooleans:(i=i.toLowerCase().slice(0,5),i!=="data-"&&i!=="aria-");default:return!1}}function x(i,c,h,y){if(c===null||typeof c>"u"||g(i,c,h,y))return!0;if(y)return!1;if(h!==null)switch(h.type){case 3:return!c;case 4:return c===!1;case 5:return isNaN(c);case 6:return isNaN(c)||1>c}return!1}function w(i,c,h,y,$,S,E){this.acceptsBooleans=c===2||c===3||c===4,this.attributeName=y,this.attributeNamespace=$,this.mustUseProperty=h,this.propertyName=i,this.type=c,this.sanitizeURL=S,this.removeEmptyString=E}var v={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(i){v[i]=new w(i,0,!1,i,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(i){var c=i[0];v[c]=new w(c,1,!1,i[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(i){v[i]=new w(i,2,!1,i.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(i){v[i]=new w(i,2,!1,i,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(i){v[i]=new w(i,3,!1,i.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(i){v[i]=new w(i,3,!0,i,null,!1,!1)}),["capture","download"].forEach(function(i){v[i]=new w(i,4,!1,i,null,!1,!1)}),["cols","rows","size","span"].forEach(function(i){v[i]=new w(i,6,!1,i,null,!1,!1)}),["rowSpan","start"].forEach(function(i){v[i]=new w(i,5,!1,i.toLowerCase(),null,!1,!1)});var b=/[\-:]([a-z])/g;function C(i){return i[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(i){var c=i.replace(b,C);v[c]=new w(c,1,!1,i,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(i){var c=i.replace(b,C);v[c]=new w(c,1,!1,i,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(i){var c=i.replace(b,C);v[c]=new w(c,1,!1,i,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(i){v[i]=new w(i,1,!1,i.toLowerCase(),null,!1,!1)}),v.xlinkHref=new w("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(i){v[i]=new w(i,1,!1,i.toLowerCase(),null,!0,!0)});function I(i,c,h,y){var $=v.hasOwnProperty(c)?v[c]:null;($!==null?$.type!==0:y||!(2<c.length)||c[0]!=="o"&&c[0]!=="O"||c[1]!=="n"&&c[1]!=="N")&&(x(c,h,$,y)&&(h=null),y||$===null?m(c)&&(h===null?i.removeAttribute(c):i.setAttribute(c,""+h)):$.mustUseProperty?i[$.propertyName]=h===null?$.type===3?!1:"":h:(c=$.attributeName,y=$.attributeNamespace,h===null?i.removeAttribute(c):($=$.type,h=$===3||$===4&&h===!0?"":""+h,y?i.setAttributeNS(y,c,h):i.setAttribute(c,h))))}var N=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,R=Symbol.for("react.element"),D=Symbol.for("react.portal"),F=Symbol.for("react.fragment"),V=Symbol.for("react.strict_mode"),P=Symbol.for("react.profiler"),A=Symbol.for("react.provider"),T=Symbol.for("react.context"),W=Symbol.for("react.forward_ref"),j=Symbol.for("react.suspense"),Y=Symbol.for("react.suspense_list"),Q=Symbol.for("react.memo"),Z=Symbol.for("react.lazy"),ne=Symbol.for("react.offscreen"),U=Symbol.iterator;function K(i){return i===null||typeof i!="object"?null:(i=U&&i[U]||i["@@iterator"],typeof i=="function"?i:null)}var X=Object.assign,L;function H(i){if(L===void 0)try{throw Error()}catch(h){var c=h.stack.trim().match(/\n( *(at )?)/);L=c&&c[1]||""}return`
`+L+i}var re=!1;function ae(i,c){if(!i||re)return"";re=!0;var h=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(c)if(c=function(){throw Error()},Object.defineProperty(c.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(c,[])}catch(se){var y=se}Reflect.construct(i,[],c)}else{try{c.call()}catch(se){y=se}i.call(c.prototype)}else{try{throw Error()}catch(se){y=se}i()}}catch(se){if(se&&y&&typeof se.stack=="string"){for(var $=se.stack.split(`
`),S=y.stack.split(`
`),E=$.length-1,B=S.length-1;1<=E&&0<=B&&$[E]!==S[B];)B--;for(;1<=E&&0<=B;E--,B--)if($[E]!==S[B]){if(E!==1||B!==1)do if(E--,B--,0>B||$[E]!==S[B]){var G=`
`+$[E].replace(" at new "," at ");return i.displayName&&G.includes("<anonymous>")&&(G=G.replace("<anonymous>",i.displayName)),G}while(1<=E&&0<=B);break}}}finally{re=!1,Error.prepareStackTrace=h}return(i=i?i.displayName||i.name:"")?H(i):""}function ie(i){switch(i.tag){case 5:return H(i.type);case 16:return H("Lazy");case 13:return H("Suspense");case 19:return H("SuspenseList");case 0:case 2:case 15:return i=ae(i.type,!1),i;case 11:return i=ae(i.type.render,!1),i;case 1:return i=ae(i.type,!0),i;default:return""}}function ue(i){if(i==null)return null;if(typeof i=="function")return i.displayName||i.name||null;if(typeof i=="string")return i;switch(i){case F:return"Fragment";case D:return"Portal";case P:return"Profiler";case V:return"StrictMode";case j:return"Suspense";case Y:return"SuspenseList"}if(typeof i=="object")switch(i.$$typeof){case T:return(i.displayName||"Context")+".Consumer";case A:return(i._context.displayName||"Context")+".Provider";case W:var c=i.render;return i=i.displayName,i||(i=c.displayName||c.name||"",i=i!==""?"ForwardRef("+i+")":"ForwardRef"),i;case Q:return c=i.displayName||null,c!==null?c:ue(i.type)||"Memo";case Z:c=i._payload,i=i._init;try{return ue(i(c))}catch{}}return null}function he(i){var c=i.type;switch(i.tag){case 24:return"Cache";case 9:return(c.displayName||"Context")+".Consumer";case 10:return(c._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return i=c.render,i=i.displayName||i.name||"",c.displayName||(i!==""?"ForwardRef("+i+")":"ForwardRef");case 7:return"Fragment";case 5:return c;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return ue(c);case 8:return c===V?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof c=="function")return c.displayName||c.name||null;if(typeof c=="string")return c}return null}function me(i){switch(typeof i){case"boolean":case"number":case"string":case"undefined":return i;case"object":return i;default:return""}}function ye(i){var c=i.type;return(i=i.nodeName)&&i.toLowerCase()==="input"&&(c==="checkbox"||c==="radio")}function Te(i){var c=ye(i)?"checked":"value",h=Object.getOwnPropertyDescriptor(i.constructor.prototype,c),y=""+i[c];if(!i.hasOwnProperty(c)&&typeof h<"u"&&typeof h.get=="function"&&typeof h.set=="function"){var $=h.get,S=h.set;return Object.defineProperty(i,c,{configurable:!0,get:function(){return $.call(this)},set:function(E){y=""+E,S.call(this,E)}}),Object.defineProperty(i,c,{enumerable:h.enumerable}),{getValue:function(){return y},setValue:function(E){y=""+E},stopTracking:function(){i._valueTracker=null,delete i[c]}}}}function De(i){i._valueTracker||(i._valueTracker=Te(i))}function ze(i){if(!i)return!1;var c=i._valueTracker;if(!c)return!0;var h=c.getValue(),y="";return i&&(y=ye(i)?i.checked?"true":"false":i.value),i=y,i!==h?(c.setValue(i),!0):!1}function Ge(i){if(i=i||(typeof document<"u"?document:void 0),typeof i>"u")return null;try{return i.activeElement||i.body}catch{return i.body}}function nt(i,c){var h=c.checked;return X({},c,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:h??i._wrapperState.initialChecked})}function Ke(i,c){var h=c.defaultValue==null?"":c.defaultValue,y=c.checked!=null?c.checked:c.defaultChecked;h=me(c.value!=null?c.value:h),i._wrapperState={initialChecked:y,initialValue:h,controlled:c.type==="checkbox"||c.type==="radio"?c.checked!=null:c.value!=null}}function He(i,c){c=c.checked,c!=null&&I(i,"checked",c,!1)}function Je(i,c){He(i,c);var h=me(c.value),y=c.type;if(h!=null)y==="number"?(h===0&&i.value===""||i.value!=h)&&(i.value=""+h):i.value!==""+h&&(i.value=""+h);else if(y==="submit"||y==="reset"){i.removeAttribute("value");return}c.hasOwnProperty("value")?On(i,c.type,h):c.hasOwnProperty("defaultValue")&&On(i,c.type,me(c.defaultValue)),c.checked==null&&c.defaultChecked!=null&&(i.defaultChecked=!!c.defaultChecked)}function et(i,c,h){if(c.hasOwnProperty("value")||c.hasOwnProperty("defaultValue")){var y=c.type;if(!(y!=="submit"&&y!=="reset"||c.value!==void 0&&c.value!==null))return;c=""+i._wrapperState.initialValue,h||c===i.value||(i.value=c),i.defaultValue=c}h=i.name,h!==""&&(i.name=""),i.defaultChecked=!!i._wrapperState.initialChecked,h!==""&&(i.name=h)}function On(i,c,h){(c!=="number"||Ge(i.ownerDocument)!==i)&&(h==null?i.defaultValue=""+i._wrapperState.initialValue:i.defaultValue!==""+h&&(i.defaultValue=""+h))}var dt=Array.isArray;function cn(i,c,h,y){if(i=i.options,c){c={};for(var $=0;$<h.length;$++)c["$"+h[$]]=!0;for(h=0;h<i.length;h++)$=c.hasOwnProperty("$"+i[h].value),i[h].selected!==$&&(i[h].selected=$),$&&y&&(i[h].defaultSelected=!0)}else{for(h=""+me(h),c=null,$=0;$<i.length;$++){if(i[$].value===h){i[$].selected=!0,y&&(i[$].defaultSelected=!0);return}c!==null||i[$].disabled||(c=i[$])}c!==null&&(c.selected=!0)}}function jt(i,c){if(c.dangerouslySetInnerHTML!=null)throw Error(t(91));return X({},c,{value:void 0,defaultValue:void 0,children:""+i._wrapperState.initialValue})}function ws(i,c){var h=c.value;if(h==null){if(h=c.children,c=c.defaultValue,h!=null){if(c!=null)throw Error(t(92));if(dt(h)){if(1<h.length)throw Error(t(93));h=h[0]}c=h}c==null&&(c=""),h=c}i._wrapperState={initialValue:me(h)}}function gn(i,c){var h=me(c.value),y=me(c.defaultValue);h!=null&&(h=""+h,h!==i.value&&(i.value=h),c.defaultValue==null&&i.defaultValue!==h&&(i.defaultValue=h)),y!=null&&(i.defaultValue=""+y)}function Wn(i){var c=i.textContent;c===i._wrapperState.initialValue&&c!==""&&c!==null&&(i.value=c)}function ss(i){switch(i){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Un(i,c){return i==null||i==="http://www.w3.org/1999/xhtml"?ss(c):i==="http://www.w3.org/2000/svg"&&c==="foreignObject"?"http://www.w3.org/1999/xhtml":i}var Dn,dr=function(i){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(c,h,y,$){MSApp.execUnsafeLocalFunction(function(){return i(c,h,y,$)})}:i}(function(i,c){if(i.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in i)i.innerHTML=c;else{for(Dn=Dn||document.createElement("div"),Dn.innerHTML="<svg>"+c.valueOf().toString()+"</svg>",c=Dn.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;c.firstChild;)i.appendChild(c.firstChild)}});function Vs(i,c){if(c){var h=i.firstChild;if(h&&h===i.lastChild&&h.nodeType===3){h.nodeValue=c;return}}i.textContent=c}var Bs={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Xf=["Webkit","ms","Moz","O"];Object.keys(Bs).forEach(function(i){Xf.forEach(function(c){c=c+i.charAt(0).toUpperCase()+i.substring(1),Bs[c]=Bs[i]})});function Jr(i,c,h){return c==null||typeof c=="boolean"||c===""?"":h||typeof c!="number"||c===0||Bs.hasOwnProperty(i)&&Bs[i]?(""+c).trim():c+"px"}function Tu(i,c){i=i.style;for(var h in c)if(c.hasOwnProperty(h)){var y=h.indexOf("--")===0,$=Jr(h,c[h],y);h==="float"&&(h="cssFloat"),y?i.setProperty(h,$):i[h]=$}}var Yf=X({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Qf(i,c){if(c){if(Yf[i]&&(c.children!=null||c.dangerouslySetInnerHTML!=null))throw Error(t(137,i));if(c.dangerouslySetInnerHTML!=null){if(c.children!=null)throw Error(t(60));if(typeof c.dangerouslySetInnerHTML!="object"||!("__html"in c.dangerouslySetInnerHTML))throw Error(t(61))}if(c.style!=null&&typeof c.style!="object")throw Error(t(62))}}function Zf(i,c){if(i.indexOf("-")===-1)return typeof c.is=="string";switch(i){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Jf=null;function eh(i){return i=i.target||i.srcElement||window,i.correspondingUseElement&&(i=i.correspondingUseElement),i.nodeType===3?i.parentNode:i}var th=null,Go=null,Ho=null;function rx(i){if(i=hi(i)){if(typeof th!="function")throw Error(t(280));var c=i.stateNode;c&&(c=Qu(c),th(i.stateNode,i.type,c))}}function ox(i){Go?Ho?Ho.push(i):Ho=[i]:Go=i}function ax(){if(Go){var i=Go,c=Ho;if(Ho=Go=null,rx(i),c)for(i=0;i<c.length;i++)rx(c[i])}}function ix(i,c){return i(c)}function lx(){}var nh=!1;function ux(i,c,h){if(nh)return i(c,h);nh=!0;try{return ix(i,c,h)}finally{nh=!1,(Go!==null||Ho!==null)&&(lx(),ax())}}function qa(i,c){var h=i.stateNode;if(h===null)return null;var y=Qu(h);if(y===null)return null;h=y[c];e:switch(c){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(y=!y.disabled)||(i=i.type,y=!(i==="button"||i==="input"||i==="select"||i==="textarea")),i=!y;break e;default:i=!1}if(i)return null;if(h&&typeof h!="function")throw Error(t(231,c,typeof h));return h}var sh=!1;if(l)try{var Ka={};Object.defineProperty(Ka,"passive",{get:function(){sh=!0}}),window.addEventListener("test",Ka,Ka),window.removeEventListener("test",Ka,Ka)}catch{sh=!1}function l2(i,c,h,y,$,S,E,B,G){var se=Array.prototype.slice.call(arguments,3);try{c.apply(h,se)}catch(de){this.onError(de)}}var Xa=!1,Eu=null,Ru=!1,rh=null,u2={onError:function(i){Xa=!0,Eu=i}};function c2(i,c,h,y,$,S,E,B,G){Xa=!1,Eu=null,l2.apply(u2,arguments)}function d2(i,c,h,y,$,S,E,B,G){if(c2.apply(this,arguments),Xa){if(Xa){var se=Eu;Xa=!1,Eu=null}else throw Error(t(198));Ru||(Ru=!0,rh=se)}}function eo(i){var c=i,h=i;if(i.alternate)for(;c.return;)c=c.return;else{i=c;do c=i,c.flags&4098&&(h=c.return),i=c.return;while(i)}return c.tag===3?h:null}function cx(i){if(i.tag===13){var c=i.memoizedState;if(c===null&&(i=i.alternate,i!==null&&(c=i.memoizedState)),c!==null)return c.dehydrated}return null}function dx(i){if(eo(i)!==i)throw Error(t(188))}function p2(i){var c=i.alternate;if(!c){if(c=eo(i),c===null)throw Error(t(188));return c!==i?null:i}for(var h=i,y=c;;){var $=h.return;if($===null)break;var S=$.alternate;if(S===null){if(y=$.return,y!==null){h=y;continue}break}if($.child===S.child){for(S=$.child;S;){if(S===h)return dx($),i;if(S===y)return dx($),c;S=S.sibling}throw Error(t(188))}if(h.return!==y.return)h=$,y=S;else{for(var E=!1,B=$.child;B;){if(B===h){E=!0,h=$,y=S;break}if(B===y){E=!0,y=$,h=S;break}B=B.sibling}if(!E){for(B=S.child;B;){if(B===h){E=!0,h=S,y=$;break}if(B===y){E=!0,y=S,h=$;break}B=B.sibling}if(!E)throw Error(t(189))}}if(h.alternate!==y)throw Error(t(190))}if(h.tag!==3)throw Error(t(188));return h.stateNode.current===h?i:c}function px(i){return i=p2(i),i!==null?fx(i):null}function fx(i){if(i.tag===5||i.tag===6)return i;for(i=i.child;i!==null;){var c=fx(i);if(c!==null)return c;i=i.sibling}return null}var hx=e.unstable_scheduleCallback,mx=e.unstable_cancelCallback,f2=e.unstable_shouldYield,h2=e.unstable_requestPaint,St=e.unstable_now,m2=e.unstable_getCurrentPriorityLevel,oh=e.unstable_ImmediatePriority,gx=e.unstable_UserBlockingPriority,_u=e.unstable_NormalPriority,g2=e.unstable_LowPriority,yx=e.unstable_IdlePriority,Ou=null,bs=null;function y2(i){if(bs&&typeof bs.onCommitFiberRoot=="function")try{bs.onCommitFiberRoot(Ou,i,void 0,(i.current.flags&128)===128)}catch{}}var rs=Math.clz32?Math.clz32:w2,x2=Math.log,v2=Math.LN2;function w2(i){return i>>>=0,i===0?32:31-(x2(i)/v2|0)|0}var Du=64,Au=4194304;function Ya(i){switch(i&-i){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return i&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return i&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return i}}function Fu(i,c){var h=i.pendingLanes;if(h===0)return 0;var y=0,$=i.suspendedLanes,S=i.pingedLanes,E=h&268435455;if(E!==0){var B=E&~$;B!==0?y=Ya(B):(S&=E,S!==0&&(y=Ya(S)))}else E=h&~$,E!==0?y=Ya(E):S!==0&&(y=Ya(S));if(y===0)return 0;if(c!==0&&c!==y&&!(c&$)&&($=y&-y,S=c&-c,$>=S||$===16&&(S&4194240)!==0))return c;if(y&4&&(y|=h&16),c=i.entangledLanes,c!==0)for(i=i.entanglements,c&=y;0<c;)h=31-rs(c),$=1<<h,y|=i[h],c&=~$;return y}function b2(i,c){switch(i){case 1:case 2:case 4:return c+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return c+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function $2(i,c){for(var h=i.suspendedLanes,y=i.pingedLanes,$=i.expirationTimes,S=i.pendingLanes;0<S;){var E=31-rs(S),B=1<<E,G=$[E];G===-1?(!(B&h)||B&y)&&($[E]=b2(B,c)):G<=c&&(i.expiredLanes|=B),S&=~B}}function ah(i){return i=i.pendingLanes&-1073741825,i!==0?i:i&1073741824?1073741824:0}function xx(){var i=Du;return Du<<=1,!(Du&4194240)&&(Du=64),i}function ih(i){for(var c=[],h=0;31>h;h++)c.push(i);return c}function Qa(i,c,h){i.pendingLanes|=c,c!==536870912&&(i.suspendedLanes=0,i.pingedLanes=0),i=i.eventTimes,c=31-rs(c),i[c]=h}function S2(i,c){var h=i.pendingLanes&~c;i.pendingLanes=c,i.suspendedLanes=0,i.pingedLanes=0,i.expiredLanes&=c,i.mutableReadLanes&=c,i.entangledLanes&=c,c=i.entanglements;var y=i.eventTimes;for(i=i.expirationTimes;0<h;){var $=31-rs(h),S=1<<$;c[$]=0,y[$]=-1,i[$]=-1,h&=~S}}function lh(i,c){var h=i.entangledLanes|=c;for(i=i.entanglements;h;){var y=31-rs(h),$=1<<y;$&c|i[y]&c&&(i[y]|=c),h&=~$}}var Ye=0;function vx(i){return i&=-i,1<i?4<i?i&268435455?16:536870912:4:1}var wx,uh,bx,$x,Sx,ch=!1,Pu=[],pr=null,fr=null,hr=null,Za=new Map,Ja=new Map,mr=[],C2="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Cx(i,c){switch(i){case"focusin":case"focusout":pr=null;break;case"dragenter":case"dragleave":fr=null;break;case"mouseover":case"mouseout":hr=null;break;case"pointerover":case"pointerout":Za.delete(c.pointerId);break;case"gotpointercapture":case"lostpointercapture":Ja.delete(c.pointerId)}}function ei(i,c,h,y,$,S){return i===null||i.nativeEvent!==S?(i={blockedOn:c,domEventName:h,eventSystemFlags:y,nativeEvent:S,targetContainers:[$]},c!==null&&(c=hi(c),c!==null&&uh(c)),i):(i.eventSystemFlags|=y,c=i.targetContainers,$!==null&&c.indexOf($)===-1&&c.push($),i)}function k2(i,c,h,y,$){switch(c){case"focusin":return pr=ei(pr,i,c,h,y,$),!0;case"dragenter":return fr=ei(fr,i,c,h,y,$),!0;case"mouseover":return hr=ei(hr,i,c,h,y,$),!0;case"pointerover":var S=$.pointerId;return Za.set(S,ei(Za.get(S)||null,i,c,h,y,$)),!0;case"gotpointercapture":return S=$.pointerId,Ja.set(S,ei(Ja.get(S)||null,i,c,h,y,$)),!0}return!1}function kx(i){var c=to(i.target);if(c!==null){var h=eo(c);if(h!==null){if(c=h.tag,c===13){if(c=cx(h),c!==null){i.blockedOn=c,Sx(i.priority,function(){bx(h)});return}}else if(c===3&&h.stateNode.current.memoizedState.isDehydrated){i.blockedOn=h.tag===3?h.stateNode.containerInfo:null;return}}}i.blockedOn=null}function Lu(i){if(i.blockedOn!==null)return!1;for(var c=i.targetContainers;0<c.length;){var h=ph(i.domEventName,i.eventSystemFlags,c[0],i.nativeEvent);if(h===null){h=i.nativeEvent;var y=new h.constructor(h.type,h);Jf=y,h.target.dispatchEvent(y),Jf=null}else return c=hi(h),c!==null&&uh(c),i.blockedOn=h,!1;c.shift()}return!0}function Nx(i,c,h){Lu(i)&&h.delete(c)}function N2(){ch=!1,pr!==null&&Lu(pr)&&(pr=null),fr!==null&&Lu(fr)&&(fr=null),hr!==null&&Lu(hr)&&(hr=null),Za.forEach(Nx),Ja.forEach(Nx)}function ti(i,c){i.blockedOn===c&&(i.blockedOn=null,ch||(ch=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,N2)))}function ni(i){function c($){return ti($,i)}if(0<Pu.length){ti(Pu[0],i);for(var h=1;h<Pu.length;h++){var y=Pu[h];y.blockedOn===i&&(y.blockedOn=null)}}for(pr!==null&&ti(pr,i),fr!==null&&ti(fr,i),hr!==null&&ti(hr,i),Za.forEach(c),Ja.forEach(c),h=0;h<mr.length;h++)y=mr[h],y.blockedOn===i&&(y.blockedOn=null);for(;0<mr.length&&(h=mr[0],h.blockedOn===null);)kx(h),h.blockedOn===null&&mr.shift()}var jo=N.ReactCurrentBatchConfig,Vu=!0;function I2(i,c,h,y){var $=Ye,S=jo.transition;jo.transition=null;try{Ye=1,dh(i,c,h,y)}finally{Ye=$,jo.transition=S}}function T2(i,c,h,y){var $=Ye,S=jo.transition;jo.transition=null;try{Ye=4,dh(i,c,h,y)}finally{Ye=$,jo.transition=S}}function dh(i,c,h,y){if(Vu){var $=ph(i,c,h,y);if($===null)Eh(i,c,y,Bu,h),Cx(i,y);else if(k2($,i,c,h,y))y.stopPropagation();else if(Cx(i,y),c&4&&-1<C2.indexOf(i)){for(;$!==null;){var S=hi($);if(S!==null&&wx(S),S=ph(i,c,h,y),S===null&&Eh(i,c,y,Bu,h),S===$)break;$=S}$!==null&&y.stopPropagation()}else Eh(i,c,y,null,h)}}var Bu=null;function ph(i,c,h,y){if(Bu=null,i=eh(y),i=to(i),i!==null)if(c=eo(i),c===null)i=null;else if(h=c.tag,h===13){if(i=cx(c),i!==null)return i;i=null}else if(h===3){if(c.stateNode.current.memoizedState.isDehydrated)return c.tag===3?c.stateNode.containerInfo:null;i=null}else c!==i&&(i=null);return Bu=i,null}function Ix(i){switch(i){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(m2()){case oh:return 1;case gx:return 4;case _u:case g2:return 16;case yx:return 536870912;default:return 16}default:return 16}}var gr=null,fh=null,Mu=null;function Tx(){if(Mu)return Mu;var i,c=fh,h=c.length,y,$="value"in gr?gr.value:gr.textContent,S=$.length;for(i=0;i<h&&c[i]===$[i];i++);var E=h-i;for(y=1;y<=E&&c[h-y]===$[S-y];y++);return Mu=$.slice(i,1<y?1-y:void 0)}function zu(i){var c=i.keyCode;return"charCode"in i?(i=i.charCode,i===0&&c===13&&(i=13)):i=c,i===10&&(i=13),32<=i||i===13?i:0}function Wu(){return!0}function Ex(){return!1}function An(i){function c(h,y,$,S,E){this._reactName=h,this._targetInst=$,this.type=y,this.nativeEvent=S,this.target=E,this.currentTarget=null;for(var B in i)i.hasOwnProperty(B)&&(h=i[B],this[B]=h?h(S):S[B]);return this.isDefaultPrevented=(S.defaultPrevented!=null?S.defaultPrevented:S.returnValue===!1)?Wu:Ex,this.isPropagationStopped=Ex,this}return X(c.prototype,{preventDefault:function(){this.defaultPrevented=!0;var h=this.nativeEvent;h&&(h.preventDefault?h.preventDefault():typeof h.returnValue!="unknown"&&(h.returnValue=!1),this.isDefaultPrevented=Wu)},stopPropagation:function(){var h=this.nativeEvent;h&&(h.stopPropagation?h.stopPropagation():typeof h.cancelBubble!="unknown"&&(h.cancelBubble=!0),this.isPropagationStopped=Wu)},persist:function(){},isPersistent:Wu}),c}var qo={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(i){return i.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},hh=An(qo),si=X({},qo,{view:0,detail:0}),E2=An(si),mh,gh,ri,Uu=X({},si,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:xh,button:0,buttons:0,relatedTarget:function(i){return i.relatedTarget===void 0?i.fromElement===i.srcElement?i.toElement:i.fromElement:i.relatedTarget},movementX:function(i){return"movementX"in i?i.movementX:(i!==ri&&(ri&&i.type==="mousemove"?(mh=i.screenX-ri.screenX,gh=i.screenY-ri.screenY):gh=mh=0,ri=i),mh)},movementY:function(i){return"movementY"in i?i.movementY:gh}}),Rx=An(Uu),R2=X({},Uu,{dataTransfer:0}),_2=An(R2),O2=X({},si,{relatedTarget:0}),yh=An(O2),D2=X({},qo,{animationName:0,elapsedTime:0,pseudoElement:0}),A2=An(D2),F2=X({},qo,{clipboardData:function(i){return"clipboardData"in i?i.clipboardData:window.clipboardData}}),P2=An(F2),L2=X({},qo,{data:0}),_x=An(L2),V2={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},B2={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},M2={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function z2(i){var c=this.nativeEvent;return c.getModifierState?c.getModifierState(i):(i=M2[i])?!!c[i]:!1}function xh(){return z2}var W2=X({},si,{key:function(i){if(i.key){var c=V2[i.key]||i.key;if(c!=="Unidentified")return c}return i.type==="keypress"?(i=zu(i),i===13?"Enter":String.fromCharCode(i)):i.type==="keydown"||i.type==="keyup"?B2[i.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:xh,charCode:function(i){return i.type==="keypress"?zu(i):0},keyCode:function(i){return i.type==="keydown"||i.type==="keyup"?i.keyCode:0},which:function(i){return i.type==="keypress"?zu(i):i.type==="keydown"||i.type==="keyup"?i.keyCode:0}}),U2=An(W2),G2=X({},Uu,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Ox=An(G2),H2=X({},si,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:xh}),j2=An(H2),q2=X({},qo,{propertyName:0,elapsedTime:0,pseudoElement:0}),K2=An(q2),X2=X({},Uu,{deltaX:function(i){return"deltaX"in i?i.deltaX:"wheelDeltaX"in i?-i.wheelDeltaX:0},deltaY:function(i){return"deltaY"in i?i.deltaY:"wheelDeltaY"in i?-i.wheelDeltaY:"wheelDelta"in i?-i.wheelDelta:0},deltaZ:0,deltaMode:0}),Y2=An(X2),Q2=[9,13,27,32],vh=l&&"CompositionEvent"in window,oi=null;l&&"documentMode"in document&&(oi=document.documentMode);var Z2=l&&"TextEvent"in window&&!oi,Dx=l&&(!vh||oi&&8<oi&&11>=oi),Ax=" ",Fx=!1;function Px(i,c){switch(i){case"keyup":return Q2.indexOf(c.keyCode)!==-1;case"keydown":return c.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Lx(i){return i=i.detail,typeof i=="object"&&"data"in i?i.data:null}var Ko=!1;function J2(i,c){switch(i){case"compositionend":return Lx(c);case"keypress":return c.which!==32?null:(Fx=!0,Ax);case"textInput":return i=c.data,i===Ax&&Fx?null:i;default:return null}}function eI(i,c){if(Ko)return i==="compositionend"||!vh&&Px(i,c)?(i=Tx(),Mu=fh=gr=null,Ko=!1,i):null;switch(i){case"paste":return null;case"keypress":if(!(c.ctrlKey||c.altKey||c.metaKey)||c.ctrlKey&&c.altKey){if(c.char&&1<c.char.length)return c.char;if(c.which)return String.fromCharCode(c.which)}return null;case"compositionend":return Dx&&c.locale!=="ko"?null:c.data;default:return null}}var tI={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Vx(i){var c=i&&i.nodeName&&i.nodeName.toLowerCase();return c==="input"?!!tI[i.type]:c==="textarea"}function Bx(i,c,h,y){ox(y),c=Ku(c,"onChange"),0<c.length&&(h=new hh("onChange","change",null,h,y),i.push({event:h,listeners:c}))}var ai=null,ii=null;function nI(i){s1(i,0)}function Gu(i){var c=Jo(i);if(ze(c))return i}function sI(i,c){if(i==="change")return c}var Mx=!1;if(l){var wh;if(l){var bh="oninput"in document;if(!bh){var zx=document.createElement("div");zx.setAttribute("oninput","return;"),bh=typeof zx.oninput=="function"}wh=bh}else wh=!1;Mx=wh&&(!document.documentMode||9<document.documentMode)}function Wx(){ai&&(ai.detachEvent("onpropertychange",Ux),ii=ai=null)}function Ux(i){if(i.propertyName==="value"&&Gu(ii)){var c=[];Bx(c,ii,i,eh(i)),ux(nI,c)}}function rI(i,c,h){i==="focusin"?(Wx(),ai=c,ii=h,ai.attachEvent("onpropertychange",Ux)):i==="focusout"&&Wx()}function oI(i){if(i==="selectionchange"||i==="keyup"||i==="keydown")return Gu(ii)}function aI(i,c){if(i==="click")return Gu(c)}function iI(i,c){if(i==="input"||i==="change")return Gu(c)}function lI(i,c){return i===c&&(i!==0||1/i===1/c)||i!==i&&c!==c}var os=typeof Object.is=="function"?Object.is:lI;function li(i,c){if(os(i,c))return!0;if(typeof i!="object"||i===null||typeof c!="object"||c===null)return!1;var h=Object.keys(i),y=Object.keys(c);if(h.length!==y.length)return!1;for(y=0;y<h.length;y++){var $=h[y];if(!u.call(c,$)||!os(i[$],c[$]))return!1}return!0}function Gx(i){for(;i&&i.firstChild;)i=i.firstChild;return i}function Hx(i,c){var h=Gx(i);i=0;for(var y;h;){if(h.nodeType===3){if(y=i+h.textContent.length,i<=c&&y>=c)return{node:h,offset:c-i};i=y}e:{for(;h;){if(h.nextSibling){h=h.nextSibling;break e}h=h.parentNode}h=void 0}h=Gx(h)}}function jx(i,c){return i&&c?i===c?!0:i&&i.nodeType===3?!1:c&&c.nodeType===3?jx(i,c.parentNode):"contains"in i?i.contains(c):i.compareDocumentPosition?!!(i.compareDocumentPosition(c)&16):!1:!1}function qx(){for(var i=window,c=Ge();c instanceof i.HTMLIFrameElement;){try{var h=typeof c.contentWindow.location.href=="string"}catch{h=!1}if(h)i=c.contentWindow;else break;c=Ge(i.document)}return c}function $h(i){var c=i&&i.nodeName&&i.nodeName.toLowerCase();return c&&(c==="input"&&(i.type==="text"||i.type==="search"||i.type==="tel"||i.type==="url"||i.type==="password")||c==="textarea"||i.contentEditable==="true")}function uI(i){var c=qx(),h=i.focusedElem,y=i.selectionRange;if(c!==h&&h&&h.ownerDocument&&jx(h.ownerDocument.documentElement,h)){if(y!==null&&$h(h)){if(c=y.start,i=y.end,i===void 0&&(i=c),"selectionStart"in h)h.selectionStart=c,h.selectionEnd=Math.min(i,h.value.length);else if(i=(c=h.ownerDocument||document)&&c.defaultView||window,i.getSelection){i=i.getSelection();var $=h.textContent.length,S=Math.min(y.start,$);y=y.end===void 0?S:Math.min(y.end,$),!i.extend&&S>y&&($=y,y=S,S=$),$=Hx(h,S);var E=Hx(h,y);$&&E&&(i.rangeCount!==1||i.anchorNode!==$.node||i.anchorOffset!==$.offset||i.focusNode!==E.node||i.focusOffset!==E.offset)&&(c=c.createRange(),c.setStart($.node,$.offset),i.removeAllRanges(),S>y?(i.addRange(c),i.extend(E.node,E.offset)):(c.setEnd(E.node,E.offset),i.addRange(c)))}}for(c=[],i=h;i=i.parentNode;)i.nodeType===1&&c.push({element:i,left:i.scrollLeft,top:i.scrollTop});for(typeof h.focus=="function"&&h.focus(),h=0;h<c.length;h++)i=c[h],i.element.scrollLeft=i.left,i.element.scrollTop=i.top}}var cI=l&&"documentMode"in document&&11>=document.documentMode,Xo=null,Sh=null,ui=null,Ch=!1;function Kx(i,c,h){var y=h.window===h?h.document:h.nodeType===9?h:h.ownerDocument;Ch||Xo==null||Xo!==Ge(y)||(y=Xo,"selectionStart"in y&&$h(y)?y={start:y.selectionStart,end:y.selectionEnd}:(y=(y.ownerDocument&&y.ownerDocument.defaultView||window).getSelection(),y={anchorNode:y.anchorNode,anchorOffset:y.anchorOffset,focusNode:y.focusNode,focusOffset:y.focusOffset}),ui&&li(ui,y)||(ui=y,y=Ku(Sh,"onSelect"),0<y.length&&(c=new hh("onSelect","select",null,c,h),i.push({event:c,listeners:y}),c.target=Xo)))}function Hu(i,c){var h={};return h[i.toLowerCase()]=c.toLowerCase(),h["Webkit"+i]="webkit"+c,h["Moz"+i]="moz"+c,h}var Yo={animationend:Hu("Animation","AnimationEnd"),animationiteration:Hu("Animation","AnimationIteration"),animationstart:Hu("Animation","AnimationStart"),transitionend:Hu("Transition","TransitionEnd")},kh={},Xx={};l&&(Xx=document.createElement("div").style,"AnimationEvent"in window||(delete Yo.animationend.animation,delete Yo.animationiteration.animation,delete Yo.animationstart.animation),"TransitionEvent"in window||delete Yo.transitionend.transition);function ju(i){if(kh[i])return kh[i];if(!Yo[i])return i;var c=Yo[i],h;for(h in c)if(c.hasOwnProperty(h)&&h in Xx)return kh[i]=c[h];return i}var Yx=ju("animationend"),Qx=ju("animationiteration"),Zx=ju("animationstart"),Jx=ju("transitionend"),e1=new Map,t1="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function yr(i,c){e1.set(i,c),o(c,[i])}for(var Nh=0;Nh<t1.length;Nh++){var Ih=t1[Nh],dI=Ih.toLowerCase(),pI=Ih[0].toUpperCase()+Ih.slice(1);yr(dI,"on"+pI)}yr(Yx,"onAnimationEnd"),yr(Qx,"onAnimationIteration"),yr(Zx,"onAnimationStart"),yr("dblclick","onDoubleClick"),yr("focusin","onFocus"),yr("focusout","onBlur"),yr(Jx,"onTransitionEnd"),a("onMouseEnter",["mouseout","mouseover"]),a("onMouseLeave",["mouseout","mouseover"]),a("onPointerEnter",["pointerout","pointerover"]),a("onPointerLeave",["pointerout","pointerover"]),o("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),o("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),o("onBeforeInput",["compositionend","keypress","textInput","paste"]),o("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),o("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),o("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var ci="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),fI=new Set("cancel close invalid load scroll toggle".split(" ").concat(ci));function n1(i,c,h){var y=i.type||"unknown-event";i.currentTarget=h,d2(y,c,void 0,i),i.currentTarget=null}function s1(i,c){c=(c&4)!==0;for(var h=0;h<i.length;h++){var y=i[h],$=y.event;y=y.listeners;e:{var S=void 0;if(c)for(var E=y.length-1;0<=E;E--){var B=y[E],G=B.instance,se=B.currentTarget;if(B=B.listener,G!==S&&$.isPropagationStopped())break e;n1($,B,se),S=G}else for(E=0;E<y.length;E++){if(B=y[E],G=B.instance,se=B.currentTarget,B=B.listener,G!==S&&$.isPropagationStopped())break e;n1($,B,se),S=G}}}if(Ru)throw i=rh,Ru=!1,rh=null,i}function ut(i,c){var h=c[Fh];h===void 0&&(h=c[Fh]=new Set);var y=i+"__bubble";h.has(y)||(r1(c,i,2,!1),h.add(y))}function Th(i,c,h){var y=0;c&&(y|=4),r1(h,i,y,c)}var qu="_reactListening"+Math.random().toString(36).slice(2);function di(i){if(!i[qu]){i[qu]=!0,s.forEach(function(h){h!=="selectionchange"&&(fI.has(h)||Th(h,!1,i),Th(h,!0,i))});var c=i.nodeType===9?i:i.ownerDocument;c===null||c[qu]||(c[qu]=!0,Th("selectionchange",!1,c))}}function r1(i,c,h,y){switch(Ix(c)){case 1:var $=I2;break;case 4:$=T2;break;default:$=dh}h=$.bind(null,c,h,i),$=void 0,!sh||c!=="touchstart"&&c!=="touchmove"&&c!=="wheel"||($=!0),y?$!==void 0?i.addEventListener(c,h,{capture:!0,passive:$}):i.addEventListener(c,h,!0):$!==void 0?i.addEventListener(c,h,{passive:$}):i.addEventListener(c,h,!1)}function Eh(i,c,h,y,$){var S=y;if(!(c&1)&&!(c&2)&&y!==null)e:for(;;){if(y===null)return;var E=y.tag;if(E===3||E===4){var B=y.stateNode.containerInfo;if(B===$||B.nodeType===8&&B.parentNode===$)break;if(E===4)for(E=y.return;E!==null;){var G=E.tag;if((G===3||G===4)&&(G=E.stateNode.containerInfo,G===$||G.nodeType===8&&G.parentNode===$))return;E=E.return}for(;B!==null;){if(E=to(B),E===null)return;if(G=E.tag,G===5||G===6){y=S=E;continue e}B=B.parentNode}}y=y.return}ux(function(){var se=S,de=eh(h),pe=[];e:{var ce=e1.get(i);if(ce!==void 0){var we=hh,Se=i;switch(i){case"keypress":if(zu(h)===0)break e;case"keydown":case"keyup":we=U2;break;case"focusin":Se="focus",we=yh;break;case"focusout":Se="blur",we=yh;break;case"beforeblur":case"afterblur":we=yh;break;case"click":if(h.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":we=Rx;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":we=_2;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":we=j2;break;case Yx:case Qx:case Zx:we=A2;break;case Jx:we=K2;break;case"scroll":we=E2;break;case"wheel":we=Y2;break;case"copy":case"cut":case"paste":we=P2;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":we=Ox}var ke=(c&4)!==0,Ct=!ke&&i==="scroll",ee=ke?ce!==null?ce+"Capture":null:ce;ke=[];for(var q=se,te;q!==null;){te=q;var fe=te.stateNode;if(te.tag===5&&fe!==null&&(te=fe,ee!==null&&(fe=qa(q,ee),fe!=null&&ke.push(pi(q,fe,te)))),Ct)break;q=q.return}0<ke.length&&(ce=new we(ce,Se,null,h,de),pe.push({event:ce,listeners:ke}))}}if(!(c&7)){e:{if(ce=i==="mouseover"||i==="pointerover",we=i==="mouseout"||i==="pointerout",ce&&h!==Jf&&(Se=h.relatedTarget||h.fromElement)&&(to(Se)||Se[Ms]))break e;if((we||ce)&&(ce=de.window===de?de:(ce=de.ownerDocument)?ce.defaultView||ce.parentWindow:window,we?(Se=h.relatedTarget||h.toElement,we=se,Se=Se?to(Se):null,Se!==null&&(Ct=eo(Se),Se!==Ct||Se.tag!==5&&Se.tag!==6)&&(Se=null)):(we=null,Se=se),we!==Se)){if(ke=Rx,fe="onMouseLeave",ee="onMouseEnter",q="mouse",(i==="pointerout"||i==="pointerover")&&(ke=Ox,fe="onPointerLeave",ee="onPointerEnter",q="pointer"),Ct=we==null?ce:Jo(we),te=Se==null?ce:Jo(Se),ce=new ke(fe,q+"leave",we,h,de),ce.target=Ct,ce.relatedTarget=te,fe=null,to(de)===se&&(ke=new ke(ee,q+"enter",Se,h,de),ke.target=te,ke.relatedTarget=Ct,fe=ke),Ct=fe,we&&Se)t:{for(ke=we,ee=Se,q=0,te=ke;te;te=Qo(te))q++;for(te=0,fe=ee;fe;fe=Qo(fe))te++;for(;0<q-te;)ke=Qo(ke),q--;for(;0<te-q;)ee=Qo(ee),te--;for(;q--;){if(ke===ee||ee!==null&&ke===ee.alternate)break t;ke=Qo(ke),ee=Qo(ee)}ke=null}else ke=null;we!==null&&o1(pe,ce,we,ke,!1),Se!==null&&Ct!==null&&o1(pe,Ct,Se,ke,!0)}}e:{if(ce=se?Jo(se):window,we=ce.nodeName&&ce.nodeName.toLowerCase(),we==="select"||we==="input"&&ce.type==="file")var Ne=sI;else if(Vx(ce))if(Mx)Ne=iI;else{Ne=oI;var Ee=rI}else(we=ce.nodeName)&&we.toLowerCase()==="input"&&(ce.type==="checkbox"||ce.type==="radio")&&(Ne=aI);if(Ne&&(Ne=Ne(i,se))){Bx(pe,Ne,h,de);break e}Ee&&Ee(i,ce,se),i==="focusout"&&(Ee=ce._wrapperState)&&Ee.controlled&&ce.type==="number"&&On(ce,"number",ce.value)}switch(Ee=se?Jo(se):window,i){case"focusin":(Vx(Ee)||Ee.contentEditable==="true")&&(Xo=Ee,Sh=se,ui=null);break;case"focusout":ui=Sh=Xo=null;break;case"mousedown":Ch=!0;break;case"contextmenu":case"mouseup":case"dragend":Ch=!1,Kx(pe,h,de);break;case"selectionchange":if(cI)break;case"keydown":case"keyup":Kx(pe,h,de)}var Re;if(vh)e:{switch(i){case"compositionstart":var Oe="onCompositionStart";break e;case"compositionend":Oe="onCompositionEnd";break e;case"compositionupdate":Oe="onCompositionUpdate";break e}Oe=void 0}else Ko?Px(i,h)&&(Oe="onCompositionEnd"):i==="keydown"&&h.keyCode===229&&(Oe="onCompositionStart");Oe&&(Dx&&h.locale!=="ko"&&(Ko||Oe!=="onCompositionStart"?Oe==="onCompositionEnd"&&Ko&&(Re=Tx()):(gr=de,fh="value"in gr?gr.value:gr.textContent,Ko=!0)),Ee=Ku(se,Oe),0<Ee.length&&(Oe=new _x(Oe,i,null,h,de),pe.push({event:Oe,listeners:Ee}),Re?Oe.data=Re:(Re=Lx(h),Re!==null&&(Oe.data=Re)))),(Re=Z2?J2(i,h):eI(i,h))&&(se=Ku(se,"onBeforeInput"),0<se.length&&(de=new _x("onBeforeInput","beforeinput",null,h,de),pe.push({event:de,listeners:se}),de.data=Re))}s1(pe,c)})}function pi(i,c,h){return{instance:i,listener:c,currentTarget:h}}function Ku(i,c){for(var h=c+"Capture",y=[];i!==null;){var $=i,S=$.stateNode;$.tag===5&&S!==null&&($=S,S=qa(i,h),S!=null&&y.unshift(pi(i,S,$)),S=qa(i,c),S!=null&&y.push(pi(i,S,$))),i=i.return}return y}function Qo(i){if(i===null)return null;do i=i.return;while(i&&i.tag!==5);return i||null}function o1(i,c,h,y,$){for(var S=c._reactName,E=[];h!==null&&h!==y;){var B=h,G=B.alternate,se=B.stateNode;if(G!==null&&G===y)break;B.tag===5&&se!==null&&(B=se,$?(G=qa(h,S),G!=null&&E.unshift(pi(h,G,B))):$||(G=qa(h,S),G!=null&&E.push(pi(h,G,B)))),h=h.return}E.length!==0&&i.push({event:c,listeners:E})}var hI=/\r\n?/g,mI=/\u0000|\uFFFD/g;function a1(i){return(typeof i=="string"?i:""+i).replace(hI,`
`).replace(mI,"")}function Xu(i,c,h){if(c=a1(c),a1(i)!==c&&h)throw Error(t(425))}function Yu(){}var Rh=null,_h=null;function Oh(i,c){return i==="textarea"||i==="noscript"||typeof c.children=="string"||typeof c.children=="number"||typeof c.dangerouslySetInnerHTML=="object"&&c.dangerouslySetInnerHTML!==null&&c.dangerouslySetInnerHTML.__html!=null}var Dh=typeof setTimeout=="function"?setTimeout:void 0,gI=typeof clearTimeout=="function"?clearTimeout:void 0,i1=typeof Promise=="function"?Promise:void 0,yI=typeof queueMicrotask=="function"?queueMicrotask:typeof i1<"u"?function(i){return i1.resolve(null).then(i).catch(xI)}:Dh;function xI(i){setTimeout(function(){throw i})}function Ah(i,c){var h=c,y=0;do{var $=h.nextSibling;if(i.removeChild(h),$&&$.nodeType===8)if(h=$.data,h==="/$"){if(y===0){i.removeChild($),ni(c);return}y--}else h!=="$"&&h!=="$?"&&h!=="$!"||y++;h=$}while(h);ni(c)}function xr(i){for(;i!=null;i=i.nextSibling){var c=i.nodeType;if(c===1||c===3)break;if(c===8){if(c=i.data,c==="$"||c==="$!"||c==="$?")break;if(c==="/$")return null}}return i}function l1(i){i=i.previousSibling;for(var c=0;i;){if(i.nodeType===8){var h=i.data;if(h==="$"||h==="$!"||h==="$?"){if(c===0)return i;c--}else h==="/$"&&c++}i=i.previousSibling}return null}var Zo=Math.random().toString(36).slice(2),$s="__reactFiber$"+Zo,fi="__reactProps$"+Zo,Ms="__reactContainer$"+Zo,Fh="__reactEvents$"+Zo,vI="__reactListeners$"+Zo,wI="__reactHandles$"+Zo;function to(i){var c=i[$s];if(c)return c;for(var h=i.parentNode;h;){if(c=h[Ms]||h[$s]){if(h=c.alternate,c.child!==null||h!==null&&h.child!==null)for(i=l1(i);i!==null;){if(h=i[$s])return h;i=l1(i)}return c}i=h,h=i.parentNode}return null}function hi(i){return i=i[$s]||i[Ms],!i||i.tag!==5&&i.tag!==6&&i.tag!==13&&i.tag!==3?null:i}function Jo(i){if(i.tag===5||i.tag===6)return i.stateNode;throw Error(t(33))}function Qu(i){return i[fi]||null}var Ph=[],ea=-1;function vr(i){return{current:i}}function ct(i){0>ea||(i.current=Ph[ea],Ph[ea]=null,ea--)}function lt(i,c){ea++,Ph[ea]=i.current,i.current=c}var wr={},Zt=vr(wr),yn=vr(!1),no=wr;function ta(i,c){var h=i.type.contextTypes;if(!h)return wr;var y=i.stateNode;if(y&&y.__reactInternalMemoizedUnmaskedChildContext===c)return y.__reactInternalMemoizedMaskedChildContext;var $={},S;for(S in h)$[S]=c[S];return y&&(i=i.stateNode,i.__reactInternalMemoizedUnmaskedChildContext=c,i.__reactInternalMemoizedMaskedChildContext=$),$}function xn(i){return i=i.childContextTypes,i!=null}function Zu(){ct(yn),ct(Zt)}function u1(i,c,h){if(Zt.current!==wr)throw Error(t(168));lt(Zt,c),lt(yn,h)}function c1(i,c,h){var y=i.stateNode;if(c=c.childContextTypes,typeof y.getChildContext!="function")return h;y=y.getChildContext();for(var $ in y)if(!($ in c))throw Error(t(108,he(i)||"Unknown",$));return X({},h,y)}function Ju(i){return i=(i=i.stateNode)&&i.__reactInternalMemoizedMergedChildContext||wr,no=Zt.current,lt(Zt,i),lt(yn,yn.current),!0}function d1(i,c,h){var y=i.stateNode;if(!y)throw Error(t(169));h?(i=c1(i,c,no),y.__reactInternalMemoizedMergedChildContext=i,ct(yn),ct(Zt),lt(Zt,i)):ct(yn),lt(yn,h)}var zs=null,ec=!1,Lh=!1;function p1(i){zs===null?zs=[i]:zs.push(i)}function bI(i){ec=!0,p1(i)}function br(){if(!Lh&&zs!==null){Lh=!0;var i=0,c=Ye;try{var h=zs;for(Ye=1;i<h.length;i++){var y=h[i];do y=y(!0);while(y!==null)}zs=null,ec=!1}catch($){throw zs!==null&&(zs=zs.slice(i+1)),hx(oh,br),$}finally{Ye=c,Lh=!1}}return null}var na=[],sa=0,tc=null,nc=0,Gn=[],Hn=0,so=null,Ws=1,Us="";function ro(i,c){na[sa++]=nc,na[sa++]=tc,tc=i,nc=c}function f1(i,c,h){Gn[Hn++]=Ws,Gn[Hn++]=Us,Gn[Hn++]=so,so=i;var y=Ws;i=Us;var $=32-rs(y)-1;y&=~(1<<$),h+=1;var S=32-rs(c)+$;if(30<S){var E=$-$%5;S=(y&(1<<E)-1).toString(32),y>>=E,$-=E,Ws=1<<32-rs(c)+$|h<<$|y,Us=S+i}else Ws=1<<S|h<<$|y,Us=i}function Vh(i){i.return!==null&&(ro(i,1),f1(i,1,0))}function Bh(i){for(;i===tc;)tc=na[--sa],na[sa]=null,nc=na[--sa],na[sa]=null;for(;i===so;)so=Gn[--Hn],Gn[Hn]=null,Us=Gn[--Hn],Gn[Hn]=null,Ws=Gn[--Hn],Gn[Hn]=null}var Fn=null,Pn=null,pt=!1,as=null;function h1(i,c){var h=Xn(5,null,null,0);h.elementType="DELETED",h.stateNode=c,h.return=i,c=i.deletions,c===null?(i.deletions=[h],i.flags|=16):c.push(h)}function m1(i,c){switch(i.tag){case 5:var h=i.type;return c=c.nodeType!==1||h.toLowerCase()!==c.nodeName.toLowerCase()?null:c,c!==null?(i.stateNode=c,Fn=i,Pn=xr(c.firstChild),!0):!1;case 6:return c=i.pendingProps===""||c.nodeType!==3?null:c,c!==null?(i.stateNode=c,Fn=i,Pn=null,!0):!1;case 13:return c=c.nodeType!==8?null:c,c!==null?(h=so!==null?{id:Ws,overflow:Us}:null,i.memoizedState={dehydrated:c,treeContext:h,retryLane:1073741824},h=Xn(18,null,null,0),h.stateNode=c,h.return=i,i.child=h,Fn=i,Pn=null,!0):!1;default:return!1}}function Mh(i){return(i.mode&1)!==0&&(i.flags&128)===0}function zh(i){if(pt){var c=Pn;if(c){var h=c;if(!m1(i,c)){if(Mh(i))throw Error(t(418));c=xr(h.nextSibling);var y=Fn;c&&m1(i,c)?h1(y,h):(i.flags=i.flags&-4097|2,pt=!1,Fn=i)}}else{if(Mh(i))throw Error(t(418));i.flags=i.flags&-4097|2,pt=!1,Fn=i}}}function g1(i){for(i=i.return;i!==null&&i.tag!==5&&i.tag!==3&&i.tag!==13;)i=i.return;Fn=i}function sc(i){if(i!==Fn)return!1;if(!pt)return g1(i),pt=!0,!1;var c;if((c=i.tag!==3)&&!(c=i.tag!==5)&&(c=i.type,c=c!=="head"&&c!=="body"&&!Oh(i.type,i.memoizedProps)),c&&(c=Pn)){if(Mh(i))throw y1(),Error(t(418));for(;c;)h1(i,c),c=xr(c.nextSibling)}if(g1(i),i.tag===13){if(i=i.memoizedState,i=i!==null?i.dehydrated:null,!i)throw Error(t(317));e:{for(i=i.nextSibling,c=0;i;){if(i.nodeType===8){var h=i.data;if(h==="/$"){if(c===0){Pn=xr(i.nextSibling);break e}c--}else h!=="$"&&h!=="$!"&&h!=="$?"||c++}i=i.nextSibling}Pn=null}}else Pn=Fn?xr(i.stateNode.nextSibling):null;return!0}function y1(){for(var i=Pn;i;)i=xr(i.nextSibling)}function ra(){Pn=Fn=null,pt=!1}function Wh(i){as===null?as=[i]:as.push(i)}var $I=N.ReactCurrentBatchConfig;function mi(i,c,h){if(i=h.ref,i!==null&&typeof i!="function"&&typeof i!="object"){if(h._owner){if(h=h._owner,h){if(h.tag!==1)throw Error(t(309));var y=h.stateNode}if(!y)throw Error(t(147,i));var $=y,S=""+i;return c!==null&&c.ref!==null&&typeof c.ref=="function"&&c.ref._stringRef===S?c.ref:(c=function(E){var B=$.refs;E===null?delete B[S]:B[S]=E},c._stringRef=S,c)}if(typeof i!="string")throw Error(t(284));if(!h._owner)throw Error(t(290,i))}return i}function rc(i,c){throw i=Object.prototype.toString.call(c),Error(t(31,i==="[object Object]"?"object with keys {"+Object.keys(c).join(", ")+"}":i))}function x1(i){var c=i._init;return c(i._payload)}function v1(i){function c(ee,q){if(i){var te=ee.deletions;te===null?(ee.deletions=[q],ee.flags|=16):te.push(q)}}function h(ee,q){if(!i)return null;for(;q!==null;)c(ee,q),q=q.sibling;return null}function y(ee,q){for(ee=new Map;q!==null;)q.key!==null?ee.set(q.key,q):ee.set(q.index,q),q=q.sibling;return ee}function $(ee,q){return ee=Er(ee,q),ee.index=0,ee.sibling=null,ee}function S(ee,q,te){return ee.index=te,i?(te=ee.alternate,te!==null?(te=te.index,te<q?(ee.flags|=2,q):te):(ee.flags|=2,q)):(ee.flags|=1048576,q)}function E(ee){return i&&ee.alternate===null&&(ee.flags|=2),ee}function B(ee,q,te,fe){return q===null||q.tag!==6?(q=Dm(te,ee.mode,fe),q.return=ee,q):(q=$(q,te),q.return=ee,q)}function G(ee,q,te,fe){var Ne=te.type;return Ne===F?de(ee,q,te.props.children,fe,te.key):q!==null&&(q.elementType===Ne||typeof Ne=="object"&&Ne!==null&&Ne.$$typeof===Z&&x1(Ne)===q.type)?(fe=$(q,te.props),fe.ref=mi(ee,q,te),fe.return=ee,fe):(fe=Tc(te.type,te.key,te.props,null,ee.mode,fe),fe.ref=mi(ee,q,te),fe.return=ee,fe)}function se(ee,q,te,fe){return q===null||q.tag!==4||q.stateNode.containerInfo!==te.containerInfo||q.stateNode.implementation!==te.implementation?(q=Am(te,ee.mode,fe),q.return=ee,q):(q=$(q,te.children||[]),q.return=ee,q)}function de(ee,q,te,fe,Ne){return q===null||q.tag!==7?(q=fo(te,ee.mode,fe,Ne),q.return=ee,q):(q=$(q,te),q.return=ee,q)}function pe(ee,q,te){if(typeof q=="string"&&q!==""||typeof q=="number")return q=Dm(""+q,ee.mode,te),q.return=ee,q;if(typeof q=="object"&&q!==null){switch(q.$$typeof){case R:return te=Tc(q.type,q.key,q.props,null,ee.mode,te),te.ref=mi(ee,null,q),te.return=ee,te;case D:return q=Am(q,ee.mode,te),q.return=ee,q;case Z:var fe=q._init;return pe(ee,fe(q._payload),te)}if(dt(q)||K(q))return q=fo(q,ee.mode,te,null),q.return=ee,q;rc(ee,q)}return null}function ce(ee,q,te,fe){var Ne=q!==null?q.key:null;if(typeof te=="string"&&te!==""||typeof te=="number")return Ne!==null?null:B(ee,q,""+te,fe);if(typeof te=="object"&&te!==null){switch(te.$$typeof){case R:return te.key===Ne?G(ee,q,te,fe):null;case D:return te.key===Ne?se(ee,q,te,fe):null;case Z:return Ne=te._init,ce(ee,q,Ne(te._payload),fe)}if(dt(te)||K(te))return Ne!==null?null:de(ee,q,te,fe,null);rc(ee,te)}return null}function we(ee,q,te,fe,Ne){if(typeof fe=="string"&&fe!==""||typeof fe=="number")return ee=ee.get(te)||null,B(q,ee,""+fe,Ne);if(typeof fe=="object"&&fe!==null){switch(fe.$$typeof){case R:return ee=ee.get(fe.key===null?te:fe.key)||null,G(q,ee,fe,Ne);case D:return ee=ee.get(fe.key===null?te:fe.key)||null,se(q,ee,fe,Ne);case Z:var Ee=fe._init;return we(ee,q,te,Ee(fe._payload),Ne)}if(dt(fe)||K(fe))return ee=ee.get(te)||null,de(q,ee,fe,Ne,null);rc(q,fe)}return null}function Se(ee,q,te,fe){for(var Ne=null,Ee=null,Re=q,Oe=q=0,Lt=null;Re!==null&&Oe<te.length;Oe++){Re.index>Oe?(Lt=Re,Re=null):Lt=Re.sibling;var je=ce(ee,Re,te[Oe],fe);if(je===null){Re===null&&(Re=Lt);break}i&&Re&&je.alternate===null&&c(ee,Re),q=S(je,q,Oe),Ee===null?Ne=je:Ee.sibling=je,Ee=je,Re=Lt}if(Oe===te.length)return h(ee,Re),pt&&ro(ee,Oe),Ne;if(Re===null){for(;Oe<te.length;Oe++)Re=pe(ee,te[Oe],fe),Re!==null&&(q=S(Re,q,Oe),Ee===null?Ne=Re:Ee.sibling=Re,Ee=Re);return pt&&ro(ee,Oe),Ne}for(Re=y(ee,Re);Oe<te.length;Oe++)Lt=we(Re,ee,Oe,te[Oe],fe),Lt!==null&&(i&&Lt.alternate!==null&&Re.delete(Lt.key===null?Oe:Lt.key),q=S(Lt,q,Oe),Ee===null?Ne=Lt:Ee.sibling=Lt,Ee=Lt);return i&&Re.forEach(function(Rr){return c(ee,Rr)}),pt&&ro(ee,Oe),Ne}function ke(ee,q,te,fe){var Ne=K(te);if(typeof Ne!="function")throw Error(t(150));if(te=Ne.call(te),te==null)throw Error(t(151));for(var Ee=Ne=null,Re=q,Oe=q=0,Lt=null,je=te.next();Re!==null&&!je.done;Oe++,je=te.next()){Re.index>Oe?(Lt=Re,Re=null):Lt=Re.sibling;var Rr=ce(ee,Re,je.value,fe);if(Rr===null){Re===null&&(Re=Lt);break}i&&Re&&Rr.alternate===null&&c(ee,Re),q=S(Rr,q,Oe),Ee===null?Ne=Rr:Ee.sibling=Rr,Ee=Rr,Re=Lt}if(je.done)return h(ee,Re),pt&&ro(ee,Oe),Ne;if(Re===null){for(;!je.done;Oe++,je=te.next())je=pe(ee,je.value,fe),je!==null&&(q=S(je,q,Oe),Ee===null?Ne=je:Ee.sibling=je,Ee=je);return pt&&ro(ee,Oe),Ne}for(Re=y(ee,Re);!je.done;Oe++,je=te.next())je=we(Re,ee,Oe,je.value,fe),je!==null&&(i&&je.alternate!==null&&Re.delete(je.key===null?Oe:je.key),q=S(je,q,Oe),Ee===null?Ne=je:Ee.sibling=je,Ee=je);return i&&Re.forEach(function(tT){return c(ee,tT)}),pt&&ro(ee,Oe),Ne}function Ct(ee,q,te,fe){if(typeof te=="object"&&te!==null&&te.type===F&&te.key===null&&(te=te.props.children),typeof te=="object"&&te!==null){switch(te.$$typeof){case R:e:{for(var Ne=te.key,Ee=q;Ee!==null;){if(Ee.key===Ne){if(Ne=te.type,Ne===F){if(Ee.tag===7){h(ee,Ee.sibling),q=$(Ee,te.props.children),q.return=ee,ee=q;break e}}else if(Ee.elementType===Ne||typeof Ne=="object"&&Ne!==null&&Ne.$$typeof===Z&&x1(Ne)===Ee.type){h(ee,Ee.sibling),q=$(Ee,te.props),q.ref=mi(ee,Ee,te),q.return=ee,ee=q;break e}h(ee,Ee);break}else c(ee,Ee);Ee=Ee.sibling}te.type===F?(q=fo(te.props.children,ee.mode,fe,te.key),q.return=ee,ee=q):(fe=Tc(te.type,te.key,te.props,null,ee.mode,fe),fe.ref=mi(ee,q,te),fe.return=ee,ee=fe)}return E(ee);case D:e:{for(Ee=te.key;q!==null;){if(q.key===Ee)if(q.tag===4&&q.stateNode.containerInfo===te.containerInfo&&q.stateNode.implementation===te.implementation){h(ee,q.sibling),q=$(q,te.children||[]),q.return=ee,ee=q;break e}else{h(ee,q);break}else c(ee,q);q=q.sibling}q=Am(te,ee.mode,fe),q.return=ee,ee=q}return E(ee);case Z:return Ee=te._init,Ct(ee,q,Ee(te._payload),fe)}if(dt(te))return Se(ee,q,te,fe);if(K(te))return ke(ee,q,te,fe);rc(ee,te)}return typeof te=="string"&&te!==""||typeof te=="number"?(te=""+te,q!==null&&q.tag===6?(h(ee,q.sibling),q=$(q,te),q.return=ee,ee=q):(h(ee,q),q=Dm(te,ee.mode,fe),q.return=ee,ee=q),E(ee)):h(ee,q)}return Ct}var oa=v1(!0),w1=v1(!1),oc=vr(null),ac=null,aa=null,Uh=null;function Gh(){Uh=aa=ac=null}function Hh(i){var c=oc.current;ct(oc),i._currentValue=c}function jh(i,c,h){for(;i!==null;){var y=i.alternate;if((i.childLanes&c)!==c?(i.childLanes|=c,y!==null&&(y.childLanes|=c)):y!==null&&(y.childLanes&c)!==c&&(y.childLanes|=c),i===h)break;i=i.return}}function ia(i,c){ac=i,Uh=aa=null,i=i.dependencies,i!==null&&i.firstContext!==null&&(i.lanes&c&&(vn=!0),i.firstContext=null)}function jn(i){var c=i._currentValue;if(Uh!==i)if(i={context:i,memoizedValue:c,next:null},aa===null){if(ac===null)throw Error(t(308));aa=i,ac.dependencies={lanes:0,firstContext:i}}else aa=aa.next=i;return c}var oo=null;function qh(i){oo===null?oo=[i]:oo.push(i)}function b1(i,c,h,y){var $=c.interleaved;return $===null?(h.next=h,qh(c)):(h.next=$.next,$.next=h),c.interleaved=h,Gs(i,y)}function Gs(i,c){i.lanes|=c;var h=i.alternate;for(h!==null&&(h.lanes|=c),h=i,i=i.return;i!==null;)i.childLanes|=c,h=i.alternate,h!==null&&(h.childLanes|=c),h=i,i=i.return;return h.tag===3?h.stateNode:null}var $r=!1;function Kh(i){i.updateQueue={baseState:i.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function $1(i,c){i=i.updateQueue,c.updateQueue===i&&(c.updateQueue={baseState:i.baseState,firstBaseUpdate:i.firstBaseUpdate,lastBaseUpdate:i.lastBaseUpdate,shared:i.shared,effects:i.effects})}function Hs(i,c){return{eventTime:i,lane:c,tag:0,payload:null,callback:null,next:null}}function Sr(i,c,h){var y=i.updateQueue;if(y===null)return null;if(y=y.shared,We&2){var $=y.pending;return $===null?c.next=c:(c.next=$.next,$.next=c),y.pending=c,Gs(i,h)}return $=y.interleaved,$===null?(c.next=c,qh(y)):(c.next=$.next,$.next=c),y.interleaved=c,Gs(i,h)}function ic(i,c,h){if(c=c.updateQueue,c!==null&&(c=c.shared,(h&4194240)!==0)){var y=c.lanes;y&=i.pendingLanes,h|=y,c.lanes=h,lh(i,h)}}function S1(i,c){var h=i.updateQueue,y=i.alternate;if(y!==null&&(y=y.updateQueue,h===y)){var $=null,S=null;if(h=h.firstBaseUpdate,h!==null){do{var E={eventTime:h.eventTime,lane:h.lane,tag:h.tag,payload:h.payload,callback:h.callback,next:null};S===null?$=S=E:S=S.next=E,h=h.next}while(h!==null);S===null?$=S=c:S=S.next=c}else $=S=c;h={baseState:y.baseState,firstBaseUpdate:$,lastBaseUpdate:S,shared:y.shared,effects:y.effects},i.updateQueue=h;return}i=h.lastBaseUpdate,i===null?h.firstBaseUpdate=c:i.next=c,h.lastBaseUpdate=c}function lc(i,c,h,y){var $=i.updateQueue;$r=!1;var S=$.firstBaseUpdate,E=$.lastBaseUpdate,B=$.shared.pending;if(B!==null){$.shared.pending=null;var G=B,se=G.next;G.next=null,E===null?S=se:E.next=se,E=G;var de=i.alternate;de!==null&&(de=de.updateQueue,B=de.lastBaseUpdate,B!==E&&(B===null?de.firstBaseUpdate=se:B.next=se,de.lastBaseUpdate=G))}if(S!==null){var pe=$.baseState;E=0,de=se=G=null,B=S;do{var ce=B.lane,we=B.eventTime;if((y&ce)===ce){de!==null&&(de=de.next={eventTime:we,lane:0,tag:B.tag,payload:B.payload,callback:B.callback,next:null});e:{var Se=i,ke=B;switch(ce=c,we=h,ke.tag){case 1:if(Se=ke.payload,typeof Se=="function"){pe=Se.call(we,pe,ce);break e}pe=Se;break e;case 3:Se.flags=Se.flags&-65537|128;case 0:if(Se=ke.payload,ce=typeof Se=="function"?Se.call(we,pe,ce):Se,ce==null)break e;pe=X({},pe,ce);break e;case 2:$r=!0}}B.callback!==null&&B.lane!==0&&(i.flags|=64,ce=$.effects,ce===null?$.effects=[B]:ce.push(B))}else we={eventTime:we,lane:ce,tag:B.tag,payload:B.payload,callback:B.callback,next:null},de===null?(se=de=we,G=pe):de=de.next=we,E|=ce;if(B=B.next,B===null){if(B=$.shared.pending,B===null)break;ce=B,B=ce.next,ce.next=null,$.lastBaseUpdate=ce,$.shared.pending=null}}while(!0);if(de===null&&(G=pe),$.baseState=G,$.firstBaseUpdate=se,$.lastBaseUpdate=de,c=$.shared.interleaved,c!==null){$=c;do E|=$.lane,$=$.next;while($!==c)}else S===null&&($.shared.lanes=0);lo|=E,i.lanes=E,i.memoizedState=pe}}function C1(i,c,h){if(i=c.effects,c.effects=null,i!==null)for(c=0;c<i.length;c++){var y=i[c],$=y.callback;if($!==null){if(y.callback=null,y=h,typeof $!="function")throw Error(t(191,$));$.call(y)}}}var gi={},Ss=vr(gi),yi=vr(gi),xi=vr(gi);function ao(i){if(i===gi)throw Error(t(174));return i}function Xh(i,c){switch(lt(xi,c),lt(yi,i),lt(Ss,gi),i=c.nodeType,i){case 9:case 11:c=(c=c.documentElement)?c.namespaceURI:Un(null,"");break;default:i=i===8?c.parentNode:c,c=i.namespaceURI||null,i=i.tagName,c=Un(c,i)}ct(Ss),lt(Ss,c)}function la(){ct(Ss),ct(yi),ct(xi)}function k1(i){ao(xi.current);var c=ao(Ss.current),h=Un(c,i.type);c!==h&&(lt(yi,i),lt(Ss,h))}function Yh(i){yi.current===i&&(ct(Ss),ct(yi))}var mt=vr(0);function uc(i){for(var c=i;c!==null;){if(c.tag===13){var h=c.memoizedState;if(h!==null&&(h=h.dehydrated,h===null||h.data==="$?"||h.data==="$!"))return c}else if(c.tag===19&&c.memoizedProps.revealOrder!==void 0){if(c.flags&128)return c}else if(c.child!==null){c.child.return=c,c=c.child;continue}if(c===i)break;for(;c.sibling===null;){if(c.return===null||c.return===i)return null;c=c.return}c.sibling.return=c.return,c=c.sibling}return null}var Qh=[];function Zh(){for(var i=0;i<Qh.length;i++)Qh[i]._workInProgressVersionPrimary=null;Qh.length=0}var cc=N.ReactCurrentDispatcher,Jh=N.ReactCurrentBatchConfig,io=0,gt=null,Et=null,Ft=null,dc=!1,vi=!1,wi=0,SI=0;function Jt(){throw Error(t(321))}function em(i,c){if(c===null)return!1;for(var h=0;h<c.length&&h<i.length;h++)if(!os(i[h],c[h]))return!1;return!0}function tm(i,c,h,y,$,S){if(io=S,gt=c,c.memoizedState=null,c.updateQueue=null,c.lanes=0,cc.current=i===null||i.memoizedState===null?II:TI,i=h(y,$),vi){S=0;do{if(vi=!1,wi=0,25<=S)throw Error(t(301));S+=1,Ft=Et=null,c.updateQueue=null,cc.current=EI,i=h(y,$)}while(vi)}if(cc.current=hc,c=Et!==null&&Et.next!==null,io=0,Ft=Et=gt=null,dc=!1,c)throw Error(t(300));return i}function nm(){var i=wi!==0;return wi=0,i}function Cs(){var i={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Ft===null?gt.memoizedState=Ft=i:Ft=Ft.next=i,Ft}function qn(){if(Et===null){var i=gt.alternate;i=i!==null?i.memoizedState:null}else i=Et.next;var c=Ft===null?gt.memoizedState:Ft.next;if(c!==null)Ft=c,Et=i;else{if(i===null)throw Error(t(310));Et=i,i={memoizedState:Et.memoizedState,baseState:Et.baseState,baseQueue:Et.baseQueue,queue:Et.queue,next:null},Ft===null?gt.memoizedState=Ft=i:Ft=Ft.next=i}return Ft}function bi(i,c){return typeof c=="function"?c(i):c}function sm(i){var c=qn(),h=c.queue;if(h===null)throw Error(t(311));h.lastRenderedReducer=i;var y=Et,$=y.baseQueue,S=h.pending;if(S!==null){if($!==null){var E=$.next;$.next=S.next,S.next=E}y.baseQueue=$=S,h.pending=null}if($!==null){S=$.next,y=y.baseState;var B=E=null,G=null,se=S;do{var de=se.lane;if((io&de)===de)G!==null&&(G=G.next={lane:0,action:se.action,hasEagerState:se.hasEagerState,eagerState:se.eagerState,next:null}),y=se.hasEagerState?se.eagerState:i(y,se.action);else{var pe={lane:de,action:se.action,hasEagerState:se.hasEagerState,eagerState:se.eagerState,next:null};G===null?(B=G=pe,E=y):G=G.next=pe,gt.lanes|=de,lo|=de}se=se.next}while(se!==null&&se!==S);G===null?E=y:G.next=B,os(y,c.memoizedState)||(vn=!0),c.memoizedState=y,c.baseState=E,c.baseQueue=G,h.lastRenderedState=y}if(i=h.interleaved,i!==null){$=i;do S=$.lane,gt.lanes|=S,lo|=S,$=$.next;while($!==i)}else $===null&&(h.lanes=0);return[c.memoizedState,h.dispatch]}function rm(i){var c=qn(),h=c.queue;if(h===null)throw Error(t(311));h.lastRenderedReducer=i;var y=h.dispatch,$=h.pending,S=c.memoizedState;if($!==null){h.pending=null;var E=$=$.next;do S=i(S,E.action),E=E.next;while(E!==$);os(S,c.memoizedState)||(vn=!0),c.memoizedState=S,c.baseQueue===null&&(c.baseState=S),h.lastRenderedState=S}return[S,y]}function N1(){}function I1(i,c){var h=gt,y=qn(),$=c(),S=!os(y.memoizedState,$);if(S&&(y.memoizedState=$,vn=!0),y=y.queue,om(R1.bind(null,h,y,i),[i]),y.getSnapshot!==c||S||Ft!==null&&Ft.memoizedState.tag&1){if(h.flags|=2048,$i(9,E1.bind(null,h,y,$,c),void 0,null),Pt===null)throw Error(t(349));io&30||T1(h,c,$)}return $}function T1(i,c,h){i.flags|=16384,i={getSnapshot:c,value:h},c=gt.updateQueue,c===null?(c={lastEffect:null,stores:null},gt.updateQueue=c,c.stores=[i]):(h=c.stores,h===null?c.stores=[i]:h.push(i))}function E1(i,c,h,y){c.value=h,c.getSnapshot=y,_1(c)&&O1(i)}function R1(i,c,h){return h(function(){_1(c)&&O1(i)})}function _1(i){var c=i.getSnapshot;i=i.value;try{var h=c();return!os(i,h)}catch{return!0}}function O1(i){var c=Gs(i,1);c!==null&&cs(c,i,1,-1)}function D1(i){var c=Cs();return typeof i=="function"&&(i=i()),c.memoizedState=c.baseState=i,i={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:bi,lastRenderedState:i},c.queue=i,i=i.dispatch=NI.bind(null,gt,i),[c.memoizedState,i]}function $i(i,c,h,y){return i={tag:i,create:c,destroy:h,deps:y,next:null},c=gt.updateQueue,c===null?(c={lastEffect:null,stores:null},gt.updateQueue=c,c.lastEffect=i.next=i):(h=c.lastEffect,h===null?c.lastEffect=i.next=i:(y=h.next,h.next=i,i.next=y,c.lastEffect=i)),i}function A1(){return qn().memoizedState}function pc(i,c,h,y){var $=Cs();gt.flags|=i,$.memoizedState=$i(1|c,h,void 0,y===void 0?null:y)}function fc(i,c,h,y){var $=qn();y=y===void 0?null:y;var S=void 0;if(Et!==null){var E=Et.memoizedState;if(S=E.destroy,y!==null&&em(y,E.deps)){$.memoizedState=$i(c,h,S,y);return}}gt.flags|=i,$.memoizedState=$i(1|c,h,S,y)}function F1(i,c){return pc(8390656,8,i,c)}function om(i,c){return fc(2048,8,i,c)}function P1(i,c){return fc(4,2,i,c)}function L1(i,c){return fc(4,4,i,c)}function V1(i,c){if(typeof c=="function")return i=i(),c(i),function(){c(null)};if(c!=null)return i=i(),c.current=i,function(){c.current=null}}function B1(i,c,h){return h=h!=null?h.concat([i]):null,fc(4,4,V1.bind(null,c,i),h)}function am(){}function M1(i,c){var h=qn();c=c===void 0?null:c;var y=h.memoizedState;return y!==null&&c!==null&&em(c,y[1])?y[0]:(h.memoizedState=[i,c],i)}function z1(i,c){var h=qn();c=c===void 0?null:c;var y=h.memoizedState;return y!==null&&c!==null&&em(c,y[1])?y[0]:(i=i(),h.memoizedState=[i,c],i)}function W1(i,c,h){return io&21?(os(h,c)||(h=xx(),gt.lanes|=h,lo|=h,i.baseState=!0),c):(i.baseState&&(i.baseState=!1,vn=!0),i.memoizedState=h)}function CI(i,c){var h=Ye;Ye=h!==0&&4>h?h:4,i(!0);var y=Jh.transition;Jh.transition={};try{i(!1),c()}finally{Ye=h,Jh.transition=y}}function U1(){return qn().memoizedState}function kI(i,c,h){var y=Ir(i);if(h={lane:y,action:h,hasEagerState:!1,eagerState:null,next:null},G1(i))H1(c,h);else if(h=b1(i,c,h,y),h!==null){var $=pn();cs(h,i,y,$),j1(h,c,y)}}function NI(i,c,h){var y=Ir(i),$={lane:y,action:h,hasEagerState:!1,eagerState:null,next:null};if(G1(i))H1(c,$);else{var S=i.alternate;if(i.lanes===0&&(S===null||S.lanes===0)&&(S=c.lastRenderedReducer,S!==null))try{var E=c.lastRenderedState,B=S(E,h);if($.hasEagerState=!0,$.eagerState=B,os(B,E)){var G=c.interleaved;G===null?($.next=$,qh(c)):($.next=G.next,G.next=$),c.interleaved=$;return}}catch{}finally{}h=b1(i,c,$,y),h!==null&&($=pn(),cs(h,i,y,$),j1(h,c,y))}}function G1(i){var c=i.alternate;return i===gt||c!==null&&c===gt}function H1(i,c){vi=dc=!0;var h=i.pending;h===null?c.next=c:(c.next=h.next,h.next=c),i.pending=c}function j1(i,c,h){if(h&4194240){var y=c.lanes;y&=i.pendingLanes,h|=y,c.lanes=h,lh(i,h)}}var hc={readContext:jn,useCallback:Jt,useContext:Jt,useEffect:Jt,useImperativeHandle:Jt,useInsertionEffect:Jt,useLayoutEffect:Jt,useMemo:Jt,useReducer:Jt,useRef:Jt,useState:Jt,useDebugValue:Jt,useDeferredValue:Jt,useTransition:Jt,useMutableSource:Jt,useSyncExternalStore:Jt,useId:Jt,unstable_isNewReconciler:!1},II={readContext:jn,useCallback:function(i,c){return Cs().memoizedState=[i,c===void 0?null:c],i},useContext:jn,useEffect:F1,useImperativeHandle:function(i,c,h){return h=h!=null?h.concat([i]):null,pc(4194308,4,V1.bind(null,c,i),h)},useLayoutEffect:function(i,c){return pc(4194308,4,i,c)},useInsertionEffect:function(i,c){return pc(4,2,i,c)},useMemo:function(i,c){var h=Cs();return c=c===void 0?null:c,i=i(),h.memoizedState=[i,c],i},useReducer:function(i,c,h){var y=Cs();return c=h!==void 0?h(c):c,y.memoizedState=y.baseState=c,i={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:i,lastRenderedState:c},y.queue=i,i=i.dispatch=kI.bind(null,gt,i),[y.memoizedState,i]},useRef:function(i){var c=Cs();return i={current:i},c.memoizedState=i},useState:D1,useDebugValue:am,useDeferredValue:function(i){return Cs().memoizedState=i},useTransition:function(){var i=D1(!1),c=i[0];return i=CI.bind(null,i[1]),Cs().memoizedState=i,[c,i]},useMutableSource:function(){},useSyncExternalStore:function(i,c,h){var y=gt,$=Cs();if(pt){if(h===void 0)throw Error(t(407));h=h()}else{if(h=c(),Pt===null)throw Error(t(349));io&30||T1(y,c,h)}$.memoizedState=h;var S={value:h,getSnapshot:c};return $.queue=S,F1(R1.bind(null,y,S,i),[i]),y.flags|=2048,$i(9,E1.bind(null,y,S,h,c),void 0,null),h},useId:function(){var i=Cs(),c=Pt.identifierPrefix;if(pt){var h=Us,y=Ws;h=(y&~(1<<32-rs(y)-1)).toString(32)+h,c=":"+c+"R"+h,h=wi++,0<h&&(c+="H"+h.toString(32)),c+=":"}else h=SI++,c=":"+c+"r"+h.toString(32)+":";return i.memoizedState=c},unstable_isNewReconciler:!1},TI={readContext:jn,useCallback:M1,useContext:jn,useEffect:om,useImperativeHandle:B1,useInsertionEffect:P1,useLayoutEffect:L1,useMemo:z1,useReducer:sm,useRef:A1,useState:function(){return sm(bi)},useDebugValue:am,useDeferredValue:function(i){var c=qn();return W1(c,Et.memoizedState,i)},useTransition:function(){var i=sm(bi)[0],c=qn().memoizedState;return[i,c]},useMutableSource:N1,useSyncExternalStore:I1,useId:U1,unstable_isNewReconciler:!1},EI={readContext:jn,useCallback:M1,useContext:jn,useEffect:om,useImperativeHandle:B1,useInsertionEffect:P1,useLayoutEffect:L1,useMemo:z1,useReducer:rm,useRef:A1,useState:function(){return rm(bi)},useDebugValue:am,useDeferredValue:function(i){var c=qn();return Et===null?c.memoizedState=i:W1(c,Et.memoizedState,i)},useTransition:function(){var i=rm(bi)[0],c=qn().memoizedState;return[i,c]},useMutableSource:N1,useSyncExternalStore:I1,useId:U1,unstable_isNewReconciler:!1};function is(i,c){if(i&&i.defaultProps){c=X({},c),i=i.defaultProps;for(var h in i)c[h]===void 0&&(c[h]=i[h]);return c}return c}function im(i,c,h,y){c=i.memoizedState,h=h(y,c),h=h==null?c:X({},c,h),i.memoizedState=h,i.lanes===0&&(i.updateQueue.baseState=h)}var mc={isMounted:function(i){return(i=i._reactInternals)?eo(i)===i:!1},enqueueSetState:function(i,c,h){i=i._reactInternals;var y=pn(),$=Ir(i),S=Hs(y,$);S.payload=c,h!=null&&(S.callback=h),c=Sr(i,S,$),c!==null&&(cs(c,i,$,y),ic(c,i,$))},enqueueReplaceState:function(i,c,h){i=i._reactInternals;var y=pn(),$=Ir(i),S=Hs(y,$);S.tag=1,S.payload=c,h!=null&&(S.callback=h),c=Sr(i,S,$),c!==null&&(cs(c,i,$,y),ic(c,i,$))},enqueueForceUpdate:function(i,c){i=i._reactInternals;var h=pn(),y=Ir(i),$=Hs(h,y);$.tag=2,c!=null&&($.callback=c),c=Sr(i,$,y),c!==null&&(cs(c,i,y,h),ic(c,i,y))}};function q1(i,c,h,y,$,S,E){return i=i.stateNode,typeof i.shouldComponentUpdate=="function"?i.shouldComponentUpdate(y,S,E):c.prototype&&c.prototype.isPureReactComponent?!li(h,y)||!li($,S):!0}function K1(i,c,h){var y=!1,$=wr,S=c.contextType;return typeof S=="object"&&S!==null?S=jn(S):($=xn(c)?no:Zt.current,y=c.contextTypes,S=(y=y!=null)?ta(i,$):wr),c=new c(h,S),i.memoizedState=c.state!==null&&c.state!==void 0?c.state:null,c.updater=mc,i.stateNode=c,c._reactInternals=i,y&&(i=i.stateNode,i.__reactInternalMemoizedUnmaskedChildContext=$,i.__reactInternalMemoizedMaskedChildContext=S),c}function X1(i,c,h,y){i=c.state,typeof c.componentWillReceiveProps=="function"&&c.componentWillReceiveProps(h,y),typeof c.UNSAFE_componentWillReceiveProps=="function"&&c.UNSAFE_componentWillReceiveProps(h,y),c.state!==i&&mc.enqueueReplaceState(c,c.state,null)}function lm(i,c,h,y){var $=i.stateNode;$.props=h,$.state=i.memoizedState,$.refs={},Kh(i);var S=c.contextType;typeof S=="object"&&S!==null?$.context=jn(S):(S=xn(c)?no:Zt.current,$.context=ta(i,S)),$.state=i.memoizedState,S=c.getDerivedStateFromProps,typeof S=="function"&&(im(i,c,S,h),$.state=i.memoizedState),typeof c.getDerivedStateFromProps=="function"||typeof $.getSnapshotBeforeUpdate=="function"||typeof $.UNSAFE_componentWillMount!="function"&&typeof $.componentWillMount!="function"||(c=$.state,typeof $.componentWillMount=="function"&&$.componentWillMount(),typeof $.UNSAFE_componentWillMount=="function"&&$.UNSAFE_componentWillMount(),c!==$.state&&mc.enqueueReplaceState($,$.state,null),lc(i,h,$,y),$.state=i.memoizedState),typeof $.componentDidMount=="function"&&(i.flags|=4194308)}function ua(i,c){try{var h="",y=c;do h+=ie(y),y=y.return;while(y);var $=h}catch(S){$=`
Error generating stack: `+S.message+`
`+S.stack}return{value:i,source:c,stack:$,digest:null}}function um(i,c,h){return{value:i,source:null,stack:h??null,digest:c??null}}function cm(i,c){try{console.error(c.value)}catch(h){setTimeout(function(){throw h})}}var RI=typeof WeakMap=="function"?WeakMap:Map;function Y1(i,c,h){h=Hs(-1,h),h.tag=3,h.payload={element:null};var y=c.value;return h.callback=function(){$c||($c=!0,km=y),cm(i,c)},h}function Q1(i,c,h){h=Hs(-1,h),h.tag=3;var y=i.type.getDerivedStateFromError;if(typeof y=="function"){var $=c.value;h.payload=function(){return y($)},h.callback=function(){cm(i,c)}}var S=i.stateNode;return S!==null&&typeof S.componentDidCatch=="function"&&(h.callback=function(){cm(i,c),typeof y!="function"&&(kr===null?kr=new Set([this]):kr.add(this));var E=c.stack;this.componentDidCatch(c.value,{componentStack:E!==null?E:""})}),h}function Z1(i,c,h){var y=i.pingCache;if(y===null){y=i.pingCache=new RI;var $=new Set;y.set(c,$)}else $=y.get(c),$===void 0&&($=new Set,y.set(c,$));$.has(h)||($.add(h),i=GI.bind(null,i,c,h),c.then(i,i))}function J1(i){do{var c;if((c=i.tag===13)&&(c=i.memoizedState,c=c!==null?c.dehydrated!==null:!0),c)return i;i=i.return}while(i!==null);return null}function ev(i,c,h,y,$){return i.mode&1?(i.flags|=65536,i.lanes=$,i):(i===c?i.flags|=65536:(i.flags|=128,h.flags|=131072,h.flags&=-52805,h.tag===1&&(h.alternate===null?h.tag=17:(c=Hs(-1,1),c.tag=2,Sr(h,c,1))),h.lanes|=1),i)}var _I=N.ReactCurrentOwner,vn=!1;function dn(i,c,h,y){c.child=i===null?w1(c,null,h,y):oa(c,i.child,h,y)}function tv(i,c,h,y,$){h=h.render;var S=c.ref;return ia(c,$),y=tm(i,c,h,y,S,$),h=nm(),i!==null&&!vn?(c.updateQueue=i.updateQueue,c.flags&=-2053,i.lanes&=~$,js(i,c,$)):(pt&&h&&Vh(c),c.flags|=1,dn(i,c,y,$),c.child)}function nv(i,c,h,y,$){if(i===null){var S=h.type;return typeof S=="function"&&!Om(S)&&S.defaultProps===void 0&&h.compare===null&&h.defaultProps===void 0?(c.tag=15,c.type=S,sv(i,c,S,y,$)):(i=Tc(h.type,null,y,c,c.mode,$),i.ref=c.ref,i.return=c,c.child=i)}if(S=i.child,!(i.lanes&$)){var E=S.memoizedProps;if(h=h.compare,h=h!==null?h:li,h(E,y)&&i.ref===c.ref)return js(i,c,$)}return c.flags|=1,i=Er(S,y),i.ref=c.ref,i.return=c,c.child=i}function sv(i,c,h,y,$){if(i!==null){var S=i.memoizedProps;if(li(S,y)&&i.ref===c.ref)if(vn=!1,c.pendingProps=y=S,(i.lanes&$)!==0)i.flags&131072&&(vn=!0);else return c.lanes=i.lanes,js(i,c,$)}return dm(i,c,h,y,$)}function rv(i,c,h){var y=c.pendingProps,$=y.children,S=i!==null?i.memoizedState:null;if(y.mode==="hidden")if(!(c.mode&1))c.memoizedState={baseLanes:0,cachePool:null,transitions:null},lt(da,Ln),Ln|=h;else{if(!(h&1073741824))return i=S!==null?S.baseLanes|h:h,c.lanes=c.childLanes=1073741824,c.memoizedState={baseLanes:i,cachePool:null,transitions:null},c.updateQueue=null,lt(da,Ln),Ln|=i,null;c.memoizedState={baseLanes:0,cachePool:null,transitions:null},y=S!==null?S.baseLanes:h,lt(da,Ln),Ln|=y}else S!==null?(y=S.baseLanes|h,c.memoizedState=null):y=h,lt(da,Ln),Ln|=y;return dn(i,c,$,h),c.child}function ov(i,c){var h=c.ref;(i===null&&h!==null||i!==null&&i.ref!==h)&&(c.flags|=512,c.flags|=2097152)}function dm(i,c,h,y,$){var S=xn(h)?no:Zt.current;return S=ta(c,S),ia(c,$),h=tm(i,c,h,y,S,$),y=nm(),i!==null&&!vn?(c.updateQueue=i.updateQueue,c.flags&=-2053,i.lanes&=~$,js(i,c,$)):(pt&&y&&Vh(c),c.flags|=1,dn(i,c,h,$),c.child)}function av(i,c,h,y,$){if(xn(h)){var S=!0;Ju(c)}else S=!1;if(ia(c,$),c.stateNode===null)yc(i,c),K1(c,h,y),lm(c,h,y,$),y=!0;else if(i===null){var E=c.stateNode,B=c.memoizedProps;E.props=B;var G=E.context,se=h.contextType;typeof se=="object"&&se!==null?se=jn(se):(se=xn(h)?no:Zt.current,se=ta(c,se));var de=h.getDerivedStateFromProps,pe=typeof de=="function"||typeof E.getSnapshotBeforeUpdate=="function";pe||typeof E.UNSAFE_componentWillReceiveProps!="function"&&typeof E.componentWillReceiveProps!="function"||(B!==y||G!==se)&&X1(c,E,y,se),$r=!1;var ce=c.memoizedState;E.state=ce,lc(c,y,E,$),G=c.memoizedState,B!==y||ce!==G||yn.current||$r?(typeof de=="function"&&(im(c,h,de,y),G=c.memoizedState),(B=$r||q1(c,h,B,y,ce,G,se))?(pe||typeof E.UNSAFE_componentWillMount!="function"&&typeof E.componentWillMount!="function"||(typeof E.componentWillMount=="function"&&E.componentWillMount(),typeof E.UNSAFE_componentWillMount=="function"&&E.UNSAFE_componentWillMount()),typeof E.componentDidMount=="function"&&(c.flags|=4194308)):(typeof E.componentDidMount=="function"&&(c.flags|=4194308),c.memoizedProps=y,c.memoizedState=G),E.props=y,E.state=G,E.context=se,y=B):(typeof E.componentDidMount=="function"&&(c.flags|=4194308),y=!1)}else{E=c.stateNode,$1(i,c),B=c.memoizedProps,se=c.type===c.elementType?B:is(c.type,B),E.props=se,pe=c.pendingProps,ce=E.context,G=h.contextType,typeof G=="object"&&G!==null?G=jn(G):(G=xn(h)?no:Zt.current,G=ta(c,G));var we=h.getDerivedStateFromProps;(de=typeof we=="function"||typeof E.getSnapshotBeforeUpdate=="function")||typeof E.UNSAFE_componentWillReceiveProps!="function"&&typeof E.componentWillReceiveProps!="function"||(B!==pe||ce!==G)&&X1(c,E,y,G),$r=!1,ce=c.memoizedState,E.state=ce,lc(c,y,E,$);var Se=c.memoizedState;B!==pe||ce!==Se||yn.current||$r?(typeof we=="function"&&(im(c,h,we,y),Se=c.memoizedState),(se=$r||q1(c,h,se,y,ce,Se,G)||!1)?(de||typeof E.UNSAFE_componentWillUpdate!="function"&&typeof E.componentWillUpdate!="function"||(typeof E.componentWillUpdate=="function"&&E.componentWillUpdate(y,Se,G),typeof E.UNSAFE_componentWillUpdate=="function"&&E.UNSAFE_componentWillUpdate(y,Se,G)),typeof E.componentDidUpdate=="function"&&(c.flags|=4),typeof E.getSnapshotBeforeUpdate=="function"&&(c.flags|=1024)):(typeof E.componentDidUpdate!="function"||B===i.memoizedProps&&ce===i.memoizedState||(c.flags|=4),typeof E.getSnapshotBeforeUpdate!="function"||B===i.memoizedProps&&ce===i.memoizedState||(c.flags|=1024),c.memoizedProps=y,c.memoizedState=Se),E.props=y,E.state=Se,E.context=G,y=se):(typeof E.componentDidUpdate!="function"||B===i.memoizedProps&&ce===i.memoizedState||(c.flags|=4),typeof E.getSnapshotBeforeUpdate!="function"||B===i.memoizedProps&&ce===i.memoizedState||(c.flags|=1024),y=!1)}return pm(i,c,h,y,S,$)}function pm(i,c,h,y,$,S){ov(i,c);var E=(c.flags&128)!==0;if(!y&&!E)return $&&d1(c,h,!1),js(i,c,S);y=c.stateNode,_I.current=c;var B=E&&typeof h.getDerivedStateFromError!="function"?null:y.render();return c.flags|=1,i!==null&&E?(c.child=oa(c,i.child,null,S),c.child=oa(c,null,B,S)):dn(i,c,B,S),c.memoizedState=y.state,$&&d1(c,h,!0),c.child}function iv(i){var c=i.stateNode;c.pendingContext?u1(i,c.pendingContext,c.pendingContext!==c.context):c.context&&u1(i,c.context,!1),Xh(i,c.containerInfo)}function lv(i,c,h,y,$){return ra(),Wh($),c.flags|=256,dn(i,c,h,y),c.child}var fm={dehydrated:null,treeContext:null,retryLane:0};function hm(i){return{baseLanes:i,cachePool:null,transitions:null}}function uv(i,c,h){var y=c.pendingProps,$=mt.current,S=!1,E=(c.flags&128)!==0,B;if((B=E)||(B=i!==null&&i.memoizedState===null?!1:($&2)!==0),B?(S=!0,c.flags&=-129):(i===null||i.memoizedState!==null)&&($|=1),lt(mt,$&1),i===null)return zh(c),i=c.memoizedState,i!==null&&(i=i.dehydrated,i!==null)?(c.mode&1?i.data==="$!"?c.lanes=8:c.lanes=1073741824:c.lanes=1,null):(E=y.children,i=y.fallback,S?(y=c.mode,S=c.child,E={mode:"hidden",children:E},!(y&1)&&S!==null?(S.childLanes=0,S.pendingProps=E):S=Ec(E,y,0,null),i=fo(i,y,h,null),S.return=c,i.return=c,S.sibling=i,c.child=S,c.child.memoizedState=hm(h),c.memoizedState=fm,i):mm(c,E));if($=i.memoizedState,$!==null&&(B=$.dehydrated,B!==null))return OI(i,c,E,y,B,$,h);if(S){S=y.fallback,E=c.mode,$=i.child,B=$.sibling;var G={mode:"hidden",children:y.children};return!(E&1)&&c.child!==$?(y=c.child,y.childLanes=0,y.pendingProps=G,c.deletions=null):(y=Er($,G),y.subtreeFlags=$.subtreeFlags&14680064),B!==null?S=Er(B,S):(S=fo(S,E,h,null),S.flags|=2),S.return=c,y.return=c,y.sibling=S,c.child=y,y=S,S=c.child,E=i.child.memoizedState,E=E===null?hm(h):{baseLanes:E.baseLanes|h,cachePool:null,transitions:E.transitions},S.memoizedState=E,S.childLanes=i.childLanes&~h,c.memoizedState=fm,y}return S=i.child,i=S.sibling,y=Er(S,{mode:"visible",children:y.children}),!(c.mode&1)&&(y.lanes=h),y.return=c,y.sibling=null,i!==null&&(h=c.deletions,h===null?(c.deletions=[i],c.flags|=16):h.push(i)),c.child=y,c.memoizedState=null,y}function mm(i,c){return c=Ec({mode:"visible",children:c},i.mode,0,null),c.return=i,i.child=c}function gc(i,c,h,y){return y!==null&&Wh(y),oa(c,i.child,null,h),i=mm(c,c.pendingProps.children),i.flags|=2,c.memoizedState=null,i}function OI(i,c,h,y,$,S,E){if(h)return c.flags&256?(c.flags&=-257,y=um(Error(t(422))),gc(i,c,E,y)):c.memoizedState!==null?(c.child=i.child,c.flags|=128,null):(S=y.fallback,$=c.mode,y=Ec({mode:"visible",children:y.children},$,0,null),S=fo(S,$,E,null),S.flags|=2,y.return=c,S.return=c,y.sibling=S,c.child=y,c.mode&1&&oa(c,i.child,null,E),c.child.memoizedState=hm(E),c.memoizedState=fm,S);if(!(c.mode&1))return gc(i,c,E,null);if($.data==="$!"){if(y=$.nextSibling&&$.nextSibling.dataset,y)var B=y.dgst;return y=B,S=Error(t(419)),y=um(S,y,void 0),gc(i,c,E,y)}if(B=(E&i.childLanes)!==0,vn||B){if(y=Pt,y!==null){switch(E&-E){case 4:$=2;break;case 16:$=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:$=32;break;case 536870912:$=268435456;break;default:$=0}$=$&(y.suspendedLanes|E)?0:$,$!==0&&$!==S.retryLane&&(S.retryLane=$,Gs(i,$),cs(y,i,$,-1))}return _m(),y=um(Error(t(421))),gc(i,c,E,y)}return $.data==="$?"?(c.flags|=128,c.child=i.child,c=HI.bind(null,i),$._reactRetry=c,null):(i=S.treeContext,Pn=xr($.nextSibling),Fn=c,pt=!0,as=null,i!==null&&(Gn[Hn++]=Ws,Gn[Hn++]=Us,Gn[Hn++]=so,Ws=i.id,Us=i.overflow,so=c),c=mm(c,y.children),c.flags|=4096,c)}function cv(i,c,h){i.lanes|=c;var y=i.alternate;y!==null&&(y.lanes|=c),jh(i.return,c,h)}function gm(i,c,h,y,$){var S=i.memoizedState;S===null?i.memoizedState={isBackwards:c,rendering:null,renderingStartTime:0,last:y,tail:h,tailMode:$}:(S.isBackwards=c,S.rendering=null,S.renderingStartTime=0,S.last=y,S.tail=h,S.tailMode=$)}function dv(i,c,h){var y=c.pendingProps,$=y.revealOrder,S=y.tail;if(dn(i,c,y.children,h),y=mt.current,y&2)y=y&1|2,c.flags|=128;else{if(i!==null&&i.flags&128)e:for(i=c.child;i!==null;){if(i.tag===13)i.memoizedState!==null&&cv(i,h,c);else if(i.tag===19)cv(i,h,c);else if(i.child!==null){i.child.return=i,i=i.child;continue}if(i===c)break e;for(;i.sibling===null;){if(i.return===null||i.return===c)break e;i=i.return}i.sibling.return=i.return,i=i.sibling}y&=1}if(lt(mt,y),!(c.mode&1))c.memoizedState=null;else switch($){case"forwards":for(h=c.child,$=null;h!==null;)i=h.alternate,i!==null&&uc(i)===null&&($=h),h=h.sibling;h=$,h===null?($=c.child,c.child=null):($=h.sibling,h.sibling=null),gm(c,!1,$,h,S);break;case"backwards":for(h=null,$=c.child,c.child=null;$!==null;){if(i=$.alternate,i!==null&&uc(i)===null){c.child=$;break}i=$.sibling,$.sibling=h,h=$,$=i}gm(c,!0,h,null,S);break;case"together":gm(c,!1,null,null,void 0);break;default:c.memoizedState=null}return c.child}function yc(i,c){!(c.mode&1)&&i!==null&&(i.alternate=null,c.alternate=null,c.flags|=2)}function js(i,c,h){if(i!==null&&(c.dependencies=i.dependencies),lo|=c.lanes,!(h&c.childLanes))return null;if(i!==null&&c.child!==i.child)throw Error(t(153));if(c.child!==null){for(i=c.child,h=Er(i,i.pendingProps),c.child=h,h.return=c;i.sibling!==null;)i=i.sibling,h=h.sibling=Er(i,i.pendingProps),h.return=c;h.sibling=null}return c.child}function DI(i,c,h){switch(c.tag){case 3:iv(c),ra();break;case 5:k1(c);break;case 1:xn(c.type)&&Ju(c);break;case 4:Xh(c,c.stateNode.containerInfo);break;case 10:var y=c.type._context,$=c.memoizedProps.value;lt(oc,y._currentValue),y._currentValue=$;break;case 13:if(y=c.memoizedState,y!==null)return y.dehydrated!==null?(lt(mt,mt.current&1),c.flags|=128,null):h&c.child.childLanes?uv(i,c,h):(lt(mt,mt.current&1),i=js(i,c,h),i!==null?i.sibling:null);lt(mt,mt.current&1);break;case 19:if(y=(h&c.childLanes)!==0,i.flags&128){if(y)return dv(i,c,h);c.flags|=128}if($=c.memoizedState,$!==null&&($.rendering=null,$.tail=null,$.lastEffect=null),lt(mt,mt.current),y)break;return null;case 22:case 23:return c.lanes=0,rv(i,c,h)}return js(i,c,h)}var pv,ym,fv,hv;pv=function(i,c){for(var h=c.child;h!==null;){if(h.tag===5||h.tag===6)i.appendChild(h.stateNode);else if(h.tag!==4&&h.child!==null){h.child.return=h,h=h.child;continue}if(h===c)break;for(;h.sibling===null;){if(h.return===null||h.return===c)return;h=h.return}h.sibling.return=h.return,h=h.sibling}},ym=function(){},fv=function(i,c,h,y){var $=i.memoizedProps;if($!==y){i=c.stateNode,ao(Ss.current);var S=null;switch(h){case"input":$=nt(i,$),y=nt(i,y),S=[];break;case"select":$=X({},$,{value:void 0}),y=X({},y,{value:void 0}),S=[];break;case"textarea":$=jt(i,$),y=jt(i,y),S=[];break;default:typeof $.onClick!="function"&&typeof y.onClick=="function"&&(i.onclick=Yu)}Qf(h,y);var E;h=null;for(se in $)if(!y.hasOwnProperty(se)&&$.hasOwnProperty(se)&&$[se]!=null)if(se==="style"){var B=$[se];for(E in B)B.hasOwnProperty(E)&&(h||(h={}),h[E]="")}else se!=="dangerouslySetInnerHTML"&&se!=="children"&&se!=="suppressContentEditableWarning"&&se!=="suppressHydrationWarning"&&se!=="autoFocus"&&(r.hasOwnProperty(se)?S||(S=[]):(S=S||[]).push(se,null));for(se in y){var G=y[se];if(B=$!=null?$[se]:void 0,y.hasOwnProperty(se)&&G!==B&&(G!=null||B!=null))if(se==="style")if(B){for(E in B)!B.hasOwnProperty(E)||G&&G.hasOwnProperty(E)||(h||(h={}),h[E]="");for(E in G)G.hasOwnProperty(E)&&B[E]!==G[E]&&(h||(h={}),h[E]=G[E])}else h||(S||(S=[]),S.push(se,h)),h=G;else se==="dangerouslySetInnerHTML"?(G=G?G.__html:void 0,B=B?B.__html:void 0,G!=null&&B!==G&&(S=S||[]).push(se,G)):se==="children"?typeof G!="string"&&typeof G!="number"||(S=S||[]).push(se,""+G):se!=="suppressContentEditableWarning"&&se!=="suppressHydrationWarning"&&(r.hasOwnProperty(se)?(G!=null&&se==="onScroll"&&ut("scroll",i),S||B===G||(S=[])):(S=S||[]).push(se,G))}h&&(S=S||[]).push("style",h);var se=S;(c.updateQueue=se)&&(c.flags|=4)}},hv=function(i,c,h,y){h!==y&&(c.flags|=4)};function Si(i,c){if(!pt)switch(i.tailMode){case"hidden":c=i.tail;for(var h=null;c!==null;)c.alternate!==null&&(h=c),c=c.sibling;h===null?i.tail=null:h.sibling=null;break;case"collapsed":h=i.tail;for(var y=null;h!==null;)h.alternate!==null&&(y=h),h=h.sibling;y===null?c||i.tail===null?i.tail=null:i.tail.sibling=null:y.sibling=null}}function en(i){var c=i.alternate!==null&&i.alternate.child===i.child,h=0,y=0;if(c)for(var $=i.child;$!==null;)h|=$.lanes|$.childLanes,y|=$.subtreeFlags&14680064,y|=$.flags&14680064,$.return=i,$=$.sibling;else for($=i.child;$!==null;)h|=$.lanes|$.childLanes,y|=$.subtreeFlags,y|=$.flags,$.return=i,$=$.sibling;return i.subtreeFlags|=y,i.childLanes=h,c}function AI(i,c,h){var y=c.pendingProps;switch(Bh(c),c.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return en(c),null;case 1:return xn(c.type)&&Zu(),en(c),null;case 3:return y=c.stateNode,la(),ct(yn),ct(Zt),Zh(),y.pendingContext&&(y.context=y.pendingContext,y.pendingContext=null),(i===null||i.child===null)&&(sc(c)?c.flags|=4:i===null||i.memoizedState.isDehydrated&&!(c.flags&256)||(c.flags|=1024,as!==null&&(Tm(as),as=null))),ym(i,c),en(c),null;case 5:Yh(c);var $=ao(xi.current);if(h=c.type,i!==null&&c.stateNode!=null)fv(i,c,h,y,$),i.ref!==c.ref&&(c.flags|=512,c.flags|=2097152);else{if(!y){if(c.stateNode===null)throw Error(t(166));return en(c),null}if(i=ao(Ss.current),sc(c)){y=c.stateNode,h=c.type;var S=c.memoizedProps;switch(y[$s]=c,y[fi]=S,i=(c.mode&1)!==0,h){case"dialog":ut("cancel",y),ut("close",y);break;case"iframe":case"object":case"embed":ut("load",y);break;case"video":case"audio":for($=0;$<ci.length;$++)ut(ci[$],y);break;case"source":ut("error",y);break;case"img":case"image":case"link":ut("error",y),ut("load",y);break;case"details":ut("toggle",y);break;case"input":Ke(y,S),ut("invalid",y);break;case"select":y._wrapperState={wasMultiple:!!S.multiple},ut("invalid",y);break;case"textarea":ws(y,S),ut("invalid",y)}Qf(h,S),$=null;for(var E in S)if(S.hasOwnProperty(E)){var B=S[E];E==="children"?typeof B=="string"?y.textContent!==B&&(S.suppressHydrationWarning!==!0&&Xu(y.textContent,B,i),$=["children",B]):typeof B=="number"&&y.textContent!==""+B&&(S.suppressHydrationWarning!==!0&&Xu(y.textContent,B,i),$=["children",""+B]):r.hasOwnProperty(E)&&B!=null&&E==="onScroll"&&ut("scroll",y)}switch(h){case"input":De(y),et(y,S,!0);break;case"textarea":De(y),Wn(y);break;case"select":case"option":break;default:typeof S.onClick=="function"&&(y.onclick=Yu)}y=$,c.updateQueue=y,y!==null&&(c.flags|=4)}else{E=$.nodeType===9?$:$.ownerDocument,i==="http://www.w3.org/1999/xhtml"&&(i=ss(h)),i==="http://www.w3.org/1999/xhtml"?h==="script"?(i=E.createElement("div"),i.innerHTML="<script><\/script>",i=i.removeChild(i.firstChild)):typeof y.is=="string"?i=E.createElement(h,{is:y.is}):(i=E.createElement(h),h==="select"&&(E=i,y.multiple?E.multiple=!0:y.size&&(E.size=y.size))):i=E.createElementNS(i,h),i[$s]=c,i[fi]=y,pv(i,c,!1,!1),c.stateNode=i;e:{switch(E=Zf(h,y),h){case"dialog":ut("cancel",i),ut("close",i),$=y;break;case"iframe":case"object":case"embed":ut("load",i),$=y;break;case"video":case"audio":for($=0;$<ci.length;$++)ut(ci[$],i);$=y;break;case"source":ut("error",i),$=y;break;case"img":case"image":case"link":ut("error",i),ut("load",i),$=y;break;case"details":ut("toggle",i),$=y;break;case"input":Ke(i,y),$=nt(i,y),ut("invalid",i);break;case"option":$=y;break;case"select":i._wrapperState={wasMultiple:!!y.multiple},$=X({},y,{value:void 0}),ut("invalid",i);break;case"textarea":ws(i,y),$=jt(i,y),ut("invalid",i);break;default:$=y}Qf(h,$),B=$;for(S in B)if(B.hasOwnProperty(S)){var G=B[S];S==="style"?Tu(i,G):S==="dangerouslySetInnerHTML"?(G=G?G.__html:void 0,G!=null&&dr(i,G)):S==="children"?typeof G=="string"?(h!=="textarea"||G!=="")&&Vs(i,G):typeof G=="number"&&Vs(i,""+G):S!=="suppressContentEditableWarning"&&S!=="suppressHydrationWarning"&&S!=="autoFocus"&&(r.hasOwnProperty(S)?G!=null&&S==="onScroll"&&ut("scroll",i):G!=null&&I(i,S,G,E))}switch(h){case"input":De(i),et(i,y,!1);break;case"textarea":De(i),Wn(i);break;case"option":y.value!=null&&i.setAttribute("value",""+me(y.value));break;case"select":i.multiple=!!y.multiple,S=y.value,S!=null?cn(i,!!y.multiple,S,!1):y.defaultValue!=null&&cn(i,!!y.multiple,y.defaultValue,!0);break;default:typeof $.onClick=="function"&&(i.onclick=Yu)}switch(h){case"button":case"input":case"select":case"textarea":y=!!y.autoFocus;break e;case"img":y=!0;break e;default:y=!1}}y&&(c.flags|=4)}c.ref!==null&&(c.flags|=512,c.flags|=2097152)}return en(c),null;case 6:if(i&&c.stateNode!=null)hv(i,c,i.memoizedProps,y);else{if(typeof y!="string"&&c.stateNode===null)throw Error(t(166));if(h=ao(xi.current),ao(Ss.current),sc(c)){if(y=c.stateNode,h=c.memoizedProps,y[$s]=c,(S=y.nodeValue!==h)&&(i=Fn,i!==null))switch(i.tag){case 3:Xu(y.nodeValue,h,(i.mode&1)!==0);break;case 5:i.memoizedProps.suppressHydrationWarning!==!0&&Xu(y.nodeValue,h,(i.mode&1)!==0)}S&&(c.flags|=4)}else y=(h.nodeType===9?h:h.ownerDocument).createTextNode(y),y[$s]=c,c.stateNode=y}return en(c),null;case 13:if(ct(mt),y=c.memoizedState,i===null||i.memoizedState!==null&&i.memoizedState.dehydrated!==null){if(pt&&Pn!==null&&c.mode&1&&!(c.flags&128))y1(),ra(),c.flags|=98560,S=!1;else if(S=sc(c),y!==null&&y.dehydrated!==null){if(i===null){if(!S)throw Error(t(318));if(S=c.memoizedState,S=S!==null?S.dehydrated:null,!S)throw Error(t(317));S[$s]=c}else ra(),!(c.flags&128)&&(c.memoizedState=null),c.flags|=4;en(c),S=!1}else as!==null&&(Tm(as),as=null),S=!0;if(!S)return c.flags&65536?c:null}return c.flags&128?(c.lanes=h,c):(y=y!==null,y!==(i!==null&&i.memoizedState!==null)&&y&&(c.child.flags|=8192,c.mode&1&&(i===null||mt.current&1?Rt===0&&(Rt=3):_m())),c.updateQueue!==null&&(c.flags|=4),en(c),null);case 4:return la(),ym(i,c),i===null&&di(c.stateNode.containerInfo),en(c),null;case 10:return Hh(c.type._context),en(c),null;case 17:return xn(c.type)&&Zu(),en(c),null;case 19:if(ct(mt),S=c.memoizedState,S===null)return en(c),null;if(y=(c.flags&128)!==0,E=S.rendering,E===null)if(y)Si(S,!1);else{if(Rt!==0||i!==null&&i.flags&128)for(i=c.child;i!==null;){if(E=uc(i),E!==null){for(c.flags|=128,Si(S,!1),y=E.updateQueue,y!==null&&(c.updateQueue=y,c.flags|=4),c.subtreeFlags=0,y=h,h=c.child;h!==null;)S=h,i=y,S.flags&=14680066,E=S.alternate,E===null?(S.childLanes=0,S.lanes=i,S.child=null,S.subtreeFlags=0,S.memoizedProps=null,S.memoizedState=null,S.updateQueue=null,S.dependencies=null,S.stateNode=null):(S.childLanes=E.childLanes,S.lanes=E.lanes,S.child=E.child,S.subtreeFlags=0,S.deletions=null,S.memoizedProps=E.memoizedProps,S.memoizedState=E.memoizedState,S.updateQueue=E.updateQueue,S.type=E.type,i=E.dependencies,S.dependencies=i===null?null:{lanes:i.lanes,firstContext:i.firstContext}),h=h.sibling;return lt(mt,mt.current&1|2),c.child}i=i.sibling}S.tail!==null&&St()>pa&&(c.flags|=128,y=!0,Si(S,!1),c.lanes=4194304)}else{if(!y)if(i=uc(E),i!==null){if(c.flags|=128,y=!0,h=i.updateQueue,h!==null&&(c.updateQueue=h,c.flags|=4),Si(S,!0),S.tail===null&&S.tailMode==="hidden"&&!E.alternate&&!pt)return en(c),null}else 2*St()-S.renderingStartTime>pa&&h!==1073741824&&(c.flags|=128,y=!0,Si(S,!1),c.lanes=4194304);S.isBackwards?(E.sibling=c.child,c.child=E):(h=S.last,h!==null?h.sibling=E:c.child=E,S.last=E)}return S.tail!==null?(c=S.tail,S.rendering=c,S.tail=c.sibling,S.renderingStartTime=St(),c.sibling=null,h=mt.current,lt(mt,y?h&1|2:h&1),c):(en(c),null);case 22:case 23:return Rm(),y=c.memoizedState!==null,i!==null&&i.memoizedState!==null!==y&&(c.flags|=8192),y&&c.mode&1?Ln&1073741824&&(en(c),c.subtreeFlags&6&&(c.flags|=8192)):en(c),null;case 24:return null;case 25:return null}throw Error(t(156,c.tag))}function FI(i,c){switch(Bh(c),c.tag){case 1:return xn(c.type)&&Zu(),i=c.flags,i&65536?(c.flags=i&-65537|128,c):null;case 3:return la(),ct(yn),ct(Zt),Zh(),i=c.flags,i&65536&&!(i&128)?(c.flags=i&-65537|128,c):null;case 5:return Yh(c),null;case 13:if(ct(mt),i=c.memoizedState,i!==null&&i.dehydrated!==null){if(c.alternate===null)throw Error(t(340));ra()}return i=c.flags,i&65536?(c.flags=i&-65537|128,c):null;case 19:return ct(mt),null;case 4:return la(),null;case 10:return Hh(c.type._context),null;case 22:case 23:return Rm(),null;case 24:return null;default:return null}}var xc=!1,tn=!1,PI=typeof WeakSet=="function"?WeakSet:Set,be=null;function ca(i,c){var h=i.ref;if(h!==null)if(typeof h=="function")try{h(null)}catch(y){vt(i,c,y)}else h.current=null}function xm(i,c,h){try{h()}catch(y){vt(i,c,y)}}var mv=!1;function LI(i,c){if(Rh=Vu,i=qx(),$h(i)){if("selectionStart"in i)var h={start:i.selectionStart,end:i.selectionEnd};else e:{h=(h=i.ownerDocument)&&h.defaultView||window;var y=h.getSelection&&h.getSelection();if(y&&y.rangeCount!==0){h=y.anchorNode;var $=y.anchorOffset,S=y.focusNode;y=y.focusOffset;try{h.nodeType,S.nodeType}catch{h=null;break e}var E=0,B=-1,G=-1,se=0,de=0,pe=i,ce=null;t:for(;;){for(var we;pe!==h||$!==0&&pe.nodeType!==3||(B=E+$),pe!==S||y!==0&&pe.nodeType!==3||(G=E+y),pe.nodeType===3&&(E+=pe.nodeValue.length),(we=pe.firstChild)!==null;)ce=pe,pe=we;for(;;){if(pe===i)break t;if(ce===h&&++se===$&&(B=E),ce===S&&++de===y&&(G=E),(we=pe.nextSibling)!==null)break;pe=ce,ce=pe.parentNode}pe=we}h=B===-1||G===-1?null:{start:B,end:G}}else h=null}h=h||{start:0,end:0}}else h=null;for(_h={focusedElem:i,selectionRange:h},Vu=!1,be=c;be!==null;)if(c=be,i=c.child,(c.subtreeFlags&1028)!==0&&i!==null)i.return=c,be=i;else for(;be!==null;){c=be;try{var Se=c.alternate;if(c.flags&1024)switch(c.tag){case 0:case 11:case 15:break;case 1:if(Se!==null){var ke=Se.memoizedProps,Ct=Se.memoizedState,ee=c.stateNode,q=ee.getSnapshotBeforeUpdate(c.elementType===c.type?ke:is(c.type,ke),Ct);ee.__reactInternalSnapshotBeforeUpdate=q}break;case 3:var te=c.stateNode.containerInfo;te.nodeType===1?te.textContent="":te.nodeType===9&&te.documentElement&&te.removeChild(te.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(t(163))}}catch(fe){vt(c,c.return,fe)}if(i=c.sibling,i!==null){i.return=c.return,be=i;break}be=c.return}return Se=mv,mv=!1,Se}function Ci(i,c,h){var y=c.updateQueue;if(y=y!==null?y.lastEffect:null,y!==null){var $=y=y.next;do{if(($.tag&i)===i){var S=$.destroy;$.destroy=void 0,S!==void 0&&xm(c,h,S)}$=$.next}while($!==y)}}function vc(i,c){if(c=c.updateQueue,c=c!==null?c.lastEffect:null,c!==null){var h=c=c.next;do{if((h.tag&i)===i){var y=h.create;h.destroy=y()}h=h.next}while(h!==c)}}function vm(i){var c=i.ref;if(c!==null){var h=i.stateNode;switch(i.tag){case 5:i=h;break;default:i=h}typeof c=="function"?c(i):c.current=i}}function gv(i){var c=i.alternate;c!==null&&(i.alternate=null,gv(c)),i.child=null,i.deletions=null,i.sibling=null,i.tag===5&&(c=i.stateNode,c!==null&&(delete c[$s],delete c[fi],delete c[Fh],delete c[vI],delete c[wI])),i.stateNode=null,i.return=null,i.dependencies=null,i.memoizedProps=null,i.memoizedState=null,i.pendingProps=null,i.stateNode=null,i.updateQueue=null}function yv(i){return i.tag===5||i.tag===3||i.tag===4}function xv(i){e:for(;;){for(;i.sibling===null;){if(i.return===null||yv(i.return))return null;i=i.return}for(i.sibling.return=i.return,i=i.sibling;i.tag!==5&&i.tag!==6&&i.tag!==18;){if(i.flags&2||i.child===null||i.tag===4)continue e;i.child.return=i,i=i.child}if(!(i.flags&2))return i.stateNode}}function wm(i,c,h){var y=i.tag;if(y===5||y===6)i=i.stateNode,c?h.nodeType===8?h.parentNode.insertBefore(i,c):h.insertBefore(i,c):(h.nodeType===8?(c=h.parentNode,c.insertBefore(i,h)):(c=h,c.appendChild(i)),h=h._reactRootContainer,h!=null||c.onclick!==null||(c.onclick=Yu));else if(y!==4&&(i=i.child,i!==null))for(wm(i,c,h),i=i.sibling;i!==null;)wm(i,c,h),i=i.sibling}function bm(i,c,h){var y=i.tag;if(y===5||y===6)i=i.stateNode,c?h.insertBefore(i,c):h.appendChild(i);else if(y!==4&&(i=i.child,i!==null))for(bm(i,c,h),i=i.sibling;i!==null;)bm(i,c,h),i=i.sibling}var qt=null,ls=!1;function Cr(i,c,h){for(h=h.child;h!==null;)vv(i,c,h),h=h.sibling}function vv(i,c,h){if(bs&&typeof bs.onCommitFiberUnmount=="function")try{bs.onCommitFiberUnmount(Ou,h)}catch{}switch(h.tag){case 5:tn||ca(h,c);case 6:var y=qt,$=ls;qt=null,Cr(i,c,h),qt=y,ls=$,qt!==null&&(ls?(i=qt,h=h.stateNode,i.nodeType===8?i.parentNode.removeChild(h):i.removeChild(h)):qt.removeChild(h.stateNode));break;case 18:qt!==null&&(ls?(i=qt,h=h.stateNode,i.nodeType===8?Ah(i.parentNode,h):i.nodeType===1&&Ah(i,h),ni(i)):Ah(qt,h.stateNode));break;case 4:y=qt,$=ls,qt=h.stateNode.containerInfo,ls=!0,Cr(i,c,h),qt=y,ls=$;break;case 0:case 11:case 14:case 15:if(!tn&&(y=h.updateQueue,y!==null&&(y=y.lastEffect,y!==null))){$=y=y.next;do{var S=$,E=S.destroy;S=S.tag,E!==void 0&&(S&2||S&4)&&xm(h,c,E),$=$.next}while($!==y)}Cr(i,c,h);break;case 1:if(!tn&&(ca(h,c),y=h.stateNode,typeof y.componentWillUnmount=="function"))try{y.props=h.memoizedProps,y.state=h.memoizedState,y.componentWillUnmount()}catch(B){vt(h,c,B)}Cr(i,c,h);break;case 21:Cr(i,c,h);break;case 22:h.mode&1?(tn=(y=tn)||h.memoizedState!==null,Cr(i,c,h),tn=y):Cr(i,c,h);break;default:Cr(i,c,h)}}function wv(i){var c=i.updateQueue;if(c!==null){i.updateQueue=null;var h=i.stateNode;h===null&&(h=i.stateNode=new PI),c.forEach(function(y){var $=jI.bind(null,i,y);h.has(y)||(h.add(y),y.then($,$))})}}function us(i,c){var h=c.deletions;if(h!==null)for(var y=0;y<h.length;y++){var $=h[y];try{var S=i,E=c,B=E;e:for(;B!==null;){switch(B.tag){case 5:qt=B.stateNode,ls=!1;break e;case 3:qt=B.stateNode.containerInfo,ls=!0;break e;case 4:qt=B.stateNode.containerInfo,ls=!0;break e}B=B.return}if(qt===null)throw Error(t(160));vv(S,E,$),qt=null,ls=!1;var G=$.alternate;G!==null&&(G.return=null),$.return=null}catch(se){vt($,c,se)}}if(c.subtreeFlags&12854)for(c=c.child;c!==null;)bv(c,i),c=c.sibling}function bv(i,c){var h=i.alternate,y=i.flags;switch(i.tag){case 0:case 11:case 14:case 15:if(us(c,i),ks(i),y&4){try{Ci(3,i,i.return),vc(3,i)}catch(ke){vt(i,i.return,ke)}try{Ci(5,i,i.return)}catch(ke){vt(i,i.return,ke)}}break;case 1:us(c,i),ks(i),y&512&&h!==null&&ca(h,h.return);break;case 5:if(us(c,i),ks(i),y&512&&h!==null&&ca(h,h.return),i.flags&32){var $=i.stateNode;try{Vs($,"")}catch(ke){vt(i,i.return,ke)}}if(y&4&&($=i.stateNode,$!=null)){var S=i.memoizedProps,E=h!==null?h.memoizedProps:S,B=i.type,G=i.updateQueue;if(i.updateQueue=null,G!==null)try{B==="input"&&S.type==="radio"&&S.name!=null&&He($,S),Zf(B,E);var se=Zf(B,S);for(E=0;E<G.length;E+=2){var de=G[E],pe=G[E+1];de==="style"?Tu($,pe):de==="dangerouslySetInnerHTML"?dr($,pe):de==="children"?Vs($,pe):I($,de,pe,se)}switch(B){case"input":Je($,S);break;case"textarea":gn($,S);break;case"select":var ce=$._wrapperState.wasMultiple;$._wrapperState.wasMultiple=!!S.multiple;var we=S.value;we!=null?cn($,!!S.multiple,we,!1):ce!==!!S.multiple&&(S.defaultValue!=null?cn($,!!S.multiple,S.defaultValue,!0):cn($,!!S.multiple,S.multiple?[]:"",!1))}$[fi]=S}catch(ke){vt(i,i.return,ke)}}break;case 6:if(us(c,i),ks(i),y&4){if(i.stateNode===null)throw Error(t(162));$=i.stateNode,S=i.memoizedProps;try{$.nodeValue=S}catch(ke){vt(i,i.return,ke)}}break;case 3:if(us(c,i),ks(i),y&4&&h!==null&&h.memoizedState.isDehydrated)try{ni(c.containerInfo)}catch(ke){vt(i,i.return,ke)}break;case 4:us(c,i),ks(i);break;case 13:us(c,i),ks(i),$=i.child,$.flags&8192&&(S=$.memoizedState!==null,$.stateNode.isHidden=S,!S||$.alternate!==null&&$.alternate.memoizedState!==null||(Cm=St())),y&4&&wv(i);break;case 22:if(de=h!==null&&h.memoizedState!==null,i.mode&1?(tn=(se=tn)||de,us(c,i),tn=se):us(c,i),ks(i),y&8192){if(se=i.memoizedState!==null,(i.stateNode.isHidden=se)&&!de&&i.mode&1)for(be=i,de=i.child;de!==null;){for(pe=be=de;be!==null;){switch(ce=be,we=ce.child,ce.tag){case 0:case 11:case 14:case 15:Ci(4,ce,ce.return);break;case 1:ca(ce,ce.return);var Se=ce.stateNode;if(typeof Se.componentWillUnmount=="function"){y=ce,h=ce.return;try{c=y,Se.props=c.memoizedProps,Se.state=c.memoizedState,Se.componentWillUnmount()}catch(ke){vt(y,h,ke)}}break;case 5:ca(ce,ce.return);break;case 22:if(ce.memoizedState!==null){Cv(pe);continue}}we!==null?(we.return=ce,be=we):Cv(pe)}de=de.sibling}e:for(de=null,pe=i;;){if(pe.tag===5){if(de===null){de=pe;try{$=pe.stateNode,se?(S=$.style,typeof S.setProperty=="function"?S.setProperty("display","none","important"):S.display="none"):(B=pe.stateNode,G=pe.memoizedProps.style,E=G!=null&&G.hasOwnProperty("display")?G.display:null,B.style.display=Jr("display",E))}catch(ke){vt(i,i.return,ke)}}}else if(pe.tag===6){if(de===null)try{pe.stateNode.nodeValue=se?"":pe.memoizedProps}catch(ke){vt(i,i.return,ke)}}else if((pe.tag!==22&&pe.tag!==23||pe.memoizedState===null||pe===i)&&pe.child!==null){pe.child.return=pe,pe=pe.child;continue}if(pe===i)break e;for(;pe.sibling===null;){if(pe.return===null||pe.return===i)break e;de===pe&&(de=null),pe=pe.return}de===pe&&(de=null),pe.sibling.return=pe.return,pe=pe.sibling}}break;case 19:us(c,i),ks(i),y&4&&wv(i);break;case 21:break;default:us(c,i),ks(i)}}function ks(i){var c=i.flags;if(c&2){try{e:{for(var h=i.return;h!==null;){if(yv(h)){var y=h;break e}h=h.return}throw Error(t(160))}switch(y.tag){case 5:var $=y.stateNode;y.flags&32&&(Vs($,""),y.flags&=-33);var S=xv(i);bm(i,S,$);break;case 3:case 4:var E=y.stateNode.containerInfo,B=xv(i);wm(i,B,E);break;default:throw Error(t(161))}}catch(G){vt(i,i.return,G)}i.flags&=-3}c&4096&&(i.flags&=-4097)}function VI(i,c,h){be=i,$v(i)}function $v(i,c,h){for(var y=(i.mode&1)!==0;be!==null;){var $=be,S=$.child;if($.tag===22&&y){var E=$.memoizedState!==null||xc;if(!E){var B=$.alternate,G=B!==null&&B.memoizedState!==null||tn;B=xc;var se=tn;if(xc=E,(tn=G)&&!se)for(be=$;be!==null;)E=be,G=E.child,E.tag===22&&E.memoizedState!==null?kv($):G!==null?(G.return=E,be=G):kv($);for(;S!==null;)be=S,$v(S),S=S.sibling;be=$,xc=B,tn=se}Sv(i)}else $.subtreeFlags&8772&&S!==null?(S.return=$,be=S):Sv(i)}}function Sv(i){for(;be!==null;){var c=be;if(c.flags&8772){var h=c.alternate;try{if(c.flags&8772)switch(c.tag){case 0:case 11:case 15:tn||vc(5,c);break;case 1:var y=c.stateNode;if(c.flags&4&&!tn)if(h===null)y.componentDidMount();else{var $=c.elementType===c.type?h.memoizedProps:is(c.type,h.memoizedProps);y.componentDidUpdate($,h.memoizedState,y.__reactInternalSnapshotBeforeUpdate)}var S=c.updateQueue;S!==null&&C1(c,S,y);break;case 3:var E=c.updateQueue;if(E!==null){if(h=null,c.child!==null)switch(c.child.tag){case 5:h=c.child.stateNode;break;case 1:h=c.child.stateNode}C1(c,E,h)}break;case 5:var B=c.stateNode;if(h===null&&c.flags&4){h=B;var G=c.memoizedProps;switch(c.type){case"button":case"input":case"select":case"textarea":G.autoFocus&&h.focus();break;case"img":G.src&&(h.src=G.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(c.memoizedState===null){var se=c.alternate;if(se!==null){var de=se.memoizedState;if(de!==null){var pe=de.dehydrated;pe!==null&&ni(pe)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(t(163))}tn||c.flags&512&&vm(c)}catch(ce){vt(c,c.return,ce)}}if(c===i){be=null;break}if(h=c.sibling,h!==null){h.return=c.return,be=h;break}be=c.return}}function Cv(i){for(;be!==null;){var c=be;if(c===i){be=null;break}var h=c.sibling;if(h!==null){h.return=c.return,be=h;break}be=c.return}}function kv(i){for(;be!==null;){var c=be;try{switch(c.tag){case 0:case 11:case 15:var h=c.return;try{vc(4,c)}catch(G){vt(c,h,G)}break;case 1:var y=c.stateNode;if(typeof y.componentDidMount=="function"){var $=c.return;try{y.componentDidMount()}catch(G){vt(c,$,G)}}var S=c.return;try{vm(c)}catch(G){vt(c,S,G)}break;case 5:var E=c.return;try{vm(c)}catch(G){vt(c,E,G)}}}catch(G){vt(c,c.return,G)}if(c===i){be=null;break}var B=c.sibling;if(B!==null){B.return=c.return,be=B;break}be=c.return}}var BI=Math.ceil,wc=N.ReactCurrentDispatcher,$m=N.ReactCurrentOwner,Kn=N.ReactCurrentBatchConfig,We=0,Pt=null,Nt=null,Kt=0,Ln=0,da=vr(0),Rt=0,ki=null,lo=0,bc=0,Sm=0,Ni=null,wn=null,Cm=0,pa=1/0,qs=null,$c=!1,km=null,kr=null,Sc=!1,Nr=null,Cc=0,Ii=0,Nm=null,kc=-1,Nc=0;function pn(){return We&6?St():kc!==-1?kc:kc=St()}function Ir(i){return i.mode&1?We&2&&Kt!==0?Kt&-Kt:$I.transition!==null?(Nc===0&&(Nc=xx()),Nc):(i=Ye,i!==0||(i=window.event,i=i===void 0?16:Ix(i.type)),i):1}function cs(i,c,h,y){if(50<Ii)throw Ii=0,Nm=null,Error(t(185));Qa(i,h,y),(!(We&2)||i!==Pt)&&(i===Pt&&(!(We&2)&&(bc|=h),Rt===4&&Tr(i,Kt)),bn(i,y),h===1&&We===0&&!(c.mode&1)&&(pa=St()+500,ec&&br()))}function bn(i,c){var h=i.callbackNode;$2(i,c);var y=Fu(i,i===Pt?Kt:0);if(y===0)h!==null&&mx(h),i.callbackNode=null,i.callbackPriority=0;else if(c=y&-y,i.callbackPriority!==c){if(h!=null&&mx(h),c===1)i.tag===0?bI(Iv.bind(null,i)):p1(Iv.bind(null,i)),yI(function(){!(We&6)&&br()}),h=null;else{switch(vx(y)){case 1:h=oh;break;case 4:h=gx;break;case 16:h=_u;break;case 536870912:h=yx;break;default:h=_u}h=Fv(h,Nv.bind(null,i))}i.callbackPriority=c,i.callbackNode=h}}function Nv(i,c){if(kc=-1,Nc=0,We&6)throw Error(t(327));var h=i.callbackNode;if(fa()&&i.callbackNode!==h)return null;var y=Fu(i,i===Pt?Kt:0);if(y===0)return null;if(y&30||y&i.expiredLanes||c)c=Ic(i,y);else{c=y;var $=We;We|=2;var S=Ev();(Pt!==i||Kt!==c)&&(qs=null,pa=St()+500,co(i,c));do try{WI();break}catch(B){Tv(i,B)}while(!0);Gh(),wc.current=S,We=$,Nt!==null?c=0:(Pt=null,Kt=0,c=Rt)}if(c!==0){if(c===2&&($=ah(i),$!==0&&(y=$,c=Im(i,$))),c===1)throw h=ki,co(i,0),Tr(i,y),bn(i,St()),h;if(c===6)Tr(i,y);else{if($=i.current.alternate,!(y&30)&&!MI($)&&(c=Ic(i,y),c===2&&(S=ah(i),S!==0&&(y=S,c=Im(i,S))),c===1))throw h=ki,co(i,0),Tr(i,y),bn(i,St()),h;switch(i.finishedWork=$,i.finishedLanes=y,c){case 0:case 1:throw Error(t(345));case 2:po(i,wn,qs);break;case 3:if(Tr(i,y),(y&130023424)===y&&(c=Cm+500-St(),10<c)){if(Fu(i,0)!==0)break;if($=i.suspendedLanes,($&y)!==y){pn(),i.pingedLanes|=i.suspendedLanes&$;break}i.timeoutHandle=Dh(po.bind(null,i,wn,qs),c);break}po(i,wn,qs);break;case 4:if(Tr(i,y),(y&4194240)===y)break;for(c=i.eventTimes,$=-1;0<y;){var E=31-rs(y);S=1<<E,E=c[E],E>$&&($=E),y&=~S}if(y=$,y=St()-y,y=(120>y?120:480>y?480:1080>y?1080:1920>y?1920:3e3>y?3e3:4320>y?4320:1960*BI(y/1960))-y,10<y){i.timeoutHandle=Dh(po.bind(null,i,wn,qs),y);break}po(i,wn,qs);break;case 5:po(i,wn,qs);break;default:throw Error(t(329))}}}return bn(i,St()),i.callbackNode===h?Nv.bind(null,i):null}function Im(i,c){var h=Ni;return i.current.memoizedState.isDehydrated&&(co(i,c).flags|=256),i=Ic(i,c),i!==2&&(c=wn,wn=h,c!==null&&Tm(c)),i}function Tm(i){wn===null?wn=i:wn.push.apply(wn,i)}function MI(i){for(var c=i;;){if(c.flags&16384){var h=c.updateQueue;if(h!==null&&(h=h.stores,h!==null))for(var y=0;y<h.length;y++){var $=h[y],S=$.getSnapshot;$=$.value;try{if(!os(S(),$))return!1}catch{return!1}}}if(h=c.child,c.subtreeFlags&16384&&h!==null)h.return=c,c=h;else{if(c===i)break;for(;c.sibling===null;){if(c.return===null||c.return===i)return!0;c=c.return}c.sibling.return=c.return,c=c.sibling}}return!0}function Tr(i,c){for(c&=~Sm,c&=~bc,i.suspendedLanes|=c,i.pingedLanes&=~c,i=i.expirationTimes;0<c;){var h=31-rs(c),y=1<<h;i[h]=-1,c&=~y}}function Iv(i){if(We&6)throw Error(t(327));fa();var c=Fu(i,0);if(!(c&1))return bn(i,St()),null;var h=Ic(i,c);if(i.tag!==0&&h===2){var y=ah(i);y!==0&&(c=y,h=Im(i,y))}if(h===1)throw h=ki,co(i,0),Tr(i,c),bn(i,St()),h;if(h===6)throw Error(t(345));return i.finishedWork=i.current.alternate,i.finishedLanes=c,po(i,wn,qs),bn(i,St()),null}function Em(i,c){var h=We;We|=1;try{return i(c)}finally{We=h,We===0&&(pa=St()+500,ec&&br())}}function uo(i){Nr!==null&&Nr.tag===0&&!(We&6)&&fa();var c=We;We|=1;var h=Kn.transition,y=Ye;try{if(Kn.transition=null,Ye=1,i)return i()}finally{Ye=y,Kn.transition=h,We=c,!(We&6)&&br()}}function Rm(){Ln=da.current,ct(da)}function co(i,c){i.finishedWork=null,i.finishedLanes=0;var h=i.timeoutHandle;if(h!==-1&&(i.timeoutHandle=-1,gI(h)),Nt!==null)for(h=Nt.return;h!==null;){var y=h;switch(Bh(y),y.tag){case 1:y=y.type.childContextTypes,y!=null&&Zu();break;case 3:la(),ct(yn),ct(Zt),Zh();break;case 5:Yh(y);break;case 4:la();break;case 13:ct(mt);break;case 19:ct(mt);break;case 10:Hh(y.type._context);break;case 22:case 23:Rm()}h=h.return}if(Pt=i,Nt=i=Er(i.current,null),Kt=Ln=c,Rt=0,ki=null,Sm=bc=lo=0,wn=Ni=null,oo!==null){for(c=0;c<oo.length;c++)if(h=oo[c],y=h.interleaved,y!==null){h.interleaved=null;var $=y.next,S=h.pending;if(S!==null){var E=S.next;S.next=$,y.next=E}h.pending=y}oo=null}return i}function Tv(i,c){do{var h=Nt;try{if(Gh(),cc.current=hc,dc){for(var y=gt.memoizedState;y!==null;){var $=y.queue;$!==null&&($.pending=null),y=y.next}dc=!1}if(io=0,Ft=Et=gt=null,vi=!1,wi=0,$m.current=null,h===null||h.return===null){Rt=1,ki=c,Nt=null;break}e:{var S=i,E=h.return,B=h,G=c;if(c=Kt,B.flags|=32768,G!==null&&typeof G=="object"&&typeof G.then=="function"){var se=G,de=B,pe=de.tag;if(!(de.mode&1)&&(pe===0||pe===11||pe===15)){var ce=de.alternate;ce?(de.updateQueue=ce.updateQueue,de.memoizedState=ce.memoizedState,de.lanes=ce.lanes):(de.updateQueue=null,de.memoizedState=null)}var we=J1(E);if(we!==null){we.flags&=-257,ev(we,E,B,S,c),we.mode&1&&Z1(S,se,c),c=we,G=se;var Se=c.updateQueue;if(Se===null){var ke=new Set;ke.add(G),c.updateQueue=ke}else Se.add(G);break e}else{if(!(c&1)){Z1(S,se,c),_m();break e}G=Error(t(426))}}else if(pt&&B.mode&1){var Ct=J1(E);if(Ct!==null){!(Ct.flags&65536)&&(Ct.flags|=256),ev(Ct,E,B,S,c),Wh(ua(G,B));break e}}S=G=ua(G,B),Rt!==4&&(Rt=2),Ni===null?Ni=[S]:Ni.push(S),S=E;do{switch(S.tag){case 3:S.flags|=65536,c&=-c,S.lanes|=c;var ee=Y1(S,G,c);S1(S,ee);break e;case 1:B=G;var q=S.type,te=S.stateNode;if(!(S.flags&128)&&(typeof q.getDerivedStateFromError=="function"||te!==null&&typeof te.componentDidCatch=="function"&&(kr===null||!kr.has(te)))){S.flags|=65536,c&=-c,S.lanes|=c;var fe=Q1(S,B,c);S1(S,fe);break e}}S=S.return}while(S!==null)}_v(h)}catch(Ne){c=Ne,Nt===h&&h!==null&&(Nt=h=h.return);continue}break}while(!0)}function Ev(){var i=wc.current;return wc.current=hc,i===null?hc:i}function _m(){(Rt===0||Rt===3||Rt===2)&&(Rt=4),Pt===null||!(lo&268435455)&&!(bc&268435455)||Tr(Pt,Kt)}function Ic(i,c){var h=We;We|=2;var y=Ev();(Pt!==i||Kt!==c)&&(qs=null,co(i,c));do try{zI();break}catch($){Tv(i,$)}while(!0);if(Gh(),We=h,wc.current=y,Nt!==null)throw Error(t(261));return Pt=null,Kt=0,Rt}function zI(){for(;Nt!==null;)Rv(Nt)}function WI(){for(;Nt!==null&&!f2();)Rv(Nt)}function Rv(i){var c=Av(i.alternate,i,Ln);i.memoizedProps=i.pendingProps,c===null?_v(i):Nt=c,$m.current=null}function _v(i){var c=i;do{var h=c.alternate;if(i=c.return,c.flags&32768){if(h=FI(h,c),h!==null){h.flags&=32767,Nt=h;return}if(i!==null)i.flags|=32768,i.subtreeFlags=0,i.deletions=null;else{Rt=6,Nt=null;return}}else if(h=AI(h,c,Ln),h!==null){Nt=h;return}if(c=c.sibling,c!==null){Nt=c;return}Nt=c=i}while(c!==null);Rt===0&&(Rt=5)}function po(i,c,h){var y=Ye,$=Kn.transition;try{Kn.transition=null,Ye=1,UI(i,c,h,y)}finally{Kn.transition=$,Ye=y}return null}function UI(i,c,h,y){do fa();while(Nr!==null);if(We&6)throw Error(t(327));h=i.finishedWork;var $=i.finishedLanes;if(h===null)return null;if(i.finishedWork=null,i.finishedLanes=0,h===i.current)throw Error(t(177));i.callbackNode=null,i.callbackPriority=0;var S=h.lanes|h.childLanes;if(S2(i,S),i===Pt&&(Nt=Pt=null,Kt=0),!(h.subtreeFlags&2064)&&!(h.flags&2064)||Sc||(Sc=!0,Fv(_u,function(){return fa(),null})),S=(h.flags&15990)!==0,h.subtreeFlags&15990||S){S=Kn.transition,Kn.transition=null;var E=Ye;Ye=1;var B=We;We|=4,$m.current=null,LI(i,h),bv(h,i),uI(_h),Vu=!!Rh,_h=Rh=null,i.current=h,VI(h),h2(),We=B,Ye=E,Kn.transition=S}else i.current=h;if(Sc&&(Sc=!1,Nr=i,Cc=$),S=i.pendingLanes,S===0&&(kr=null),y2(h.stateNode),bn(i,St()),c!==null)for(y=i.onRecoverableError,h=0;h<c.length;h++)$=c[h],y($.value,{componentStack:$.stack,digest:$.digest});if($c)throw $c=!1,i=km,km=null,i;return Cc&1&&i.tag!==0&&fa(),S=i.pendingLanes,S&1?i===Nm?Ii++:(Ii=0,Nm=i):Ii=0,br(),null}function fa(){if(Nr!==null){var i=vx(Cc),c=Kn.transition,h=Ye;try{if(Kn.transition=null,Ye=16>i?16:i,Nr===null)var y=!1;else{if(i=Nr,Nr=null,Cc=0,We&6)throw Error(t(331));var $=We;for(We|=4,be=i.current;be!==null;){var S=be,E=S.child;if(be.flags&16){var B=S.deletions;if(B!==null){for(var G=0;G<B.length;G++){var se=B[G];for(be=se;be!==null;){var de=be;switch(de.tag){case 0:case 11:case 15:Ci(8,de,S)}var pe=de.child;if(pe!==null)pe.return=de,be=pe;else for(;be!==null;){de=be;var ce=de.sibling,we=de.return;if(gv(de),de===se){be=null;break}if(ce!==null){ce.return=we,be=ce;break}be=we}}}var Se=S.alternate;if(Se!==null){var ke=Se.child;if(ke!==null){Se.child=null;do{var Ct=ke.sibling;ke.sibling=null,ke=Ct}while(ke!==null)}}be=S}}if(S.subtreeFlags&2064&&E!==null)E.return=S,be=E;else e:for(;be!==null;){if(S=be,S.flags&2048)switch(S.tag){case 0:case 11:case 15:Ci(9,S,S.return)}var ee=S.sibling;if(ee!==null){ee.return=S.return,be=ee;break e}be=S.return}}var q=i.current;for(be=q;be!==null;){E=be;var te=E.child;if(E.subtreeFlags&2064&&te!==null)te.return=E,be=te;else e:for(E=q;be!==null;){if(B=be,B.flags&2048)try{switch(B.tag){case 0:case 11:case 15:vc(9,B)}}catch(Ne){vt(B,B.return,Ne)}if(B===E){be=null;break e}var fe=B.sibling;if(fe!==null){fe.return=B.return,be=fe;break e}be=B.return}}if(We=$,br(),bs&&typeof bs.onPostCommitFiberRoot=="function")try{bs.onPostCommitFiberRoot(Ou,i)}catch{}y=!0}return y}finally{Ye=h,Kn.transition=c}}return!1}function Ov(i,c,h){c=ua(h,c),c=Y1(i,c,1),i=Sr(i,c,1),c=pn(),i!==null&&(Qa(i,1,c),bn(i,c))}function vt(i,c,h){if(i.tag===3)Ov(i,i,h);else for(;c!==null;){if(c.tag===3){Ov(c,i,h);break}else if(c.tag===1){var y=c.stateNode;if(typeof c.type.getDerivedStateFromError=="function"||typeof y.componentDidCatch=="function"&&(kr===null||!kr.has(y))){i=ua(h,i),i=Q1(c,i,1),c=Sr(c,i,1),i=pn(),c!==null&&(Qa(c,1,i),bn(c,i));break}}c=c.return}}function GI(i,c,h){var y=i.pingCache;y!==null&&y.delete(c),c=pn(),i.pingedLanes|=i.suspendedLanes&h,Pt===i&&(Kt&h)===h&&(Rt===4||Rt===3&&(Kt&130023424)===Kt&&500>St()-Cm?co(i,0):Sm|=h),bn(i,c)}function Dv(i,c){c===0&&(i.mode&1?(c=Au,Au<<=1,!(Au&130023424)&&(Au=4194304)):c=1);var h=pn();i=Gs(i,c),i!==null&&(Qa(i,c,h),bn(i,h))}function HI(i){var c=i.memoizedState,h=0;c!==null&&(h=c.retryLane),Dv(i,h)}function jI(i,c){var h=0;switch(i.tag){case 13:var y=i.stateNode,$=i.memoizedState;$!==null&&(h=$.retryLane);break;case 19:y=i.stateNode;break;default:throw Error(t(314))}y!==null&&y.delete(c),Dv(i,h)}var Av;Av=function(i,c,h){if(i!==null)if(i.memoizedProps!==c.pendingProps||yn.current)vn=!0;else{if(!(i.lanes&h)&&!(c.flags&128))return vn=!1,DI(i,c,h);vn=!!(i.flags&131072)}else vn=!1,pt&&c.flags&1048576&&f1(c,nc,c.index);switch(c.lanes=0,c.tag){case 2:var y=c.type;yc(i,c),i=c.pendingProps;var $=ta(c,Zt.current);ia(c,h),$=tm(null,c,y,i,$,h);var S=nm();return c.flags|=1,typeof $=="object"&&$!==null&&typeof $.render=="function"&&$.$$typeof===void 0?(c.tag=1,c.memoizedState=null,c.updateQueue=null,xn(y)?(S=!0,Ju(c)):S=!1,c.memoizedState=$.state!==null&&$.state!==void 0?$.state:null,Kh(c),$.updater=mc,c.stateNode=$,$._reactInternals=c,lm(c,y,i,h),c=pm(null,c,y,!0,S,h)):(c.tag=0,pt&&S&&Vh(c),dn(null,c,$,h),c=c.child),c;case 16:y=c.elementType;e:{switch(yc(i,c),i=c.pendingProps,$=y._init,y=$(y._payload),c.type=y,$=c.tag=KI(y),i=is(y,i),$){case 0:c=dm(null,c,y,i,h);break e;case 1:c=av(null,c,y,i,h);break e;case 11:c=tv(null,c,y,i,h);break e;case 14:c=nv(null,c,y,is(y.type,i),h);break e}throw Error(t(306,y,""))}return c;case 0:return y=c.type,$=c.pendingProps,$=c.elementType===y?$:is(y,$),dm(i,c,y,$,h);case 1:return y=c.type,$=c.pendingProps,$=c.elementType===y?$:is(y,$),av(i,c,y,$,h);case 3:e:{if(iv(c),i===null)throw Error(t(387));y=c.pendingProps,S=c.memoizedState,$=S.element,$1(i,c),lc(c,y,null,h);var E=c.memoizedState;if(y=E.element,S.isDehydrated)if(S={element:y,isDehydrated:!1,cache:E.cache,pendingSuspenseBoundaries:E.pendingSuspenseBoundaries,transitions:E.transitions},c.updateQueue.baseState=S,c.memoizedState=S,c.flags&256){$=ua(Error(t(423)),c),c=lv(i,c,y,h,$);break e}else if(y!==$){$=ua(Error(t(424)),c),c=lv(i,c,y,h,$);break e}else for(Pn=xr(c.stateNode.containerInfo.firstChild),Fn=c,pt=!0,as=null,h=w1(c,null,y,h),c.child=h;h;)h.flags=h.flags&-3|4096,h=h.sibling;else{if(ra(),y===$){c=js(i,c,h);break e}dn(i,c,y,h)}c=c.child}return c;case 5:return k1(c),i===null&&zh(c),y=c.type,$=c.pendingProps,S=i!==null?i.memoizedProps:null,E=$.children,Oh(y,$)?E=null:S!==null&&Oh(y,S)&&(c.flags|=32),ov(i,c),dn(i,c,E,h),c.child;case 6:return i===null&&zh(c),null;case 13:return uv(i,c,h);case 4:return Xh(c,c.stateNode.containerInfo),y=c.pendingProps,i===null?c.child=oa(c,null,y,h):dn(i,c,y,h),c.child;case 11:return y=c.type,$=c.pendingProps,$=c.elementType===y?$:is(y,$),tv(i,c,y,$,h);case 7:return dn(i,c,c.pendingProps,h),c.child;case 8:return dn(i,c,c.pendingProps.children,h),c.child;case 12:return dn(i,c,c.pendingProps.children,h),c.child;case 10:e:{if(y=c.type._context,$=c.pendingProps,S=c.memoizedProps,E=$.value,lt(oc,y._currentValue),y._currentValue=E,S!==null)if(os(S.value,E)){if(S.children===$.children&&!yn.current){c=js(i,c,h);break e}}else for(S=c.child,S!==null&&(S.return=c);S!==null;){var B=S.dependencies;if(B!==null){E=S.child;for(var G=B.firstContext;G!==null;){if(G.context===y){if(S.tag===1){G=Hs(-1,h&-h),G.tag=2;var se=S.updateQueue;if(se!==null){se=se.shared;var de=se.pending;de===null?G.next=G:(G.next=de.next,de.next=G),se.pending=G}}S.lanes|=h,G=S.alternate,G!==null&&(G.lanes|=h),jh(S.return,h,c),B.lanes|=h;break}G=G.next}}else if(S.tag===10)E=S.type===c.type?null:S.child;else if(S.tag===18){if(E=S.return,E===null)throw Error(t(341));E.lanes|=h,B=E.alternate,B!==null&&(B.lanes|=h),jh(E,h,c),E=S.sibling}else E=S.child;if(E!==null)E.return=S;else for(E=S;E!==null;){if(E===c){E=null;break}if(S=E.sibling,S!==null){S.return=E.return,E=S;break}E=E.return}S=E}dn(i,c,$.children,h),c=c.child}return c;case 9:return $=c.type,y=c.pendingProps.children,ia(c,h),$=jn($),y=y($),c.flags|=1,dn(i,c,y,h),c.child;case 14:return y=c.type,$=is(y,c.pendingProps),$=is(y.type,$),nv(i,c,y,$,h);case 15:return sv(i,c,c.type,c.pendingProps,h);case 17:return y=c.type,$=c.pendingProps,$=c.elementType===y?$:is(y,$),yc(i,c),c.tag=1,xn(y)?(i=!0,Ju(c)):i=!1,ia(c,h),K1(c,y,$),lm(c,y,$,h),pm(null,c,y,!0,i,h);case 19:return dv(i,c,h);case 22:return rv(i,c,h)}throw Error(t(156,c.tag))};function Fv(i,c){return hx(i,c)}function qI(i,c,h,y){this.tag=i,this.key=h,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=c,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=y,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Xn(i,c,h,y){return new qI(i,c,h,y)}function Om(i){return i=i.prototype,!(!i||!i.isReactComponent)}function KI(i){if(typeof i=="function")return Om(i)?1:0;if(i!=null){if(i=i.$$typeof,i===W)return 11;if(i===Q)return 14}return 2}function Er(i,c){var h=i.alternate;return h===null?(h=Xn(i.tag,c,i.key,i.mode),h.elementType=i.elementType,h.type=i.type,h.stateNode=i.stateNode,h.alternate=i,i.alternate=h):(h.pendingProps=c,h.type=i.type,h.flags=0,h.subtreeFlags=0,h.deletions=null),h.flags=i.flags&14680064,h.childLanes=i.childLanes,h.lanes=i.lanes,h.child=i.child,h.memoizedProps=i.memoizedProps,h.memoizedState=i.memoizedState,h.updateQueue=i.updateQueue,c=i.dependencies,h.dependencies=c===null?null:{lanes:c.lanes,firstContext:c.firstContext},h.sibling=i.sibling,h.index=i.index,h.ref=i.ref,h}function Tc(i,c,h,y,$,S){var E=2;if(y=i,typeof i=="function")Om(i)&&(E=1);else if(typeof i=="string")E=5;else e:switch(i){case F:return fo(h.children,$,S,c);case V:E=8,$|=8;break;case P:return i=Xn(12,h,c,$|2),i.elementType=P,i.lanes=S,i;case j:return i=Xn(13,h,c,$),i.elementType=j,i.lanes=S,i;case Y:return i=Xn(19,h,c,$),i.elementType=Y,i.lanes=S,i;case ne:return Ec(h,$,S,c);default:if(typeof i=="object"&&i!==null)switch(i.$$typeof){case A:E=10;break e;case T:E=9;break e;case W:E=11;break e;case Q:E=14;break e;case Z:E=16,y=null;break e}throw Error(t(130,i==null?i:typeof i,""))}return c=Xn(E,h,c,$),c.elementType=i,c.type=y,c.lanes=S,c}function fo(i,c,h,y){return i=Xn(7,i,y,c),i.lanes=h,i}function Ec(i,c,h,y){return i=Xn(22,i,y,c),i.elementType=ne,i.lanes=h,i.stateNode={isHidden:!1},i}function Dm(i,c,h){return i=Xn(6,i,null,c),i.lanes=h,i}function Am(i,c,h){return c=Xn(4,i.children!==null?i.children:[],i.key,c),c.lanes=h,c.stateNode={containerInfo:i.containerInfo,pendingChildren:null,implementation:i.implementation},c}function XI(i,c,h,y,$){this.tag=c,this.containerInfo=i,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=ih(0),this.expirationTimes=ih(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=ih(0),this.identifierPrefix=y,this.onRecoverableError=$,this.mutableSourceEagerHydrationData=null}function Fm(i,c,h,y,$,S,E,B,G){return i=new XI(i,c,h,B,G),c===1?(c=1,S===!0&&(c|=8)):c=0,S=Xn(3,null,null,c),i.current=S,S.stateNode=i,S.memoizedState={element:y,isDehydrated:h,cache:null,transitions:null,pendingSuspenseBoundaries:null},Kh(S),i}function YI(i,c,h){var y=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:D,key:y==null?null:""+y,children:i,containerInfo:c,implementation:h}}function Pv(i){if(!i)return wr;i=i._reactInternals;e:{if(eo(i)!==i||i.tag!==1)throw Error(t(170));var c=i;do{switch(c.tag){case 3:c=c.stateNode.context;break e;case 1:if(xn(c.type)){c=c.stateNode.__reactInternalMemoizedMergedChildContext;break e}}c=c.return}while(c!==null);throw Error(t(171))}if(i.tag===1){var h=i.type;if(xn(h))return c1(i,h,c)}return c}function Lv(i,c,h,y,$,S,E,B,G){return i=Fm(h,y,!0,i,$,S,E,B,G),i.context=Pv(null),h=i.current,y=pn(),$=Ir(h),S=Hs(y,$),S.callback=c??null,Sr(h,S,$),i.current.lanes=$,Qa(i,$,y),bn(i,y),i}function Rc(i,c,h,y){var $=c.current,S=pn(),E=Ir($);return h=Pv(h),c.context===null?c.context=h:c.pendingContext=h,c=Hs(S,E),c.payload={element:i},y=y===void 0?null:y,y!==null&&(c.callback=y),i=Sr($,c,E),i!==null&&(cs(i,$,E,S),ic(i,$,E)),E}function _c(i){if(i=i.current,!i.child)return null;switch(i.child.tag){case 5:return i.child.stateNode;default:return i.child.stateNode}}function Vv(i,c){if(i=i.memoizedState,i!==null&&i.dehydrated!==null){var h=i.retryLane;i.retryLane=h!==0&&h<c?h:c}}function Pm(i,c){Vv(i,c),(i=i.alternate)&&Vv(i,c)}function QI(){return null}var Bv=typeof reportError=="function"?reportError:function(i){console.error(i)};function Lm(i){this._internalRoot=i}Oc.prototype.render=Lm.prototype.render=function(i){var c=this._internalRoot;if(c===null)throw Error(t(409));Rc(i,c,null,null)},Oc.prototype.unmount=Lm.prototype.unmount=function(){var i=this._internalRoot;if(i!==null){this._internalRoot=null;var c=i.containerInfo;uo(function(){Rc(null,i,null,null)}),c[Ms]=null}};function Oc(i){this._internalRoot=i}Oc.prototype.unstable_scheduleHydration=function(i){if(i){var c=$x();i={blockedOn:null,target:i,priority:c};for(var h=0;h<mr.length&&c!==0&&c<mr[h].priority;h++);mr.splice(h,0,i),h===0&&kx(i)}};function Vm(i){return!(!i||i.nodeType!==1&&i.nodeType!==9&&i.nodeType!==11)}function Dc(i){return!(!i||i.nodeType!==1&&i.nodeType!==9&&i.nodeType!==11&&(i.nodeType!==8||i.nodeValue!==" react-mount-point-unstable "))}function Mv(){}function ZI(i,c,h,y,$){if($){if(typeof y=="function"){var S=y;y=function(){var se=_c(E);S.call(se)}}var E=Lv(c,y,i,0,null,!1,!1,"",Mv);return i._reactRootContainer=E,i[Ms]=E.current,di(i.nodeType===8?i.parentNode:i),uo(),E}for(;$=i.lastChild;)i.removeChild($);if(typeof y=="function"){var B=y;y=function(){var se=_c(G);B.call(se)}}var G=Fm(i,0,!1,null,null,!1,!1,"",Mv);return i._reactRootContainer=G,i[Ms]=G.current,di(i.nodeType===8?i.parentNode:i),uo(function(){Rc(c,G,h,y)}),G}function Ac(i,c,h,y,$){var S=h._reactRootContainer;if(S){var E=S;if(typeof $=="function"){var B=$;$=function(){var G=_c(E);B.call(G)}}Rc(c,E,i,$)}else E=ZI(h,c,i,$,y);return _c(E)}wx=function(i){switch(i.tag){case 3:var c=i.stateNode;if(c.current.memoizedState.isDehydrated){var h=Ya(c.pendingLanes);h!==0&&(lh(c,h|1),bn(c,St()),!(We&6)&&(pa=St()+500,br()))}break;case 13:uo(function(){var y=Gs(i,1);if(y!==null){var $=pn();cs(y,i,1,$)}}),Pm(i,1)}},uh=function(i){if(i.tag===13){var c=Gs(i,134217728);if(c!==null){var h=pn();cs(c,i,134217728,h)}Pm(i,134217728)}},bx=function(i){if(i.tag===13){var c=Ir(i),h=Gs(i,c);if(h!==null){var y=pn();cs(h,i,c,y)}Pm(i,c)}},$x=function(){return Ye},Sx=function(i,c){var h=Ye;try{return Ye=i,c()}finally{Ye=h}},th=function(i,c,h){switch(c){case"input":if(Je(i,h),c=h.name,h.type==="radio"&&c!=null){for(h=i;h.parentNode;)h=h.parentNode;for(h=h.querySelectorAll("input[name="+JSON.stringify(""+c)+'][type="radio"]'),c=0;c<h.length;c++){var y=h[c];if(y!==i&&y.form===i.form){var $=Qu(y);if(!$)throw Error(t(90));ze(y),Je(y,$)}}}break;case"textarea":gn(i,h);break;case"select":c=h.value,c!=null&&cn(i,!!h.multiple,c,!1)}},ix=Em,lx=uo;var JI={usingClientEntryPoint:!1,Events:[hi,Jo,Qu,ox,ax,Em]},Ti={findFiberByHostInstance:to,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},eT={bundleType:Ti.bundleType,version:Ti.version,rendererPackageName:Ti.rendererPackageName,rendererConfig:Ti.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:N.ReactCurrentDispatcher,findHostInstanceByFiber:function(i){return i=px(i),i===null?null:i.stateNode},findFiberByHostInstance:Ti.findFiberByHostInstance||QI,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Fc=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Fc.isDisabled&&Fc.supportsFiber)try{Ou=Fc.inject(eT),bs=Fc}catch{}}return $n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=JI,$n.createPortal=function(i,c){var h=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!Vm(c))throw Error(t(200));return YI(i,c,null,h)},$n.createRoot=function(i,c){if(!Vm(i))throw Error(t(299));var h=!1,y="",$=Bv;return c!=null&&(c.unstable_strictMode===!0&&(h=!0),c.identifierPrefix!==void 0&&(y=c.identifierPrefix),c.onRecoverableError!==void 0&&($=c.onRecoverableError)),c=Fm(i,1,!1,null,null,h,!1,y,$),i[Ms]=c.current,di(i.nodeType===8?i.parentNode:i),new Lm(c)},$n.findDOMNode=function(i){if(i==null)return null;if(i.nodeType===1)return i;var c=i._reactInternals;if(c===void 0)throw typeof i.render=="function"?Error(t(188)):(i=Object.keys(i).join(","),Error(t(268,i)));return i=px(c),i=i===null?null:i.stateNode,i},$n.flushSync=function(i){return uo(i)},$n.hydrate=function(i,c,h){if(!Dc(c))throw Error(t(200));return Ac(null,i,c,!0,h)},$n.hydrateRoot=function(i,c,h){if(!Vm(i))throw Error(t(405));var y=h!=null&&h.hydratedSources||null,$=!1,S="",E=Bv;if(h!=null&&(h.unstable_strictMode===!0&&($=!0),h.identifierPrefix!==void 0&&(S=h.identifierPrefix),h.onRecoverableError!==void 0&&(E=h.onRecoverableError)),c=Lv(c,null,i,1,h??null,$,!1,S,E),i[Ms]=c.current,di(i),y)for(i=0;i<y.length;i++)h=y[i],$=h._getVersion,$=$(h._source),c.mutableSourceEagerHydrationData==null?c.mutableSourceEagerHydrationData=[h,$]:c.mutableSourceEagerHydrationData.push(h,$);return new Oc(c)},$n.render=function(i,c,h){if(!Dc(c))throw Error(t(200));return Ac(null,i,c,!1,h)},$n.unmountComponentAtNode=function(i){if(!Dc(i))throw Error(t(40));return i._reactRootContainer?(uo(function(){Ac(null,null,i,!1,function(){i._reactRootContainer=null,i[Ms]=null})}),!0):!1},$n.unstable_batchedUpdates=Em,$n.unstable_renderSubtreeIntoContainer=function(i,c,h,y){if(!Dc(h))throw Error(t(200));if(i==null||i._reactInternals===void 0)throw Error(t(38));return Ac(i,c,h,!1,y)},$n.version="18.3.1-next-f1338f8080-20240426",$n}var Kv;function cT(){if(Kv)return zm.exports;Kv=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),zm.exports=uT(),zm.exports}var Xv;function dT(){if(Xv)return Pc;Xv=1;var n=cT();return Pc.createRoot=n.createRoot,Pc.hydrateRoot=n.hydrateRoot,Pc}var pT=dT(),Oi={exports:{}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fT=1e-7,hT=1e-4;class Hg{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Nd{refCount(e){return Sn("refCount")}incRef(e){return Sn("incRef")}timerAvailable(){return!0}time(e){return Sn("time")}read(e){return Sn("read")}readSync(e){return Sn("readSync")}readToGPU(e,t){return Sn("readToGPU")}numDataIds(){return Sn("numDataIds")}disposeData(e,t){return Sn("disposeData")}write(e,t,s){return Sn("write")}move(e,t,s,r,o){return Sn("move")}createTensorFromGPUData(e,t,s){return Sn("createTensorFromGPUData")}memory(){return Sn("memory")}floatPrecision(){return Sn("floatPrecision")}epsilon(){return this.floatPrecision()===32?fT:hT}dispose(){return Sn("dispose")}}function Sn(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cb(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Qs(n,e,t)}function mT(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,s=0;for(;t>0;)s=Math.random()*t|0,t--,Qs(n,t,s),Qs(e,t,s)}function Lr(n,e,t){return Math.max(n,Math.min(e,t))}function Id(n){return n%2===0?n:n+1}function Qs(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function db(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function gT(n,e){const t=Math.random();return e*t+(1-t)*n}function yT(n,e){let t=0;for(let s=0;s<n.length;s++){const r=Number(n[s])-Number(e[s]);t+=r*r}return t}function O(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function zt(n,e,t=""){O(Qe(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function Lo(n){O(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function oe(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function xT(n){return n.length===0}function pb(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function Qe(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function No(n){return n%1===0}function vT(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function od(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function wT(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return cb(e),e}function So(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function ag(n,e=r=>0,t,s){return new Promise((r,o)=>{let a=0;const l=()=>{if(n()){r();return}a++;const u=e(a);if(t!=null&&a>=t){o();return}s!=null?s(l,u):setTimeout(l,u)};l()})}function jg(n,e){let t=1,s=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)t*=n[o];else if(n[o]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${o}`);s=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function Me(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),O(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),O(n.every(s=>No(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function or(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||r?null:Me(e,n).sort();let a=0;for(let l=0;l<n.length;++l){if(o!=null){if(o[a]===l&&n[l]!==1)throw new Error(`Can't squeeze axis ${l} since its dim '${n[l]}' is not 1`);(o[a]==null||o[a]>l)&&n[l]===1&&(t.push(n[l]),s.push(l)),o[a]<=l&&a++}n[l]!==1&&(t.push(n[l]),s.push(l))}return{newShape:t,keptDims:s}}function Dt(n,e){return xt(n,e)}function xt(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function fb(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function hb(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function qg(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function Vi(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function mb(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Is(n){return typeof n=="string"||n instanceof String}function gb(n){return typeof n=="boolean"}function yb(n){return typeof n=="number"}function Vo(n){return Array.isArray(n)?Vo(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":yb(n)?"float32":Is(n)?"string":gb(n)?"bool":"float32"}function Vr(n){return!!(n&&n.constructor&&n.call&&n.apply)}function ad(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Ie(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function xb(n,e,t,s=!1){const r=new Array;if(e.length===1){const o=e[0]*(s?2:1);for(let a=0;a<o;a++)r[a]=t[n+a]}else{const o=e[0],a=e.slice(1),l=a.reduce((u,d)=>u*d)*(s?2:1);for(let u=0;u<o;u++)r[u]=xb(n+u*l,a,t,s)}return r}function zn(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,o)=>r*o)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return xb(0,n,e,t)}function vb(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function Td(n,e){const t=Mt(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function Mt(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function Kg(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return zn(n,new Float32Array(t));if(e==="int32")return zn(n,new Int32Array(t));if(e==="bool")return zn(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function _n(n){n.forEach(e=>{O(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function ms(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function Bo(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function Br(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yv="tfjsflags";class wb{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=bT,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(J().getBool("IS_TEST")||J().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];J().getBool("IS_TEST")||J().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Br(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);Yv in e&&e[Yv].split(",").forEach(s=>{const[r,o]=s.split(":");this.urlFlags[r]=ST(r,o)})}}function bT(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>($T(e,s[0],s[1]),s.join("="))),e}function $T(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function ST(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function J(){return Xg}let Xg=null;function CT(n){Xg=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Gm;function bb(){if(Gm==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Gm=n}return Gm}function kT(){const n=bb();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function Yg(n,e){const t=kT();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const Ed="Abs",rl="Acos",ol="Acosh",Fa="Add",Rd="AddN",_d="All",Od="Any",Dd="ArgMax",Ad="ArgMin",al="Asin",il="Asinh",ll="Atan",ul="Atanh",cl="Atan2",Fd="AvgPool",Qg="AvgPoolGrad",Pd="AvgPool3D",Zg="AvgPool3DGrad",Ld="BatchMatMul",Vd="BatchToSpaceND",Bd="Bincount",dl="BitwiseAnd",NT="BroadcastTo",Md="BroadcastArgs",pl="Cast",fl="Ceil",hl="ClipByValue",zd="Complex",Wd="ComplexAbs",Ud="Concat",Gd="Conv2D",Hd="Conv2DBackpropFilter",jd="Conv2DBackpropInput",qd="Conv3D",Jg="Conv3DBackpropFilterV2",Kd="Conv3DBackpropInputV2",ml="Cos",gl="Cosh",Xd="Cumprod",Yd="Cumsum",Qd="CropAndResize",Zd="DenseBincount",Jd="DepthToSpace",ep="DepthwiseConv2dNative",tp="DepthwiseConv2dNativeBackpropFilter",np="DepthwiseConv2dNativeBackpropInput",sp="Diag",rp="Dilation2D",ig="Dilation2DBackpropInput",lg="Dilation2DBackpropFilter",op="Draw",yl="RealDiv",ap="Einsum",xl="Elu",ey="EluGrad",vl="Erf",wl="Equal",bl="Exp",ip="ExpandDims",$l="Expm1",lp="FFT",up="Fill",cp="FlipLeftRight",Sl="Floor",Cl="FloorDiv",dp="FusedBatchNorm",pp="GatherV2",fp="GatherNd",kl="Greater",Nl="GreaterEqual",Il="Identity",hp="IFFT",mp="Imag",Tl="IsFinite",El="IsInf",Rl="IsNan",gp="LeakyRelu",_l="Less",Ol="LessEqual",yp="LinSpace",Dl="Log",Al="Log1p",Fl="LogicalAnd",Pl="LogicalNot",Ll="LogicalOr",IT="LogicalXor",TT="LogSoftmax",ET="LowerBound",xp="LRN",ty="LRNGrad",RT="MatrixBandPart",vp="Max",Vl="Maximum",wp="MaxPool",ny="MaxPoolGrad",bp="MaxPool3D",sy="MaxPool3DGrad",$p="MaxPoolWithArgmax",Sp="Mean",Cp="Min",Bl="Minimum",kp="MirrorPad",Ml="Mod",Np="Multinomial",zl="Multiply",Ip="Neg",Wl="NotEqual",Tp="NonMaxSuppressionV3",Ep="NonMaxSuppressionV4",Rp="NonMaxSuppressionV5",_p="OnesLike",Op="OneHot",Dp="Pack",Ap="PadV2",_T="Pool",Ul="Pow",Fp="Prelu",Pp="Prod",Lp="RaggedGather",Vp="RaggedRange",Bp="RaggedTensorToTensor",Mp="Range",zp="Real",Gl="Reciprocal",Hl="Relu",Wp="Reshape",Up="ResizeNearestNeighbor",ry="ResizeNearestNeighborGrad",Gp="ResizeBilinear",oy="ResizeBilinearGrad",jl="Relu6",Hp="Reverse",ql="Round",Kl="Rsqrt",jp="ScatterNd",qp="TensorScatterUpdate",Kp="SearchSorted",Xp="Select",Xl="Selu",Yp="Slice",Yl="Sin",Ql="Sinh",Zl="Sign",Jl="Sigmoid",eu="Softplus",tu="Sqrt",Qp="Sum",Zp="SpaceToBatchND",Jp="SplitV",ef="Softmax",tf="SparseFillEmptyRows",nf="SparseReshape",sf="SparseSegmentMean",rf="SparseSegmentSum",of="SparseToDense",nu="SquaredDifference",ay="Square",su="StaticRegexReplace",af="StridedSlice",lf="StringNGrams",uf="StringSplit",cf="StringToHashBucketFast",ru="Sub",ou="Tan",au="Tanh",iu="Tile",df="TopK",pf="Transform",ya="Transpose",ff="Unique",hf="Unpack",mf="UnsortedSegmentSum",OT="UpperBound",gf="ZerosLike",lu="Step",id="FromPixels",yf="RotateWithOffset",Bi="_FusedMatMul",Mi="FusedConv2D",zi="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vn(...n){J().getBool("IS_TEST")||J().getBool("PROD")||console.warn(...n)}function DT(...n){J().getBool("IS_TEST")||J().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sa=Yg("kernelRegistry",()=>new Map),Wi=Yg("gradRegistry",()=>new Map);function Ui(n,e){const t=iy(n,e);return Sa.get(t)}function ug(n){return Wi.get(n)}function ld(n){const e=Sa.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[o,a]=r,[l]=o.split("_");l===n&&t.push(a)}return t}function xf(n){const{kernelName:e,backendName:t}=n,s=iy(e,t);Sa.has(s)&&Vn(`The kernel '${e}' for backend '${t}' is already registered`),Sa.set(s,n)}function AT(n){const{kernelName:e}=n;Wi.has(e)&&J().getBool("DEBUG")&&Vn(`Overriding the gradient for '${e}'`),Wi.set(e,n)}function FT(n,e){const t=iy(n,e);if(!Sa.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);Sa.delete(t)}function PT(n){if(!Wi.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);Wi.delete(n)}function LT(n,e){ld(n).forEach(s=>{const r=Object.assign({},s,{backendName:e});xf(r)})}function iy(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $b(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Hm,Qv;function VT(){if(Qv)return Hm;Qv=1,Hm=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(A,T,W){this.low=A|0,this.high=T|0,this.unsigned=!!W}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(A){return(A&&A.__isLong__)===!0}e.isLong=t;var s={},r={};function o(A,T){var W,j,Y;return T?(A>>>=0,(Y=0<=A&&A<256)&&(j=r[A],j)?j:(W=l(A,(A|0)<0?-1:0,!0),Y&&(r[A]=W),W)):(A|=0,(Y=-128<=A&&A<128)&&(j=s[A],j)?j:(W=l(A,A<0?-1:0,!1),Y&&(s[A]=W),W))}e.fromInt=o;function a(A,T){if(isNaN(A))return T?C:b;if(T){if(A<0)return C;if(A>=x)return F}else{if(A<=-w)return V;if(A+1>=w)return D}return A<0?a(-A,T).neg():l(A%g|0,A/g|0,T)}e.fromNumber=a;function l(A,T,W){return new e(A,T,W)}e.fromBits=l;var u=Math.pow;function d(A,T,W){if(A.length===0)throw Error("empty string");if(A==="NaN"||A==="Infinity"||A==="+Infinity"||A==="-Infinity")return b;if(typeof T=="number"?(W=T,T=!1):T=!!T,W=W||10,W<2||36<W)throw RangeError("radix");var j;if((j=A.indexOf("-"))>0)throw Error("interior hyphen");if(j===0)return d(A.substring(1),T,W).neg();for(var Y=a(u(W,8)),Q=b,Z=0;Z<A.length;Z+=8){var ne=Math.min(8,A.length-Z),U=parseInt(A.substring(Z,Z+ne),W);if(ne<8){var K=a(u(W,ne));Q=Q.mul(K).add(a(U))}else Q=Q.mul(Y),Q=Q.add(a(U))}return Q.unsigned=T,Q}e.fromString=d;function p(A,T){return typeof A=="number"?a(A,T):typeof A=="string"?d(A,T):l(A.low,A.high,typeof T=="boolean"?T:A.unsigned)}e.fromValue=p;var f=65536,m=1<<24,g=f*f,x=g*g,w=x/2,v=o(m),b=o(0);e.ZERO=b;var C=o(0,!0);e.UZERO=C;var I=o(1);e.ONE=I;var N=o(1,!0);e.UONE=N;var R=o(-1);e.NEG_ONE=R;var D=l(-1,2147483647,!1);e.MAX_VALUE=D;var F=l(-1,-1,!0);e.MAX_UNSIGNED_VALUE=F;var V=l(0,-2147483648,!1);e.MIN_VALUE=V;var P=e.prototype;return P.toInt=function(){return this.unsigned?this.low>>>0:this.low},P.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},P.toString=function(T){if(T=T||10,T<2||36<T)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(V)){var W=a(T),j=this.div(W),Y=j.mul(W).sub(this);return j.toString(T)+Y.toInt().toString(T)}else return"-"+this.neg().toString(T);for(var Q=a(u(T,6),this.unsigned),Z=this,ne="";;){var U=Z.div(Q),K=Z.sub(U.mul(Q)).toInt()>>>0,X=K.toString(T);if(Z=U,Z.isZero())return X+ne;for(;X.length<6;)X="0"+X;ne=""+X+ne}},P.getHighBits=function(){return this.high},P.getHighBitsUnsigned=function(){return this.high>>>0},P.getLowBits=function(){return this.low},P.getLowBitsUnsigned=function(){return this.low>>>0},P.getNumBitsAbs=function(){if(this.isNegative())return this.eq(V)?64:this.neg().getNumBitsAbs();for(var T=this.high!=0?this.high:this.low,W=31;W>0&&!(T&1<<W);W--);return this.high!=0?W+33:W+1},P.isZero=function(){return this.high===0&&this.low===0},P.eqz=P.isZero,P.isNegative=function(){return!this.unsigned&&this.high<0},P.isPositive=function(){return this.unsigned||this.high>=0},P.isOdd=function(){return(this.low&1)===1},P.isEven=function(){return(this.low&1)===0},P.equals=function(T){return t(T)||(T=p(T)),this.unsigned!==T.unsigned&&this.high>>>31===1&&T.high>>>31===1?!1:this.high===T.high&&this.low===T.low},P.eq=P.equals,P.notEquals=function(T){return!this.eq(T)},P.neq=P.notEquals,P.ne=P.notEquals,P.lessThan=function(T){return this.comp(T)<0},P.lt=P.lessThan,P.lessThanOrEqual=function(T){return this.comp(T)<=0},P.lte=P.lessThanOrEqual,P.le=P.lessThanOrEqual,P.greaterThan=function(T){return this.comp(T)>0},P.gt=P.greaterThan,P.greaterThanOrEqual=function(T){return this.comp(T)>=0},P.gte=P.greaterThanOrEqual,P.ge=P.greaterThanOrEqual,P.compare=function(T){if(t(T)||(T=p(T)),this.eq(T))return 0;var W=this.isNegative(),j=T.isNegative();return W&&!j?-1:!W&&j?1:this.unsigned?T.high>>>0>this.high>>>0||T.high===this.high&&T.low>>>0>this.low>>>0?-1:1:this.sub(T).isNegative()?-1:1},P.comp=P.compare,P.negate=function(){return!this.unsigned&&this.eq(V)?V:this.not().add(I)},P.neg=P.negate,P.add=function(T){t(T)||(T=p(T));var W=this.high>>>16,j=this.high&65535,Y=this.low>>>16,Q=this.low&65535,Z=T.high>>>16,ne=T.high&65535,U=T.low>>>16,K=T.low&65535,X=0,L=0,H=0,re=0;return re+=Q+K,H+=re>>>16,re&=65535,H+=Y+U,L+=H>>>16,H&=65535,L+=j+ne,X+=L>>>16,L&=65535,X+=W+Z,X&=65535,l(H<<16|re,X<<16|L,this.unsigned)},P.subtract=function(T){return t(T)||(T=p(T)),this.add(T.neg())},P.sub=P.subtract,P.multiply=function(T){if(this.isZero())return b;if(t(T)||(T=p(T)),n){var W=n.mul(this.low,this.high,T.low,T.high);return l(W,n.get_high(),this.unsigned)}if(T.isZero())return b;if(this.eq(V))return T.isOdd()?V:b;if(T.eq(V))return this.isOdd()?V:b;if(this.isNegative())return T.isNegative()?this.neg().mul(T.neg()):this.neg().mul(T).neg();if(T.isNegative())return this.mul(T.neg()).neg();if(this.lt(v)&&T.lt(v))return a(this.toNumber()*T.toNumber(),this.unsigned);var j=this.high>>>16,Y=this.high&65535,Q=this.low>>>16,Z=this.low&65535,ne=T.high>>>16,U=T.high&65535,K=T.low>>>16,X=T.low&65535,L=0,H=0,re=0,ae=0;return ae+=Z*X,re+=ae>>>16,ae&=65535,re+=Q*X,H+=re>>>16,re&=65535,re+=Z*K,H+=re>>>16,re&=65535,H+=Y*X,L+=H>>>16,H&=65535,H+=Q*K,L+=H>>>16,H&=65535,H+=Z*U,L+=H>>>16,H&=65535,L+=j*X+Y*K+Q*U+Z*ne,L&=65535,l(re<<16|ae,L<<16|H,this.unsigned)},P.mul=P.multiply,P.divide=function(T){if(t(T)||(T=p(T)),T.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&T.low===-1&&T.high===-1)return this;var W=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,T.low,T.high);return l(W,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?C:b;var j,Y,Q;if(this.unsigned){if(T.unsigned||(T=T.toUnsigned()),T.gt(this))return C;if(T.gt(this.shru(1)))return N;Q=C}else{if(this.eq(V)){if(T.eq(I)||T.eq(R))return V;if(T.eq(V))return I;var Z=this.shr(1);return j=Z.div(T).shl(1),j.eq(b)?T.isNegative()?I:R:(Y=this.sub(T.mul(j)),Q=j.add(Y.div(T)),Q)}else if(T.eq(V))return this.unsigned?C:b;if(this.isNegative())return T.isNegative()?this.neg().div(T.neg()):this.neg().div(T).neg();if(T.isNegative())return this.div(T.neg()).neg();Q=b}for(Y=this;Y.gte(T);){j=Math.max(1,Math.floor(Y.toNumber()/T.toNumber()));for(var ne=Math.ceil(Math.log(j)/Math.LN2),U=ne<=48?1:u(2,ne-48),K=a(j),X=K.mul(T);X.isNegative()||X.gt(Y);)j-=U,K=a(j,this.unsigned),X=K.mul(T);K.isZero()&&(K=I),Q=Q.add(K),Y=Y.sub(X)}return Q},P.div=P.divide,P.modulo=function(T){if(t(T)||(T=p(T)),n){var W=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,T.low,T.high);return l(W,n.get_high(),this.unsigned)}return this.sub(this.div(T).mul(T))},P.mod=P.modulo,P.rem=P.modulo,P.not=function(){return l(~this.low,~this.high,this.unsigned)},P.and=function(T){return t(T)||(T=p(T)),l(this.low&T.low,this.high&T.high,this.unsigned)},P.or=function(T){return t(T)||(T=p(T)),l(this.low|T.low,this.high|T.high,this.unsigned)},P.xor=function(T){return t(T)||(T=p(T)),l(this.low^T.low,this.high^T.high,this.unsigned)},P.shiftLeft=function(T){return t(T)&&(T=T.toInt()),(T&=63)===0?this:T<32?l(this.low<<T,this.high<<T|this.low>>>32-T,this.unsigned):l(0,this.low<<T-32,this.unsigned)},P.shl=P.shiftLeft,P.shiftRight=function(T){return t(T)&&(T=T.toInt()),(T&=63)===0?this:T<32?l(this.low>>>T|this.high<<32-T,this.high>>T,this.unsigned):l(this.high>>T-32,this.high>=0?0:-1,this.unsigned)},P.shr=P.shiftRight,P.shiftRightUnsigned=function(T){if(t(T)&&(T=T.toInt()),T&=63,T===0)return this;var W=this.high;if(T<32){var j=this.low;return l(j>>>T|W<<32-T,W>>>T,this.unsigned)}else return T===32?l(W,0,this.unsigned):l(W>>>T-32,0,this.unsigned)},P.shru=P.shiftRightUnsigned,P.shr_u=P.shiftRightUnsigned,P.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},P.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},P.toBytes=function(T){return T?this.toBytesLE():this.toBytesBE()},P.toBytesLE=function(){var T=this.high,W=this.low;return[W&255,W>>>8&255,W>>>16&255,W>>>24,T&255,T>>>8&255,T>>>16&255,T>>>24]},P.toBytesBE=function(){var T=this.high,W=this.low;return[T>>>24,T>>>16&255,T>>>8&255,T&255,W>>>24,W>>>16&255,W>>>8&255,W&255]},e.fromBytes=function(T,W,j){return j?e.fromBytesLE(T,W):e.fromBytesBE(T,W)},e.fromBytesLE=function(T,W){return new e(T[0]|T[1]<<8|T[2]<<16|T[3]<<24,T[4]|T[5]<<8|T[6]<<16|T[7]<<24,W)},e.fromBytesBE=function(T,W){return new e(T[4]<<24|T[5]<<16|T[6]<<8|T[7],T[0]<<24|T[1]<<16|T[2]<<8|T[3],W)},Hm}var Sb=VT();const Cb=sT(Sb),BT=nT({__proto__:null,default:Cb},[Sb]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yo=Cb||BT;function uu(n){return yo.fromString(n,!0,16)}const kb=uu("c3a5c85c97cb3127"),go=uu("b492b66fbe98f273"),sn=uu("9ae16a3b2f90404f");function cg(n){return n.xor(n.shru(47))}function Nb(n,e,t){const s=n.slice(e,e+t);return yo.fromBytes(Array.from(s),!0,!0)}function st(n,e){return Nb(n,e,8)}function Zv(n,e){return Nb(n,e,4)}function _t(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Pr(n,e,t=uu("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function MT(n,e,t,s,r,o){r=r.add(n),o=_t(o.add(r).add(s),21);const a=r;return r=r.add(e),r=r.add(t),o=o.add(_t(r,44)),[r.add(s),o.add(a)]}function Lc(n,e,t,s){return MT(st(n,e),st(n,e+8),st(n,e+16),st(n,e+24),t,s)}function zT(n,e=n.length){if(e>=8){const t=sn.add(e*2),s=st(n,0).add(sn),r=st(n,e-8),o=_t(r,37).mul(t).add(s),a=_t(s,25).add(r).mul(t);return Pr(o,a,t)}if(e>=4){const t=sn.add(e*2),s=Zv(n,0);return Pr(s.shl(3).add(e),Zv(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],o=t+(s<<8),a=e+(r<<2);return cg(sn.mul(o).xor(kb.mul(a))).mul(sn)}return sn}function WT(n,e=n.length){const t=sn.add(e*2),s=st(n,0).mul(go),r=st(n,8),o=st(n,e-8).mul(t),a=st(n,e-16).mul(sn);return Pr(_t(s.add(r),43).add(_t(o,30)).add(a),s.add(_t(r.add(sn),18)).add(o),t)}function UT(n,e=n.length){const t=sn.add(e*2),s=st(n,0).mul(sn),r=st(n,8),o=st(n,e-8).mul(t),a=st(n,e-16).mul(sn),l=_t(s.add(r),43).add(_t(o,30)).add(a),u=Pr(l,s.add(_t(r.add(sn),18)).add(o),t),d=st(n,16).mul(t),p=st(n,24),f=l.add(st(n,e-32)).mul(t),m=u.add(st(n,e-24)).mul(t);return Pr(_t(d.add(p),43).add(_t(f,30)).add(m),d.add(_t(p.add(s),18)).add(f),t)}function Ib(n,e=n.length){const t=yo.fromNumber(81,!0);if(e<=32)return e<=16?zT(n,e):WT(n,e);if(e<=64)return UT(n,e);let s=t,r=t.mul(go).add(113),o=cg(r.mul(sn).add(113)).mul(sn),a=[yo.UZERO,yo.UZERO],l=[yo.UZERO,yo.UZERO];s=s.mul(sn).add(st(n,0));let u=0;const d=(e-1>>6)*64,p=d+(e-1&63)-63;do s=_t(s.add(r).add(a[0]).add(st(n,u+8)),37).mul(go),r=_t(r.add(a[1]).add(st(n,u+48)),42).mul(go),s=s.xor(l[1]),r=r.add(a[0]).add(st(n,u+40)),o=_t(o.add(l[0]),33).mul(go),a=Lc(n,u,a[1].mul(go),s.add(l[0])),l=Lc(n,u+32,o.add(l[1]),r.add(st(n,u+16))),[o,s]=[s,o],u+=64;while(u!==d);const f=go.add(o.and(255).shl(1));return u=p,l[0]=l[0].add(e-1&63),a[0]=a[0].add(l[0]),l[0]=l[0].add(a[0]),s=_t(s.add(r).add(a[0]).add(st(n,u+8)),37).mul(f),r=_t(r.add(a[1]).add(st(n,u+48)),42).mul(f),s=s.xor(l[1].mul(9)),r=r.add(a[0].mul(9).add(st(n,u+40))),o=_t(o.add(l[0]),33).mul(f),a=Lc(n,u,a[1].mul(f),s.add(l[0])),l=Lc(n,u+32,o.add(l[1]),r.add(st(n,u+16))),[o,s]=[s,o],Pr(Pr(a[0],l[0],f).add(cg(r).mul(kb)).add(o),Pr(a[1],l[1],f).add(s),f)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ar(n,e){return e==="string"?Es(n):Hr([n],e)}function GT(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Hr(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=_s(n)),J().getBool("DEBUG")&&fb(n,e),GT(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function In(){return J().platform.now()}function HT(n,e){return J().platform.fetch(n,e)}function Es(n,e="utf-8"){return e=e||"utf-8",J().platform.encode(n,e)}function tr(n,e="utf-8"){return e=e||"utf-8",J().platform.decode(n,e)}function Ot(n){return J().platform.isTypedArray!=null?J().platform.isTypedArray(n):$b(n)}function _s(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Br(n)||n==null||Ot(n)&&t)e.push(n);else if(Array.isArray(n)||Ot(n))for(let s=0;s<n.length;++s)_s(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)_s(n[r],e,t)}return e}const jT=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:Qe,arraysEqualWithNull:pb,assert:O,assertNonNegativeIntegerDimensions:_n,assertNonNull:Lo,assertShapesMatch:zt,bytesFromStringArray:mb,bytesPerElement:Vi,checkConversionForErrors:fb,clamp:Lr,computeStrides:Ie,convertBackendValuesAndArrayBuffer:vb,createScalarValue:ar,createShuffledIndices:wT,decodeString:tr,distSquared:yT,encodeString:Es,fetch:HT,fingerPrint64:Ib,flatten:_s,getArrayFromDType:xt,getTypedArrayFromDType:Dt,hasEncodingLoss:qg,hexToLong:uu,indexToLoc:Bo,inferDtype:Vo,inferFromImplicitShape:jg,isBoolean:gb,isFunction:Vr,isInt:No,isNumber:yb,isPromise:Br,isScalarShape:xT,isString:Is,isTypedArray:Ot,isValidDtype:hb,locToIndex:ms,makeOnesTypedArray:Td,makeZerosNestedTypedArray:Kg,makeZerosTypedArray:Mt,nearestDivisor:ad,nearestLargerEven:Id,now:In,parseAxisParam:Me,randUniform:gT,repeatedTry:ag,rightPad:So,shuffle:cb,shuffleCombo:mT,sizeFromShape:oe,sizeToSquarishShape:od,squeezeShape:or,sum:db,swap:Qs,tanh:vT,toNestedArray:zn,toTypedArray:Hr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qT{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new XT)}profileKernel(e,t,s){let r;const o=()=>{r=s()};let a;const l=In();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(o);else{o();for(const d of r)d.dataSync();a=Promise.resolve({kernelMs:In()-l})}if(J().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let d=0;d<r.length;d++){const p=r[d];p.data().then(f=>{KT(f,p.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(d=>d.kernelMs),extraInfo:a.then(d=>d.getExtraProfileInfo!=null?d.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:o,extraInfo:a}=e;s.forEach(l=>{Promise.all([l.data(),r,a]).then(u=>{this.logger.logKernelProfile(t,l,u[0],u[1],o,u[2])})})}}function KT(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class XT{logKernelProfile(e,t,s,r,o,a){const l=typeof r=="number"?So(`${r}ms`,9):r.error,u=So(e,25),d=t.rank,p=t.size,f=So(t.shape.toString(),14);let m="";for(const g in o){const x=o[g];if(x!=null){const w=x.shape||t.shape,v=w.length;m+=`${g}: ${v}D ${v>0?w:""} `}}console.log(`%c${u}	%c${l}	%c${d}D ${f}	%c${p}	%c${m}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YT(n,e,t){const s={},r={};for(let u=0;u<e.length;u++)s[e[u].id]=!0;for(let u=0;u<n.length;u++){const d=n[u],p=d.inputs;for(const f in p){const m=p[f];let g=!1;for(let x=0;x<e.length;x++)if(s[m.id]){d.outputs.forEach(w=>s[w.id]=!0),g=!0,r[d.id]=!0;break}if(g)break}}const o={};o[t.id]=!0;const a={};for(let u=n.length-1;u>=0;u--){const d=n[u],p=d.inputs;for(let f=0;f<d.outputs.length;f++)if(o[d.outputs[f].id]){for(const m in p)o[p[m].id]=!0,a[d.id]=!0;break}}const l=[];for(let u=0;u<n.length;u++){const d=n[u];if(r[d.id]&&a[d.id]){const p={};for(const m in d.inputs){const g=d.inputs[m];s[g.id]&&(p[m]=g)}const f=Object.assign({},d);f.inputs=p,f.outputs=d.outputs,l.push(f)}}return l}function QT(n,e,t,s){for(let r=e.length-1;r>=0;r--){const o=e[r],a=[];if(o.outputs.forEach(u=>{const d=n[u.id];d!=null?a.push(d):a.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const l=o.gradient(a);for(const u in o.inputs){if(!(u in l))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(l)}.`);const d=t(()=>l[u]());if(d.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${d.dtype}'`);const p=o.inputs[u];if(!Qe(d.shape,p.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${u}' has shape '${d.shape}', which does not match the shape of the input '${p.shape}'`);if(n[p.id]==null)n[p.id]=d;else{const f=n[p.id];n[p.id]=s(f,d),f.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jv=20,Ri=3,jm=7;function ZT(n,e,t,s){const r=Ie(e),o=JT(n,e,t,r),a=e.length,l=Kc(n,e,t,r,o),u=["Tensor"];return s&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${a}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(l.map(d=>"    "+d).join(`
`)),u.join(`
`)}function JT(n,e,t,s){const r=oe(e),o=s[s.length-1],a=new Array(o).fill(0),l=e.length,u=t==="complex64"?Ai(n):n;if(l>1)for(let d=0;d<r/o;d++){const p=d*o;for(let f=0;f<o;f++)a[f]=Math.max(a[f],Di(u[p+f],0,t).length)}return a}function Di(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(jm))} + ${parseFloat(n[1].toFixed(jm))}j`:Is(n)?s=`'${n}'`:t==="bool"?s=Tb(n):s=parseFloat(n.toFixed(jm)).toString(),So(s,e)}function Tb(n){return n===0?"false":"true"}function Kc(n,e,t,s,r,o=!0){const a=t==="complex64"?2:1,l=e[0],u=e.length;if(u===0){if(t==="complex64"){const w=Ai(n);return[Di(w[0],0,t)]}return t==="bool"?[Tb(n[0])]:[n[0].toString()]}if(u===1){if(l>Jv){const v=Ri*a;let b=Array.from(n.slice(0,v)),C=Array.from(n.slice((l-Ri)*a,l*a));return t==="complex64"&&(b=Ai(b),C=Ai(C)),["["+b.map((I,N)=>Di(I,r[N],t)).join(", ")+", ..., "+C.map((I,N)=>Di(I,r[l-Ri+N],t)).join(", ")+"]"]}return["["+(t==="complex64"?Ai(n):Array.from(n)).map((v,b)=>Di(v,r[b],t)).join(", ")+"]"]}const d=e.slice(1),p=s.slice(1),f=s[0]*a,m=[];if(l>Jv){for(let w=0;w<Ri;w++){const v=w*f,b=v+f;m.push(...Kc(n.slice(v,b),d,t,p,r,!1))}m.push("...");for(let w=l-Ri;w<l;w++){const v=w*f,b=v+f;m.push(...Kc(n.slice(v,b),d,t,p,r,w===l-1))}}else for(let w=0;w<l;w++){const v=w*f,b=v+f;m.push(...Kc(n.slice(v,b),d,t,p,r,w===l-1))}const g=u===2?",":"";m[0]="["+(l>0?m[0]+g:"");for(let w=1;w<m.length-1;w++)m[w]=" "+m[w]+g;let x=`,
`;for(let w=2;w<u;w++)x+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(o?"":x),m}function Ai(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kt{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=oe(e),s!=null){const r=s.length;O(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||xt(t,this.size),this.strides=Ie(e)}set(e,...t){t.length===0&&(t=[0]),O(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ps().makeTensor(this.values,this.shape,this.dtype)}}let ps=null,ma=null;function eE(n){ps=n}function tE(n){ma=n}class yt{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=oe(e),this.strides=Ie(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return ma.buffer(this.shape,this.dtype,e)}bufferSync(){return ma.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return zn(this.shape,e,this.dtype==="complex64")}arraySync(){return zn(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=ps().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>tr(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ps().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=ps().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>tr(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await ps().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),ps().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return ma.print(this,e)}clone(){return this.throwIfDisposed(),ma.clone(this)}toString(e=!1){const t=this.dataSync();return ZT(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),ma.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),ps().makeVariable(this,e,t,s)}}Object.defineProperty(yt,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Eb(){return Yg("Tensor",()=>yt)}Eb();class Gi extends yt{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Qe(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ps().disposeTensor(this),this.dataId=e.dataId,ps().incRef(this,null)}dispose(){ps().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Gi,Symbol.hasInstance,{value:n=>n instanceof yt&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var dg;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(dg||(dg={}));var pg;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(pg||(pg={}));var fg;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(fg||(fg={}));var hg;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(hg||(hg={}));var mg;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(mg||(mg={}));const nE={float32:hg,int32:pg,bool:fg,complex64:mg};function fn(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return nE[n][e]}function vf(n){return fn(n,"int32")}function Rb(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function _b(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ht(n,e){if(n.dtype===e.dtype)return[n,e];const t=fn(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function Ob(n,e){O(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function sE(n,e){return e.some(t=>t.id===n.id)}function ly(n){const e=[];return Db(n,e,new Set),e}function Db(n,e,t){if(n==null)return;if(n instanceof yt){e.push(n);return}if(!rE(n))return;const s=n;for(const r in s){const o=s[r];t.has(o)||(t.add(o),Db(o,e,t))}}function rE(n){return Array.isArray(n)||typeof n=="object"}const oE=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:Ob,getTensorsInContainer:ly,isTensorInList:sE,makeTypesMatch:ht},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qm(n){return n.kernelName!=null}class ew{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Ca{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ew}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(Vn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new qT(this.backendInstance),!0}setupRegisteredKernels(){ld(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){ld(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof Nd)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,o=s.then(a=>r<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Vn(`Initialization of backend ${e} failed`),Vn(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return Vn(`Initialization of backend ${e} failed`),Vn(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:o}=this.initializeBackend(s);if(o||r)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,o=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,o,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return Ca.nextTensorId++}nextVariableId(){return Ca.nextVariableId++}clone(e){const t=z.runKernel(Il,{x:e}),s={x:e},r=a=>({x:()=>{const l="float32",u={x:a},d={dtype:l};return z.runKernel(pl,u,d)}}),o=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,o,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(Ui(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let o=0;s.forEach(u=>{o+=u.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=r-t-o-a;if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let l;this.backendName==null&&this.backend;let u;const d=qm(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(qm(e)){const{kernelName:x,inputs:w,attrs:v}=e;this.backendName==null&&this.backend;const b=Ui(x,this.backendName);O(b!=null,()=>`Cannot find registered kernel '${x}' for backend '${this.backendName}'`),l=()=>{const C=this.backend.numDataIds();u=b.kernelFunc({inputs:w,attrs:v,backend:this.backend});const I=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(x,C,I);const N=I.map(R=>R.rank!=null?R:this.makeTensorFromTensorInfo(R));if(r){const R=this.getTensorsForGradient(x,w,N);s=this.saveTensorsForBackwardMode(R)}return N}}else{const{forwardFunc:x}=e,w=v=>{r&&(s=v.map(b=>this.keep(this.clone(b))))};l=()=>{const v=this.backend.numDataIds();u=this.tidy(()=>x(this.backend,w));const b=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,v,b),b}}const{inputs:p,attrs:f}=e,m=qm(e)?null:e.backwardsFunc;let g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=l():(g=this.profiler.profileKernel(d,p,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),t=g.outputs)}),r&&this.addTapeNode(d,p,t,m,s,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:d,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(x=>p[x]!=null?p[x].shape:null),outputShapes:t.map(x=>x.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=ug(e);if(r!=null){const o=r.inputsToSave||[],a=r.outputsToSave||[];let l;r.saveAllInputs?(O(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(t).map(d=>t[d])):l=o.map(d=>t[d]);const u=s.filter((d,p)=>a[p]);return l.concat(u)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let o=e;s==="string"&&Is(e[0])&&(o=e.map(u=>Es(u)));const a=r.write(o,t,s),l=new yt(t,s,a,this.nextTensorId());if(this.trackTensor(l,r),s==="string"){const u=this.state.tensorInfo.get(a),d=mb(o);this.state.numBytes+=d-u.bytes,u.bytes=d}return l}makeTensorFromDataId(e,t,s,r){s=s||"float32";const o={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(o,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:o}=e,a=new yt(r,o,s,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const o=new Gi(e,t,s,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Vi(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Gi||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Vi(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,o,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:o},u=ug(e);u!=null&&(r=u.gradFunc),r!=null&&(l.gradient=d=>(d=d.map((p,f)=>{if(p==null){const m=s[f],g=Mt(m.size,m.dtype);return this.makeTensor(g,m.shape,m.dtype)}return p}),r(d.length>1?d:d[0],o,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=ly(e),s=new Set(t.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!s.has(a.id)&&a.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(o=>{!o.kept&&o.scopeId===r.id&&this.track(o)})}gradients(e,t,s,r=!1){if(O(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));O(o instanceof yt,()=>"The result y returned by f() must be a tensor.");const a=YT(this.state.activeTape,t,o);if(!r&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[o.id]=s??aE(o.shape),QT(l,a,d=>this.tidy(d),iE);const u=t.map(d=>l[d.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(d=>{for(const p of d.saved)p.dispose()}),this.state.activeTape=null),{value:o,grads:u}})}customGrad(e){return O(Vr(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{O(t.every(l=>l instanceof yt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((l,u)=>{r[u]=l});const o=(l,u)=>(s=e(...t,u),O(s.value instanceof yt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),O(Vr(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(l,u)=>{const d=s.gradFunc(l,u),p=Array.isArray(d)?d:[d];O(p.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),O(p.every(m=>m instanceof yt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};return p.forEach((m,g)=>{f[g]=()=>m}),f};return this.runKernelFunc({forwardFunc:o,backwardsFunc:a,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=In(),s=await this.backend.time(e);return s.wallMs=In()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ew;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Ca.nextTensorId=0;Ca.nextVariableId=0;function aE(n){const e=Td(oe(n),"float32");return z.makeTensor(e,n,"float32")}function Ab(){const n=bb();if(n._tfengine==null){const e=new wb(n);n._tfengine=new Ca(e)}return CT(n._tfengine.ENV),eE(()=>n._tfengine),n._tfengine}const z=Ab();function iE(n,e){const t={a:n,b:e};return z.runKernel(Fa,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lE(){return typeof navigator<"u"&&navigator!=null}let gg;function uE(n){gg=n}function uy(n){if(gg!==void 0)return gg;if(n||lE()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function cy(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const cE=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:cy,isMobile:uy,mockIsMobile:uE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hn=J();hn.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});hn.registerFlag("IS_BROWSER",()=>cy());hn.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");hn.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));hn.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));hn.registerFlag("PROD",()=>!1);hn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>hn.getBool("DEBUG"));hn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);hn.registerFlag("IS_TEST",()=>!1);hn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>hn.getBool("DEBUG"));hn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);hn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);hn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Os(n,e){let t=n;if(Ot(n))return e==="string"?[]:[n.length];if(Rb(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(_b(n))return[n.buffer.size/(e==null?4:Vi(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||Ot(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&J().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Fb(n,s,[]),s}function Fb(n,e,t){if(t=t||[],!Array.isArray(n)&&!Ot(n)){O(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}O(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),O(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)Fb(n[r],s,t.concat(r))}function tw(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function _(n,e,t,s="numeric"){if(n instanceof Eb())return tw(s,n.dtype,e,t),n;let r=Vo(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),tw(s,r,e,t),n==null||!Ot(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const o=Os(n,r);!Ot(n)&&!Array.isArray(n)&&(n=[n]);const l=r!=="string"?Hr(n,r):_s(n,[],!0);return z.makeTensor(l,o,r)}function Hi(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,a)=>_(o,`${e}[${a}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dy="__op";function M(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+dy;const r=(...o)=>{z.startScope(t);try{const a=s(...o);return Br(a)&&console.error("Cannot return a Promise inside of tidy."),z.endScope(a),a}catch(a){throw z.endScope(null),a}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dE(n,e){const t=_(n,"real","complex"),s=_(e,"imag","complex");zt(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return z.runKernel(zd,r)}const nr=M({complex_:dE});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jr(n,e,t,s){if(s==null)s=Vo(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(_b(n)||Rb(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return z.backend.createTensorFromGPUData(n,e||t,s)}if(!Ot(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){_n(e);const r=oe(e),o=oe(t);O(r===o,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${o}`);for(let a=0;a<t.length;++a){const l=t[a],u=a===t.length-1?l!==oe(e.slice(a)):!0;O(t[a]===e[a]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Ot(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?Hr(n,s):_s(n,[],!0),z.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gs(n,e,t){const s=Os(n,t);return jr(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Io={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class vs{static join(e){return new vs(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>Ot(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=t+r.byteLength;this.shards.push({buffer:r,start:t,end:o}),t=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,o=new ArrayBuffer(r),a=new Uint8Array(o);let l=0;for(let u=s;u<this.shards.length;u++){const d=this.shards[u],f=e+l-d.start,m=l,x=Math.min(t,d.end)-d.start,w=new Uint8Array(d.buffer,f,x-f);if(a.set(w,m),l+=w.length,t<d.end)break}return o}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=pE(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function pE(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,o=e(n[r]);if(o===0)return r;o<0?s=r:t=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fE(){J().set("PROD",!0)}function hE(){J().set("DEBUG",!0)}function mE(){J().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function gE(n){J().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function yE(){z.disposeVariables()}function ds(){return z}function xE(){return z.memory()}function vE(n){return z.profile(n)}function Ue(n,e){return z.tidy(n,e)}function an(n){ly(n).forEach(t=>t.dispose())}function hs(n){return z.keep(n)}function wE(n){return z.time(n)}function bE(n){return z.setBackend(n)}function $E(){return z.ready()}function Pb(){return z.backendName}function SE(n){z.removeBackend(n)}function CE(n){return z.findBackend(n)}function kE(n){return z.findBackendFactory(n)}function py(n,e,t=1){return z.registerBackend(n,e,t)}function Lb(){return z.backend}function NE(n,e){J().setPlatform(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mr=4;async function IE(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<r.length;++a){const l=r[a],u=Array.isArray(n)?n[a].tensor:n[l];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${l}': ${u.dtype}`);const d={name:l,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const p=new Promise(async f=>{const m=await u.bytes(),g=m.reduce((v,b)=>v+b.length,0)+Mr*m.length,x=new Uint8Array(g);let w=0;for(let v=0;v<m.length;v++){const b=m[v],C=new Uint8Array(new Uint32Array([b.length]).buffer);x.set(C,w),w+=Mr,x.set(b,w),w+=b.length}f(x)});s.push(p)}else s.push(u.data());e!=null&&(d.group=e),t.push(d)}const o=await Promise.all(s);return{data:RE(o),specs:t}}function Vb(n,e){const t=new vs(n),s={};let r=0;for(const o of e){const a=TE(o,(l,u)=>t.slice(r+l,r+u));s[o.name]=Bb(o,t.slice(r,r+a)),r+=a}return s}function TE(n,e){const t=oe(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Io[r.dtype]}else if(n.dtype==="string"){let r=0;for(let o=0;o<t;o++)r+=Mr+new Uint32Array(e(r,r+Mr))[0];return r}else s=Io[n.dtype];return t*s}async function EE(n,e){const t=oe(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Io[r.dtype]}else if(n.dtype==="string"){let r=0;for(let o=0;o<t;o++)r+=Mr+new Uint32Array(await e(r,r+Mr))[0];return r}else s=Io[n.dtype];return t*s}function Bb(n,e){const t=n.name,s=n.dtype,r=n.shape,o=oe(r);let a,l=0;if("quantization"in n){const u=n.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${n.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const d=Io[u.dtype],p=u.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){a=new Float32Array(p.length);for(let f=0;f<p.length;f++){const m=p[f];a[f]=m*u.scale+u.min}}else if(u.dtype==="float16")a=LE()(p);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(s==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);a=new Int32Array(p.length);for(let f=0;f<p.length;f++){const m=p[f];a[f]=Math.round(m*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);l+=o*d}else if(s==="string"){const u=oe(n.shape);a=[];for(let d=0;d<u;d++){const p=new Uint32Array(e.slice(l,l+Mr))[0];l+=Mr;const f=new Uint8Array(e.slice(l,l+p));a.push(f),l+=p}}else{const u=Io[s];if(s==="float32")a=new Float32Array(e);else if(s==="int32")a=new Int32Array(e);else if(s==="bool")a=new Uint8Array(e);else if(s==="complex64"){a=new Float32Array(e);const d=new Float32Array(a.length/2),p=new Float32Array(a.length/2);for(let x=0;x<d.length;x++)d[x]=a[x*2],p[x]=a[x*2+1];const f=gs(d,r,"float32"),m=gs(p,r,"float32"),g=nr(f,m);return f.dispose(),m.dispose(),g}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);l+=o*u}return gs(a,r,s)}async function nw(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:r,value:o}=await n.read();if(r&&o==null){const l=t-s.byteLength;throw new Error(`Reader is done but ${l} bytes are still expected`)}const a=new Uint8Array(s.length+o.byteLength);a.set(s,0),a.set(new Uint8Array(o),s.length),s=a}return s.buffer}async function Mb(n,e){const t={},s=n.getReader();let r=new ArrayBuffer(0);for(const o of e){const a=await EE(o,async(d,p)=>(r=await nw(s,r,p),r.slice(d,p)));r=await nw(s,r,a);const l=r.slice(0,a);r=r.slice(a);const u=Bb(o,l);if(t[o.name]=u,Pb()==="webgpu"){const d=Lb();"uploadToGPU"in d&&oe(u.shape)>=J().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&d.uploadToGPU(u.dataId)}}return t}function RE(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(o=>{if(e+=o.byteLength,t.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(o=>{s.set(new Uint8Array(o.buffer),r),r+=o.byteLength}),s.buffer}const fy=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function sw(n){return fy?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function _E(n){if(fy)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function OE(n){if(fy){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function DE(n){return vs.join(n)}function rw(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function zb(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function hy(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function my(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),hy(n,t,s)}function cu(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:sw(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:sw(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new vs(n.weightData).byteLength}}function ud(n){const e=[];for(const t of n)e.push(...t.weights);return e}function AE(){const n=t=>{let s=t<<13,r=0;for(;!(s&8388608);)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function FE(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function PE(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function LE(){const n=AE(),e=FE(),t=PE();return s=>{const r=new ArrayBuffer(4*s.length),o=new Uint32Array(r);for(let a=0;a<s.length;a++){const l=s[a],u=n[t[l>>10]+(l&1023)]+e[l>>10];o[a]=u}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ft{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ft.instance==null&&(ft.instance=new ft),ft.instance}static registerSaveRouter(e){ft.getInstance().saveRouters.push(e)}static registerLoadRouter(e){ft.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return ft.getHandlers(e,"save")}static getLoadHandlers(e,t){return ft.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?ft.getInstance().loadRouters:ft.getInstance().saveRouters).forEach(a=>{const l=a(e,s);l!==null&&r.push(l)}),r}}const VE=n=>ft.registerSaveRouter(n),BE=n=>ft.registerLoadRouter(n),ME=n=>ft.getSaveHandlers(n),zE=(n,e)=>ft.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yg="tensorflowjs",xg=1,bo="models_store",Dr="model_info_store";function Wb(){if(!J().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function vg(n){const e=n.result;e.createObjectStore(bo,{keyPath:"modelPath"}),e.createObjectStore(Dr,{keyPath:"modelPath"})}class To{constructor(e){if(this.indexedDB=Wb(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const o=this.indexedDB.open(yg,xg);o.onupgradeneeded=()=>vg(o),o.onsuccess=()=>{const a=o.result;if(t==null){const l=a.transaction(bo,"readonly"),d=l.objectStore(bo).get(this.modelPath);d.onsuccess=()=>{if(d.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(d.result.modelArtifacts)},d.onerror=p=>(a.close(),r(d.error)),l.oncomplete=()=>a.close()}else{t.weightData=vs.join(t.weightData);const l=cu(t),u=a.transaction(Dr,"readwrite");let d=u.objectStore(Dr),p;try{p=d.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(m){return r(m)}let f;p.onsuccess=()=>{f=a.transaction(bo,"readwrite");const m=f.objectStore(bo);let g;try{g=m.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:l})}catch(x){return r(x)}g.onsuccess=()=>s({modelArtifactsInfo:l}),g.onerror=x=>{d=u.objectStore(Dr);const w=d.delete(this.modelPath);w.onsuccess=()=>(a.close(),r(g.error)),w.onerror=v=>(a.close(),r(g.error))}},p.onerror=m=>(a.close(),r(p.error)),u.oncomplete=()=>{f==null?a.close():f.oncomplete=()=>a.close()}}},o.onerror=a=>r(o.error)})}}To.URL_SCHEME="indexeddb://";const Ub=n=>J().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(To.URL_SCHEME)?WE(n.slice(To.URL_SCHEME.length)):null;ft.registerSaveRouter(Ub);ft.registerLoadRouter(Ub);function WE(n){return new To(n)}function UE(n){return n.startsWith(To.URL_SCHEME)?n.slice(To.URL_SCHEME.length):n}class GE{constructor(){this.indexedDB=Wb()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(yg,xg);s.onupgradeneeded=()=>vg(s),s.onsuccess=()=>{const r=s.result,o=r.transaction(Dr,"readonly"),l=o.objectStore(Dr).getAll();l.onsuccess=()=>{const u={};for(const d of l.result)u[d.modelPath]=d.modelArtifactsInfo;e(u)},l.onerror=u=>(r.close(),t(l.error)),o.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=UE(e),new Promise((t,s)=>{const r=this.indexedDB.open(yg,xg);r.onupgradeneeded=()=>vg(r),r.onsuccess=()=>{const o=r.result,a=o.transaction(Dr,"readwrite"),l=a.objectStore(Dr),u=l.get(e);let d;u.onsuccess=()=>{if(u.result==null)return o.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const p=l.delete(e),f=()=>{d=o.transaction(bo,"readwrite");const g=d.objectStore(bo).delete(e);g.onsuccess=()=>t(u.result.modelArtifactsInfo),g.onerror=x=>s(u.error)};p.onsuccess=f,p.onerror=m=>(f(),o.close(),s(u.error))}},u.onerror=p=>(o.close(),s(u.error)),a.oncomplete=()=>{d==null?o.close():d.oncomplete=()=>o.close()}},r.onerror=o=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zs="/",ga="tensorflowjs_models",Gb="info",HE="model_topology",jE="weight_specs",qE="weight_data",KE="model_metadata";function Hb(n){return{info:[ga,n,Gb].join(Zs),topology:[ga,n,HE].join(Zs),weightSpecs:[ga,n,jE].join(Zs),weightData:[ga,n,qE].join(Zs),modelMetadata:[ga,n,KE].join(Zs)}}function jb(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function XE(n){const e=n.split(Zs);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Zs)}function YE(n){return n.startsWith(Eo.URL_SCHEME)?n.slice(Eo.URL_SCHEME.length):n}class Eo{constructor(e){if(!J().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Hb(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=cu(e),o=vs.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,_E(o));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw jb(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const l=JSON.parse(o);t.format=l.format,t.generatedBy=l.generatedBy,t.convertedBy=l.convertedBy,l.signature!=null&&(t.signature=l.signature),l.userDefinedMetadata!=null&&(t.userDefinedMetadata=l.userDefinedMetadata),l.modelInitializer!=null&&(t.modelInitializer=l.modelInitializer),l.initializerSignature!=null&&(t.initializerSignature=l.initializerSignature),l.trainingConfig!=null&&(t.trainingConfig=l.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=OE(a),t}}Eo.URL_SCHEME="localstorage://";const qb=n=>J().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Eo.URL_SCHEME)?QE(n.slice(Eo.URL_SCHEME.length)):null;ft.registerSaveRouter(qb);ft.registerLoadRouter(qb);function QE(n){return new Eo(n)}class ZE{constructor(){O(J().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),O(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=ga+Zs,s=Zs+Gb;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);if(o.startsWith(t)&&o.endsWith(s)){const a=XE(o);e[a]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=YE(e);const t=Hb(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return jb(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xa="://";class nn{constructor(){this.managers={}}static getInstance(){return nn.instance==null&&(nn.instance=new nn),nn.instance}static registerManager(e,t){O(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(xa)&&(e=e.slice(0,e.indexOf(xa))),O(e.length>0,()=>"scheme must not be an empty string.");const s=nn.getInstance();O(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=nn.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(nn.getInstance().managers)}}function Xc(n){if(n.indexOf(xa)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${nn.getSchemes().join(",")}`);return{scheme:n.split(xa)[0],path:n.split(xa)[1]}}async function Kb(n,e,t=!1){O(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=ft.getLoadHandlers(n);O(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),O(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],o=ft.getSaveHandlers(e);O(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),O(o.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const a=o[0],l=Xc(n).scheme,u=Xc(n).path,d=l===Xc(n).scheme,p=await r.load();t&&d&&await nn.getManager(l).removeModel(u);const f=await a.save(p);return t&&!d&&await nn.getManager(l).removeModel(u),f.modelArtifactsInfo}async function JE(){const n=nn.getSchemes(),e={};for(const t of n){const s=await nn.getManager(t).listModels();for(const r in s){const o=t+xa+r;e[o]=s[r]}}return e}async function eR(n){const e=Xc(n);return nn.getManager(e.scheme).removeModel(e.path)}async function tR(n,e){return Kb(n,e,!1)}async function nR(n,e){return Kb(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sR{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!J().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return $b(e)}}if(J().get("IS_BROWSER")){J().setPlatform("browser",new sR);try{nn.registerManager(Eo.URL_SCHEME,new ZE)}catch{}try{nn.registerManager(To.URL_SCHEME,new GE)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rR={importFetch:()=>require("node-fetch")};let Km;class oR{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return J().global.fetch!=null?J().global.fetch(e,t):(Km==null&&(Km=rR.importFetch()),Km(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}J().get("IS_NODE")&&!J().get("IS_BROWSER")&&J().setPlatform("node",new oR);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ae(n,e="float32",t){return e=e||"float32",_n(n),new kt(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aR(n,e){const t=_(n,"x","cast");if(!hb(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return z.runKernel(pl,s,r)}const at=M({cast_:aR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iR(n){const t={x:_(n,"x","clone","string_or_numeric")};return z.runKernel(Il,t)}const Js=M({clone_:iR});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gy(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ab();const lR={buffer:Ae,cast:at,clone:Js,print:gy};tE(lR);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uR(n,e){let t=_(n,"a","add"),s=_(e,"b","add");[t,s]=ht(t,s);const r={a:t,b:s};return z.runKernel(Fa,r)}const _e=M({add_:uR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cR(n,e){let t=_(n,"a","floorDiv"),s=_(e,"b","floorDiv");[t,s]=ht(t,s);const r={a:t,b:s};return z.runKernel(Cl,r)}const yy=M({floorDiv_:cR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dR(n,e){let t=_(n,"a","div"),s=_(e,"b","div");if([t,s]=ht(t,s),t.dtype==="int32"&&s.dtype==="int32")return yy(t,s);const r={a:t,b:s},o={};return z.runKernel(yl,r,o)}const ot=M({div_:dR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pR(n,e){let t=_(n,"a","mul"),s=_(e,"b","mul");[t,s]=ht(t,s);const r={a:t,b:s};return z.runKernel(zl,r)}const xe=M({mul_:pR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fR(n){const e=_(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return z.runKernel(Wd,t)}else{const t={x:e};return z.runKernel(Ed,t)}}const Nn=M({abs_:fR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hR(n){const t={x:_(n,"x","acos")};return z.runKernel(rl,t)}const Xb=M({acos_:hR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mR(n){const t={x:_(n,"x","acosh")};return z.runKernel(ol,t)}const Yb=M({acosh_:mR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gR(n){O(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),O(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,o)=>_(r,`tensors${o}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!Qe(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return z.runKernel(Rd,s)}const Qb=M({addN_:gR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yR(n,e=null,t=!1){const r={x:_(n,"x","all","bool")},o={axis:e,keepDims:t};return z.runKernel(_d,r,o)}const Zb=M({all_:yR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xR(n,e=null,t=!1){const r={x:_(n,"x","any","bool")},o={axis:e,keepDims:t};return z.runKernel(Od,r,o)}const Jb=M({any_:xR});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vR(n,e=0){const s={x:_(n,"x","argMax")},r={axis:e};return z.runKernel(Dd,s,r)}const e$=M({argMax_:vR});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wR(n,e=0){const s={x:_(n,"x","argMin")},r={axis:e};return z.runKernel(Ad,s,r)}const t$=M({argMin_:wR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bR(n){const t={x:_(n,"x","asin")};return z.runKernel(al,t)}const n$=M({asin_:bR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $R(n){const t={x:_(n,"x","asinh")};return z.runKernel(il,t)}const s$=M({asinh_:$R});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SR(n){const t={x:_(n,"x","atan")};return z.runKernel(ll,t)}const r$=M({atan_:SR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CR(n,e){let t=_(n,"a","atan2"),s=_(e,"b","atan2");[t,s]=ht(t,s);const r={a:t,b:s};return z.runKernel(cl,r)}const o$=M({atan2_:CR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kR(n){const t={x:_(n,"x","atanh")};return z.runKernel(ul,t)}const a$=M({atanh_:kR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function du(n,e,t,s,r="NHWC",o){const a=n[3],l=[...e,a],u=lr(r);return At(n,l,t,o,s,null,null,u)}function es(n,e,t,s,r,o,a="channelsLast"){const[l,u]=ji(e);let d;if(a==="channelsLast")d=[l,u,n[3],n[3]];else if(a==="channelsFirst")d=[l,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return At(n,d,t,s,r,o,!1,a)}function ir(n,e,t,s,r,o,a="NDHWC"){const[l,u,d]=wg(e);let p,f;if(a==="NDHWC")f="channelsLast",p=[l,u,d,n[4],n[4]];else if(a==="NCDHW")f="channelsFirst",p=[l,u,d,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return qr(n,p,t,s,r,!1,f,o)}function At(n,e,t,s,r,o,a=!1,l="channelsLast"){let[u,d,p,f]=[-1,-1,-1,-1];if(l==="channelsLast")[u,d,p,f]=n;else if(l==="channelsFirst")[u,f,d,p]=n;else throw new Error(`Unknown dataFormat ${l}`);const[m,g,,x]=e,[w,v]=ji(t),[b,C]=ji(s),I=va(m,b),N=va(g,C),{padInfo:R,outHeight:D,outWidth:F}=TR(r,d,p,w,v,I,N,o,l),V=a?x*f:x;let P;return l==="channelsFirst"?P=[u,V,D,F]:l==="channelsLast"&&(P=[u,D,F,V]),{batchSize:u,dataFormat:l,inHeight:d,inWidth:p,inChannels:f,outHeight:D,outWidth:F,outChannels:V,padInfo:R,strideHeight:w,strideWidth:v,filterHeight:m,filterWidth:g,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationHeight:b,dilationWidth:C,inShape:n,outShape:P,filterShape:e}}function qr(n,e,t,s,r,o=!1,a="channelsLast",l){let[u,d,p,f,m]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[u,d,p,f,m]=n;else if(a==="channelsFirst")[u,m,d,p,f]=n;else throw new Error(`Unknown dataFormat ${a}`);const[g,x,w,,v]=e,[b,C,I]=wg(t),[N,R,D]=wg(s),F=va(g,N),V=va(x,R),P=va(w,D),{padInfo:A,outDepth:T,outHeight:W,outWidth:j}=ER(r,d,p,f,b,C,I,F,V,P,l),Y=o?v*m:v;let Q;return a==="channelsFirst"?Q=[u,Y,T,W,j]:a==="channelsLast"&&(Q=[u,T,W,j,Y]),{batchSize:u,dataFormat:a,inDepth:d,inHeight:p,inWidth:f,inChannels:m,outDepth:T,outHeight:W,outWidth:j,outChannels:Y,padInfo:A,strideDepth:b,strideHeight:C,strideWidth:I,filterDepth:g,filterHeight:x,filterWidth:w,effectiveFilterDepth:F,effectiveFilterHeight:V,effectiveFilterWidth:P,dilationDepth:N,dilationHeight:R,dilationWidth:D,inShape:n,outShape:Q,filterShape:e}}function NR(n,e,t,s,r){s==null&&(s=xy(n,e,t));const o=n[0],a=n[1],l=qi((o-e+2*s)/t+1,r),u=qi((a-e+2*s)/t+1,r);return[l,u]}function IR(n,e,t,s,r,o){r==null&&(r=xy(n,e[0],s[0]));const a=[0,0,0,t];for(let l=0;l<3;l++)n[l]+2*r>=e[l]&&(a[l]=qi((n[l]-e[l]+2*r)/s[l]+1,o));return a}function xy(n,e,t,s=1){const r=va(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function ji(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function wg(n){return typeof n=="number"?[n,n,n]:n}function va(n,e){return e<=1?n:n+(n-1)*(e-1)}function TR(n,e,t,s,r,o,a,l,u){let d,p,f;if(typeof n=="number"){d={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const g=NR([e,t],o,s,n,l);p=g[0],f=g[1]}else if(n==="same"){p=Math.ceil(e/s),f=Math.ceil(t/r);const m=Math.max(0,(p-1)*s+o-e),g=Math.max(0,(f-1)*r+a-t),x=Math.floor(m/2),w=m-x,v=Math.floor(g/2),b=g-v;d={top:x,bottom:w,left:v,right:b,type:"SAME"}}else if(n==="valid")d={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((e-o+1)/s),f=Math.ceil((t-a+1)/r);else if(typeof n=="object"){const m=u==="channelsLast"?n[1][0]:n[2][0],g=u==="channelsLast"?n[1][1]:n[2][1],x=u==="channelsLast"?n[2][0]:n[3][0],w=u==="channelsLast"?n[2][1]:n[3][1];d={top:m,bottom:g,left:x,right:w,type:m===0&&g===0&&x===0&&w===0?"VALID":"EXPLICIT"},p=qi((e-o+m+g)/s+1,l),f=qi((t-a+x+w)/r+1,l)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:d,outHeight:p,outWidth:f}}function ER(n,e,t,s,r,o,a,l,u,d,p){let f,m,g,x;if(n==="valid"&&(n=0),typeof n=="number"){f={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const v=IR([e,t,s,1],[l,u,d],1,[r,o,a],n,p);m=v[0],g=v[1],x=v[2]}else if(n==="same"){m=Math.ceil(e/r),g=Math.ceil(t/o),x=Math.ceil(s/a);const w=(m-1)*r+l-e,v=(g-1)*o+u-t,b=(x-1)*a+d-s,C=Math.floor(w/2),I=w-C,N=Math.floor(v/2),R=v-N,D=Math.floor(b/2),F=b-D;f={top:N,bottom:R,left:D,right:F,front:C,back:I,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:f,outDepth:m,outHeight:g,outWidth:x}}function qi(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Ki(n){const[e,t,s]=ji(n);return e===1&&t===1&&s===1}function Yt(n,e){return Ki(n)||Ki(e)}function Ro(n){return ji(n).every(e=>e>0)}function lr(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function ts(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")O(No(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{O(No(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RR(n,e){const s={x:_(n,"x","reshape","string_or_numeric")},r={shape:e};return z.runKernel(Wp,s,r)}const le=M({reshape_:RR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _R(n,e,t,s,r){const o=_(n,"x","avgPool","float32"),a=1;O(Yt(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let l=o,u=!1;o.rank===3&&(u=!0,l=le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(l.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${l.rank}.`),ts("avgPool",s,r);const d={x:l},p={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let f=z.runKernel(Fd,d,p);return f=at(f,o.dtype),u?le(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const vy=M({avgPool_:_R});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OR(n,e,t,s,r,o="NDHWC"){const a=_(n,"x","avgPool3d","float32");let l=a,u=!1;a.rank===4&&(u=!0,l=le(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),O(l.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${l.rank}.`),O(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),O(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),ts("avgPool3d",s,r);const d={x:l},p={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:o};let f=z.runKernel(Pd,d,p);return f=at(f,l.dtype),u?le(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const i$=M({avgPool3d_:OR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DR(n,e=0){O(n.length>=1,()=>"Pass at least one tensor to concat");const t=Hi(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),t.length===1)return Js(t[0]);const s=t,r={axis:e};return z.runKernel(Ud,s,r)}const Xt=M({concat_:DR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AR(n,e,t=!1,s=!1){let r=_(n,"a","matMul"),o=_(e,"b","matMul");[r,o]=ht(r,o);const a={a:r,b:o},l={transposeA:t,transposeB:s};return z.runKernel(Ld,a,l)}const qe=M({matMul_:AR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FR(n){const t={x:_(n,"x","sigmoid","float32")};return z.runKernel(Jl,t)}const Co=M({sigmoid_:FR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PR(n,e,t){const s=_(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},o={begin:e,size:t};return z.runKernel(Yp,r,o)}const tt=M({slice_:PR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LR(n){const t={x:_(n,"x","tanh","float32")};return z.runKernel(au,t)}const cd=M({tanh_:LR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VR(n,e,t,s,r,o){const a=_(n,"forgetBias","basicLSTMCell"),l=_(e,"lstmKernel","basicLSTMCell"),u=_(t,"lstmBias","basicLSTMCell"),d=_(s,"data","basicLSTMCell"),p=_(r,"c","basicLSTMCell"),f=_(o,"h","basicLSTMCell"),m=Xt([d,f],1),g=qe(m,l),x=_e(g,u),w=x.shape[0],v=x.shape[1]/4,b=[w,v],C=tt(x,[0,0],b),I=tt(x,[0,v],b),N=tt(x,[0,v*2],b),R=tt(x,[0,v*3],b),D=_e(xe(Co(C),cd(I)),xe(p,Co(_e(a,N)))),F=xe(cd(D),Co(R));return[D,F]}const l$=M({basicLSTMCell_:VR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BR(n,e,t){const s=_(n,"x","batchToSpaceND"),r=e.reduce((l,u)=>l*u);O(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),O(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),O(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const o={x:s},a={blockShape:e,crops:t};return z.runKernel(Vd,o,a)}const wy=M({batchToSpaceND_:BR});function MR(n){let e;return n.rank===0||n.rank===1?e=le(n,[1,1,1,n.size]):n.rank===2?e=le(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=le(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zR(n,e,t,s,r,o){o==null&&(o=.001);const a=_(n,"x","batchNorm"),l=_(e,"mean","batchNorm"),u=_(t,"variance","batchNorm");let d;r!=null&&(d=_(r,"scale","batchNorm"));let p;s!=null&&(p=_(s,"offset","batchNorm")),O(l.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(p==null||l.rank===p.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(d==null||l.rank===d.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:MR(a),scale:d,offset:p,mean:l,variance:u},g={varianceEpsilon:o},x=z.runKernel(dp,m,g);return le(x,a.shape)}const pu=M({batchNorm_:zR});function WR(n,e,t,s,r,o){const a=_(n,"x","batchNorm"),l=_(e,"mean","batchNorm"),u=_(t,"variance","batchNorm");let d;r!=null&&(d=_(r,"scale","batchNorm"));let p;return s!=null&&(p=_(s,"offset","batchNorm")),O(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),O(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${l.rank}.`),O(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),d!=null&&O(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${d.rank}.`),p!=null&&O(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),pu(a,l,u,p,d,o)}const u$=M({batchNorm2d_:WR});function UR(n,e,t,s,r,o){const a=_(n,"x","batchNorm"),l=_(e,"mean","batchNorm"),u=_(t,"variance","batchNorm");let d;r!=null&&(d=_(r,"scale","batchNorm"));let p;return s!=null&&(p=_(s,"offset","batchNorm")),O(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),O(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${l.rank}.`),O(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),d!=null&&O(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${d.rank}.`),p!=null&&O(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),pu(a,l,u,p,d,o)}const c$=M({batchNorm3d_:UR});function GR(n,e,t,s,r,o){const a=_(n,"x","batchNorm"),l=_(e,"mean","batchNorm"),u=_(t,"variance","batchNorm");let d;r!=null&&(d=_(r,"scale","batchNorm"));let p;return s!=null&&(p=_(s,"offset","batchNorm")),O(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),O(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${l.rank}.`),O(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),d!=null&&O(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${d.rank}.`),p!=null&&O(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),pu(a,l,u,p,d,o)}const d$=M({batchNorm4d_:GR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HR(n,e,t){const s=_(n,"x","bincount"),r=_(e,"weights","bincount");O(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),O(t>=0,()=>`size must be non-negative, but got ${t}.`),O(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const o={x:s,weights:r},a={size:t};return z.runKernel(Bd,o,a)}const by=M({bincount_:HR});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jR(n,e){const t=_(n,"x","bitwiseAnd"),s=_(e,"y","bitwiseAnd");if(!Qe(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return z.runKernel(dl,r)}const p$=M({bitwiseAnd_:jR});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qR(n,e){const t=_(n,"s0","broadcastArgs","int32"),s=_(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return z.runKernel(Md,r)}const f$=M({broadcastArgs_:qR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KR(n,e){let t=_(n,"broadcastTo","x");const s=t.shape;if(_n(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const d=t.shape.slice();for(;d.length<e.length;)d.unshift(1);t=le(t,d)}const r=t.shape,o=Array.from(e);for(let d=e.length-1;d>=0;d--)if(r[d]===e[d])o[d]=1;else if(t.shape[d]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(o.map((d,p)=>d>1?p:-1).filter(d=>d>=0).length===0)return Js(t);const l={x:t},u={reps:o};return z.runKernel(iu,l,u)}const wa=M({broadcastTo_:KR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XR(n){const t={x:_(n,"x","ceil","float32")};return z.runKernel(fl,t)}const h$=M({ceil_:XR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pa(n,e,t){_n(n),t=t||Vo(e);const s={shape:n,value:e,dtype:t};return z.runKernel(up,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YR(n,e,t){const s=_(n,"x","clipByValue");if(O(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Pa(s.shape,e,s.dtype);const r={x:s},o={clipValueMin:e,clipValueMax:t};return z.runKernel(hl,r,o)}const m$=M({clipByValue_:YR});function QR(n){return Xt(n,0)}const g$=M({concat1d_:QR});function ZR(n,e){return Xt(n,e)}const y$=M({concat2d_:ZR});function JR(n,e){return Xt(n,e)}const x$=M({concat3d_:JR});function e_(n,e){return Xt(n,e)}const v$=M({concat4d_:e_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t_(n,e,t,s,r="NHWC",o=[1,1],a){const l=_(n,"x","conv2d","float32"),u=_(e,"filter","conv2d","float32");let d=l,p=!1;l.rank===3&&(p=!0,d=le(l,[1,l.shape[0],l.shape[1],l.shape[2]])),O(d.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${d.rank}.`),O(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),ts("conv2d",s,a);const f=r==="NHWC"?d.shape[3]:d.shape[1];O(f===u.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${u.shape[2]}.`),O(Yt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),O(Ro(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),O(Ro(t),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:d,filter:u},g={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a},x=z.runKernel(Gd,m,g);return p?le(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const fu=M({conv2d_:t_});function n_(n,e,t,s,r="NWC",o=1,a){const l=_(n,"x","conv1d"),u=_(e,"filter","conv1d");let d=l,p=!1;l.rank===2&&(p=!0,d=le(l,[1,l.shape[0],l.shape[1]])),O(d.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${d.rank}.`),O(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),ts("conv1d",s,a),O(d.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${d.shape[2]}) must match input depth for filter ${u.shape[1]}.`),O(Yt(t,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`),O(Ro(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),O(Ro(t),()=>"Error in conv1D: Stride should be larger than 0."),O(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const f=le(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=le(d,[d.shape[0],1,d.shape[1],d.shape[2]]),v=fu(m,f,[1,t],s,"NHWC",[1,o],a);return p?le(v,[v.shape[2],v.shape[3]]):le(v,[v.shape[0],v.shape[2],v.shape[3]])}const w$=M({conv1d_:n_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s_(n,e,t,s,r,o="NHWC",a){O(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let l=n,u=e,d=!1;e.rank===3&&(d=!0,u=le(e,[1,e.shape[0],e.shape[1],e.shape[2]]),l=[1,n[0],n[1],n[2]]),O(l.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${l.length}.`),O(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),O(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const p=o==="NHWC"?l[3]:l[1],f=o==="NHWC"?u.shape[3]:u.shape[1];O(p===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${t.shape[2]}.`),O(f===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${t.shape[3]}.`),ts("conv2dDerInput",r,a);const m={dy:u,filter:t},g={strides:s,pad:r,dataFormat:o,dimRoundingMode:a,inputShape:l},x=z.runKernel(jd,m,g);return d?le(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const b$=M({conv2DBackpropInput_:s_});function r_(n,e,t,s,r,o){const a=_(n,"x","conv2dTranspose"),l=_(e,"filter","conv2dTranspose");return b$(t,a,l,s,r,"NHWC",o)}const $$=M({conv2dTranspose_:r_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o_(n,e,t,s,r="NDHWC",o=[1,1,1]){const a=_(n,"x","conv3d"),l=_(e,"filter","conv3d");let u=a,d=!1;a.rank===4&&(d=!0,u=le(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),O(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),O(l.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${l.rank}.`),O(u.shape[4]===l.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${l.shape[3]}.`),O(Yt(t,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),O(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),O(Ro(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),O(Ro(t),()=>"Error in conv3D: Strides should be larger than 0.");const p={x:u,filter:l},f={strides:t,pad:s,dataFormat:r,dilations:o},m=z.runKernel(qd,p,f);return d?le(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const S$=M({conv3d_:o_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a_(n,e,t,s,r){O(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,a=e,l=!1;e.rank===4&&(l=!0,a=le(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const u=o[4],d=a.shape[4];O(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),O(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),O(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),O(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),O(d===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${d}) must match output depth for filter ${t.shape[4]}.`);const p={dy:a,filter:t},f={pad:r,strides:s,inputShape:o},m=z.runKernel(Kd,p,f);return l?le(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const i_=M({conv3DBackpropInput_:a_});function l_(n,e,t,s,r){const o=_(n,"x","conv3dTranspose"),a=_(e,"filter","conv3dTranspose");return i_(t,o,a,s,r)}const C$=M({conv3dTranspose_:l_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u_(n){const t={x:_(n,"x","cos","float32")};return z.runKernel(ml,t)}const k$=M({cos_:u_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c_(n){const t={x:_(n,"x","cosh","float32")};return z.runKernel(gl,t)}const N$=M({cosh_:c_});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d_(n,e=0,t=!1,s=!1){const o={x:_(n,"x","cumprod")},a={axis:e,exclusive:t,reverse:s};return z.runKernel(Xd,o,a)}const I$=M({cumprod_:d_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p_(n,e=0,t=!1,s=!1){const o={x:_(n,"x","cumsum")},a={axis:e,exclusive:t,reverse:s};return z.runKernel(Yd,o,a)}const T$=M({cumsum_:p_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f_(n,e,t,s=!1){const r=_(n,"x","denseBincount"),o=_(e,"weights","denseBincount");O(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),O(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),O(t>=0,()=>`size must be non-negative, but got ${t}.`),O(o.size===r.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${o.shape}.`);const a={x:r,weights:o},l={size:t,binaryOutput:s};return z.runKernel(Zd,a,l)}const E$=M({denseBincount_:f_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h_(n,e,t="NHWC"){const s=_(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],o=t==="NHWC"?s.shape[2]:s.shape[3],a=t==="NHWC"?s.shape[3]:s.shape[1];O(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),O(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),O(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${s.shape}`),O(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${s.shape}`);const l={x:s},u={blockSize:e,dataFormat:t};return z.runKernel(Jd,l,u)}const R$=M({depthToSpace_:h_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m_(n,e,t,s,r="NHWC",o=[1,1],a){const l=_(n,"x","depthwiseConv2d","float32"),u=_(e,"filter","depthwiseConv2d","float32");let d=l,p=!1;l.rank===3&&(p=!0,d=le(l,[1,l.shape[0],l.shape[1],l.shape[2]])),O(d.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),O(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const f=r==="NHWC"?d.shape[3]:d.shape[1];O(f===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${u.shape[2]}.`),ts("depthwiseConv2d",s,a);const m={x:d,filter:u},g={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a},x=z.runKernel(ep,m,g);return p?le(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const wf=M({depthwiseConv2d_:m_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g_(n){const t={x:_(n,"x","diag")};return z.runKernel(sp,t)}const _$=M({diag_:g_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y_(n,e,t,s,r=[1,1],o="NHWC"){const a=_(n,"x","dilation2d"),l=_(e,"filter","dilation2d");O(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),O(l.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${l.rank}.`),O(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let u=a,d=!1;a.rank===3&&(u=le(a,[1,a.shape[0],a.shape[1],a.shape[2]]),d=!0),O(u.shape[3]===l.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${l.shape[2]}`);const p={x:u,filter:l},f={strides:t,pad:s,dilations:r},m=z.runKernel(rp,p,f);return d?le(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const O$=M({dilation2d_:y_});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _o(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const o=t-1-r,a=n[o]||1;(e[e.length-1-r]||1)>1&&a===1&&s.unshift(o)}return s}function $y(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],o=e.length-s-1,a=e[o];(r==null||r===1&&a>1)&&t.unshift(o)}return t}function Le(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let o=n[n.length-r-1];o==null&&(o=1);let a=e[e.length-r-1];if(a==null&&(a=1),o===1)s[t-r-1]=a;else if(a===1)s[t-r-1]=o;else if(o!==a){const l=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(l)}else s[t-r-1]=o}return s}const x_=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:Le,getBroadcastDims:_o,getReductionAxes:$y},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v_(n,e){let t=_(n,"a","equal","string_or_numeric"),s=_(e,"b","equal","string_or_numeric");[t,s]=ht(t,s),Le(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(wl,r)}const Sy=M({equal_:v_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w_(n,e,t){const s=_(e,"a","where"),r=_(t,"b","where"),o=_(n,"condition","where","bool"),a=Le(Le(o.shape,s.shape),r.shape),l=wa(o,a),u=wa(s,a),d=wa(r,a),p={condition:l,t:u,e:d};return z.runKernel(Xp,p)}const er=M({where_:w_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b_(n){const t={x:_(n,"x","zerosLike")};return z.runKernel(gf,t)}const En=M({zerosLike_:b_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $_(n,e){let t=_(n,"a","div"),s=_(e,"b","div");[t,s]=ht(t,s);const r=ot(t,s),o=En(r),a=Sy(s,o);return er(a,o,r)}const D$=M({divNoNan_:$_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S_(n,e){const t=_(n,"t1","dot"),s=_(e,"t2","dot");O((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],o=s.rank===1?s.size:s.shape[0];if(O(r===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${o}.`),t.rank===1&&s.rank===1){const a=le(t,[1,-1]),l=le(s,[-1,1]),u=qe(a,l);return le(u,[])}else if(t.rank===1&&s.rank===2){const a=le(t,[1,-1]),l=le(s,[s.shape[0],s.shape[1]]),u=qe(a,l);return le(u,[u.size])}else if(t.rank===2&&s.rank===1){const a=le(s,[-1,1]),l=qe(t,a);return le(l,[l.size])}else{const a=le(s,[s.shape[0],s.shape[1]]);return qe(t,a)}}const A$=M({dot_:S_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C_(n,...e){const t=e.map((r,o)=>_(r,`tensors${o}`,"einsum")),s={equation:n};return z.runKernel(ap,t,s)}const xo=M({einsum_:C_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k_(n){const t={x:_(n,"x","elu","float32")};return z.runKernel(xl,t)}const Cy=M({elu_:k_});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N_(n,e){const t=_(n,"x","ensureShape","string_or_numeric");if(!pb(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const F$=M({ensureShape_:N_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I_(n){let e=_(n,"x","erf");O(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=at(e,"float32"));const t={x:e};return z.runKernel(vl,t)}const P$=M({erf_:I_});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ky(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function L$(n,e,t){const s=n.length+e.length,r=[];let o=0,a=0;for(let l=0;l<s;l++)t.indexOf(l)===-1?r.push(n[o++]):r.push(e[a++]);return r}function Wt(n,e){const t=[],s=n.length;for(let o=0;o<s;o++)e.indexOf(o)===-1&&t.push(n[o]);const r=e.map(o=>n[o]);return[t,r]}function It(n,e){const t=e.map(s=>1);return L$(n,t,e)}function Ut(n,e,t){O(ky(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function wt(n,e){if(ky(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function hu(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function bt(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T_(n,e=null,t=!1){const r={x:_(n,"x","max")},o={reductionIndices:e,keepDims:t};return z.runKernel(vp,r,o)}const ko=M({max_:T_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E_(n,e=null,t=!1){const r={x:_(n,"x","min")},o={axis:e,keepDims:t};return z.runKernel(Cp,r,o)}const dd=M({min_:E_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R_(n,e){let t=_(n,"base","pow"),s=_(e,"exp","pow");[t,s]=ht(t,s);const r={a:t,b:s};return z.runKernel(Ul,r)}const ka=M({pow_:R_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ve(n,e){if((Ot(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Ot(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return jr(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function __(n){const t={x:_(n,"x","sqrt","float32")};return z.runKernel(tu,t)}const Ds=M({sqrt_:__});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O_(n){const e=_(n,"x","square"),t={};return z.runKernel("Square",{x:e},t)}const Jn=M({square_:O_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D_(n,e=null,t=!1){let s=_(n,"x","sum");s.dtype==="bool"&&(s=at(s,"int32"));const r={x:s},o={axis:e,keepDims:t};return z.runKernel(Qp,r,o)}const rt=M({sum_:D_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A_(n,e="euclidean",t=null,s=!1){n=_(n,"x","norm");const r=V$(n,e,t);let o=r.shape;if(s){const a=Me(t,n.shape);o=It(r.shape,a)}return le(r,o)}function V$(n,e,t=null){if(n.rank===0)return Nn(n);if(n.rank!==1&&t===null)return V$(le(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return rt(Nn(n),t);if(e===1/0)return ko(Nn(n),t);if(e===-1/0)return dd(Nn(n),t);if(e==="euclidean"||e===2)return Ds(rt(ka(Nn(n),Ve(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return ko(rt(Nn(n),t[0]),t[1]-1);if(e===1/0)return ko(rt(Nn(n),t[1]),t[0]);if(e===-1/0)return dd(rt(Nn(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Ds(rt(Jn(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const mu=M({norm_:A_});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F_(n,e=null,t=!1){return mu(n,"euclidean",e,t)}const B$=M({euclideanNorm_:F_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P_(n){const t={x:_(n,"x","exp")};return z.runKernel(bl,t)}const zr=M({exp_:P_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L_(n,e=0){const t=_(n,"x","expandDims","string_or_numeric");O(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return z.runKernel(ip,s,r)}const Ks=M({expandDims_:L_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V_(n){const t={x:_(n,"x","expm1")};return z.runKernel($l,t)}const M$=M({expm1_:V_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B_(n,e){const t=_(n,"x","tile","string_or_numeric");O(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return z.runKernel(iu,s,r)}const ba=M({tile_:B_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M_(n,e,t,s="float32"){e==null&&(e=n);const r=Ae([n,e],s),o=n<=e?n:e;for(let l=0;l<o;++l)r.set(1,l,l);const a=le(r.toTensor(),[n,e]);if(t==null)return a;if(t.length===1)return ba(Ks(a,0),[t[0],1,1]);if(t.length===2)return ba(Ks(Ks(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return ba(Ks(Ks(Ks(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const Ny=M({eye_:M_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z_(n){const t={x:_(n,"x","floor","float32")};return z.runKernel(Sl,t)}const Iy=M({floor_:z_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W_(n,e,t=0,s=0){const r=_(n,"x","gather"),o=_(e,"indices","gather","int32"),a={x:r,indices:o},l={axis:t,batchDims:s};return z.runKernel(pp,a,l)}const Ty=M({gather_:W_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U_(n,e){let t=_(n,"a","greater","string_or_numeric"),s=_(e,"b","greater","string_or_numeric");[t,s]=ht(t,s),Le(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(kl,r)}const gu=M({greater_:U_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G_(n,e){let t=_(n,"a","greaterEqual","string_or_numeric"),s=_(e,"b","greaterEqual","string_or_numeric");[t,s]=ht(t,s),Le(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(Nl,r)}const Ey=M({greaterEqual_:G_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H_(n){const t={input:_(n,"input","imag")};return z.runKernel(mp,t)}const yu=M({imag_:H_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j_(n){const t={x:_(n,"x","isFinite")};return z.runKernel(Tl,t)}const z$=M({isFinite_:j_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q_(n){const t={x:_(n,"x","isInf")};return z.runKernel(El,t)}const W$=M({isInf_:q_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K_(n){const t={x:_(n,"x","isNaN")};return z.runKernel(Rl,t)}const U$=M({isNaN_:K_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X_(n,e=.2){const s={x:_(n,"x","leakyRelu")},r={alpha:e};return z.runKernel(gp,s,r)}const Ry=M({leakyRelu_:X_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y_(n,e){let t=_(n,"a","less","string_or_numeric"),s=_(e,"b","less","string_or_numeric");[t,s]=ht(t,s),Le(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(_l,r)}const pd=M({less_:Y_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q_(n,e){let t=_(n,"a","lessEqual","string_or_numeric"),s=_(e,"b","lessEqual","string_or_numeric");[t,s]=ht(t,s),Le(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(Ol,r)}const bf=M({lessEqual_:Q_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return z.runKernel(yp,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z_(n,e=5,t=1,s=1,r=.5){const o=_(n,"x","localResponseNormalization");O(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),O(No(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=o,l=!1;o.rank===3&&(l=!0,a=le(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const u={x:a},d={depthRadius:e,bias:t,alpha:s,beta:r},p=z.runKernel(xp,u,d);return l?le(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const H$=M({localResponseNormalization_:Z_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_(n){const t={x:_(n,"x","log","float32")};return z.runKernel(Dl,t)}const Na=M({log_:J_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eO(n){const t={x:_(n,"x","log1p")};return z.runKernel(Al,t)}const _y=M({log1p_:eO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tO(n){return O(Vr(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const s=_(e,"x","tf.grad","string_or_numeric"),r=t!=null?_(t,"dy","tf.grad"):null;return z.tidy(()=>{const{value:o,grads:a}=z.gradients(()=>n(s),[s],r);return r!=null&&zt(o.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),$f(a),a[0]})}}function nO(n){return O(Vr(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{O(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=Hi(e,"args","tf.grads","string_or_numeric"),r=t!=null?_(t,"dy","tf.grads"):null;return z.tidy(()=>{const{value:o,grads:a}=z.gradients(()=>n(...s),s,r);return r!=null&&zt(o.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),$f(a),a})}}function sO(n){return O(Vr(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{O(e instanceof yt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),O(t==null||t instanceof yt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:r}=z.gradients(()=>n(e),[e],t);return $f(s),{grad:s[0],value:r}}}function rO(n){return O(Vr(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{O(Array.isArray(e)&&e.every(r=>r instanceof yt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),O(t==null||t instanceof yt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=z.gradients(()=>n(...e),e,t);return t!=null&&zt(s.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),$f(s.grads),s}}function j$(n,e){O(Vr(n),()=>"The f passed in variableGrads(f) must be a function"),O(e==null||Array.isArray(e)&&e.every(d=>d instanceof Gi),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const d in z.registeredVariables)e.push(z.registeredVariables[d])}const s=t?e.filter(d=>!d.trainable):null,r=e.length;e=e.filter(d=>d.trainable),O(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const o=!0,{value:a,grads:l}=z.gradients(n,e,null,o);O(l.some(d=>d!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),O(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const u={};return e.forEach((d,p)=>{l[p]!=null&&(u[d.name]=l[p])}),s!=null&&s.forEach(d=>u[d.name]=null),{value:a,grads:u}}function As(n){return z.customGrad(n)}function $f(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oO(n){const t={x:_(n,"x","neg")};return z.runKernel(Ip,t)}const ys=M({neg_:oO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aO(n){const t={x:_(n,"x","softplus")};return z.runKernel(eu,t)}const Oy=M({softplus_:aO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iO(n){const e=_(n,"x","logSigmoid");return As(s=>({value:ys(Oy(ys(s))),gradFunc:a=>xe(a,Co(ys(s)))}))(e)}const q$=M({logSigmoid_:iO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lO(n,e){let t=_(n,"a","sub"),s=_(e,"b","sub");[t,s]=ht(t,s);const r={a:t,b:s};return z.runKernel(ru,r)}const Fe=M({sub_:lO});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uO(n,e=-1){const t=_(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return As((r,o)=>{const l=ko(r,e,!0),u=Fe(r,l),d=Fe(at(u,"float32"),Na(rt(zr(u),e,!0)));return o([d]),{value:d,gradFunc:(f,m)=>{const[g]=m,x=!0,w=zr(g);return Fe(f,xe(rt(f,e,x),w))}}})(t)}const K$=M({logSoftmax_:uO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cO(n,e=null,t=!1){const s=_(n,"x","logSumExp"),r=Me(e,s.shape),o=ko(s,r,!0),a=Fe(s,o),l=zr(a),u=rt(l,r),d=Na(u),p=_e(le(o,d.shape),d);if(t){const f=It(p.shape,r);return le(p,f)}return p}const Dy=M({logSumExp_:cO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dO(n,e){const t=_(n,"a","logicalAnd","bool"),s=_(e,"b","logicalAnd","bool");Le(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(Fl,r)}const Xi=M({logicalAnd_:dO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pO(n){const t={x:_(n,"x","logicalNot","bool")};return z.runKernel(Pl,t)}const Ay=M({logicalNot_:pO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fO(n,e){const t=_(n,"a","logicalOr","bool"),s=_(e,"b","logicalOr","bool");Le(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(Ll,r)}const Fy=M({logicalOr_:fO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hO(n,e){const t=_(n,"a","logicalXor","bool"),s=_(e,"b","logicalXor","bool");return Le(t.shape,s.shape),Xi(Fy(n,e),Ay(Xi(n,e)))}const X$=M({logicalXor_:hO});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vc=2147483648;function mO(n,e,t="left"){const s=_(n,"sortedSequence","searchSorted"),r=_(e,"values","searchSorted"),o=s.shape[s.shape.length-1],a=r.shape[r.shape.length-1],l=le(s,[-1,o]),u=le(r,[-1,a]);if(l.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(l.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(oe(u.shape)>=Vc)throw new Error(`values tensor size must less than ${Vc}`);if(l.shape[1]>=Vc)throw new Error(`trailing dim_size must less than ${Vc} for int32 output type, was ${l.shape[1]}`);const d={sortedSequence:l,values:u},p={side:t};return z.runKernel(Kp,d,p)}const Sf=M({searchSorted_:mO});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$(n,e){return Sf(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gO(n,e,t,s,r){const o=_(n,"x","maxPool"),a=1;let l=o,u=!1;o.rank===3&&(u=!0,l=le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(l.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.rank}.`),O(Yt(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),ts("maxPool",s,r);const d={x:l},p={filterSize:e,strides:t,pad:s,dimRoundingMode:r},f=z.runKernel(wp,d,p);return u?le(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Py=M({maxPool_:gO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yO(n,e=[1,1,1],t,s,r,o="NDHWC"){const a=_(n,"x","maxPool3d");let l=a,u=!1;a.rank===4&&(u=!0,l=le(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),O(l.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${l.rank}.`),O(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),ts("maxPool3d",s,r);const d={x:l},p={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:o},f=z.runKernel(bp,d,p);return u?le(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const Q$=M({maxPool3d_:yO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xO(n,e,t,s,r=!1){const a={x:_(n,"x","maxPoolWithArgmax")},l={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},u=z.runKernel($p,a,l);return{result:u[0],indexes:u[1]}}const Z$=M({maxPoolWithArgmax_:xO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vO(n,e){let t=_(n,"a","maximum"),s=_(e,"b","maximum");[t,s]=ht(t,s),t.dtype==="bool"&&(t=at(t,"int32"),s=at(s,"int32")),Le(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(Vl,r)}const Ly=M({maximum_:vO});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wO(n,e=null,t=!1){const r={x:_(n,"x","mean")},o={axis:e,keepDims:t};return z.runKernel(Sp,r,o)}const Yi=M({mean_:wO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wr(n,e="float32"){if(_n(n),e==="complex64"){const s=Wr(n,"float32"),r=Wr(n,"float32");return nr(s,r)}const t=Mt(oe(n),e);return z.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ar(n,e="float32"){if(_n(n),e==="complex64"){const s=Ar(n,"float32"),r=Wr(n,"float32");return nr(s,r)}const t=Td(oe(n),e);return z.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=_(n,"x","meshgrid",n instanceof yt?n.dtype:"float32");if(e===void 0)return[s];let r=_(e,"y","meshgrid",e instanceof yt?e.dtype:"float32");const o=oe(s.shape),a=oe(r.shape);return t==="xy"?(s=le(s,[1,-1]),r=le(r,[-1,1]),[qe(Ar([a,1],s.dtype),s),qe(r,Ar([1,o],r.dtype))]):(s=le(s,[-1,1]),r=le(r,[1,-1]),[qe(s,Ar([1,a],s.dtype)),qe(Ar([o,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bO(n,e){let t=_(n,"a","minimum"),s=_(e,"b","minimum");[t,s]=ht(t,s),t.dtype==="bool"&&(t=at(t,"int32"),s=at(s,"int32")),Le(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(Bl,r)}const Qi=M({minimum_:bO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $O(n,e,t){O(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=_(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");O(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let l=0;l<s.rank;l++)O(e[l].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),O(e[l][0]>=0&&e[l][0]<=s.shape[l]-r&&e[l][1]>=0&&e[l][1]<=s.shape[l]-r,()=>`Padding in dimension ${l} cannot be greater than or equal to ${s.shape[l]-r} or less than 0 for input of shape ${s.shape}`);const o={paddings:e,mode:t},a={x:s};return z.runKernel(kp,a,o)}const eS=M({mirrorPad_:$O});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SO(n,e){let t=_(n,"a","mod"),s=_(e,"b","mod");[t,s]=ht(t,s);const r={a:t,b:s};return z.runKernel(Ml,r)}const tS=M({mod_:SO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CO(n,e=null,t=!1){n=_(n,"x","moments");const s=Me(e,n.shape),r=Yi(n,s,t);let o=r.shape;t||(o=It(r.shape,s));const a=Jn(Fe(at(n,"float32"),le(r,o))),l=Yi(a,s,t);return{mean:r,variance:l}}const nS=M({moments_:CO});function kO(n,e,t,s){const r=_(e,"data","multiRNNCell"),o=Hi(t,"c","multiRNNCell"),a=Hi(s,"h","multiRNNCell");let l=r;const u=[];for(let f=0;f<n.length;f++){const m=n[f](l,o[f],a[f]);u.push(m[0]),u.push(m[1]),l=m[1]}const d=[],p=[];for(let f=0;f<u.length;f+=2)d.push(u[f]),p.push(u[f+1]);return[d,p]}const sS=M({multiRNNCell_:kO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NO(n,e,t,s=!1){const r=_(n,"logits","multinomial"),o=r.size,a=r.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();const u={logits:a===1?le(r,[1,-1]):r},d={numSamples:e,seed:t,normalized:s},p=z.runKernel(Np,u,d);return a===1?le(p,[p.size]):p}const rS=M({multinomial_:NO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IO(n,e){let t=_(n,"a","notEqual","string_or_numeric"),s=_(e,"b","notEqual","string_or_numeric");[t,s]=ht(t,s),Le(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(Wl,r)}const Vy=M({notEqual_:IO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TO(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:_(n,"indices","oneHot","int32")},l={dtype:r,depth:e,onValue:t,offValue:s};return z.runKernel(Op,a,l)}const fd=M({oneHot_:TO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EO(n){const t={x:_(n,"x","onesLike")};return z.runKernel(_p,t)}const oS=M({onesLike_:EO});function RO(n,e){const t=_(n,"v1","outerProduct"),s=_(e,"v2","outerProduct");O(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=le(t,[-1,1]),o=le(s,[1,-1]);return qe(r,o)}const aS=M({outerProduct_:RO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _O(n,e,t=0){const s=_(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},o={x:s};return z.runKernel(Ap,o,r)}const La=M({pad_:_O});function OO(n,e,t=0){return O(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),La(n,[e],t)}const iS=M({pad1d_:OO});function DO(n,e,t=0){return O(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),La(n,e,t)}const lS=M({pad2d_:DO});function AO(n,e,t=0){return O(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),La(n,e,t)}const uS=M({pad3d_:AO});function FO(n,e,t=0){return O(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),La(n,e,t)}const cS=M({pad4d_:FO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PO(n,e,t){const s=_(n,"x","spaceToBatchND");O(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),O(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),O(s.shape.reduce((a,l,u)=>u>0&&u<=e.length?a&&(l+t[u-1][0]+t[u-1][1])%e[u-1]===0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},o={blockShape:e,paddings:t};return z.runKernel(Zp,r,o)}const By=M({spaceToBatchND_:PO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LO(n,e,t,s,r,o,a){r==null&&(r=[1,1]),o==null&&(o=1),s===0&&(s="valid");const l=_(n,"x","maxPool");let u=l,d=!1;l.rank===3&&(d=!0,u=le(l,[1,l.shape[0],l.shape[1],l.shape[2]])),O(Yt(o,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${r}'`);const p=es(u.shape,e,o,r,s),f=[p.dilationHeight,p.dilationWidth];let m;s==="same"?m=BO([p.filterHeight,p.filterWidth],f):m=[[0,0],[0,0]];const g=f[0]===1&&f[1]===1,[x,w]=VO([p.inHeight,p.inWidth],f,m),v=g?s:"valid",b=g?u:By(u,f,x),I=(t==="avg"?()=>vy(b,e,o,v,a):()=>Py(b,e,o,v,a))(),N=g?I:wy(I,f,w);return d?le(N,[N.shape[1],N.shape[2],N.shape[3]]):N}function VO(n,e,t){const s=t.map(p=>p[0]),r=t.map(p=>p[1]),o=n.concat(s,r),a=e.map((p,f)=>(p-o[f]%p)%p),l=r.map((p,f)=>p+a[f]),u=e.map((p,f)=>[s[f],l[f]]),d=e.map((p,f)=>[0,a[f]]);return[u,d]}function BO(n,e){const s=n.map((a,l)=>a+(a-1)*(e[l]-1)).map(a=>a-1),r=s.map(a=>Math.floor(a/2)),o=s.map((a,l)=>a-r[l]);return s.map((a,l)=>[r[l],o[l]])}const dS=M({pool_:LO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MO(n,e){const t=_(n,"x","prelu"),s=_(e,"alpha","prelu"),r={x:t,alpha:s};return z.runKernel(Fp,r)}const My=M({prelu_:MO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zO(n,e=null,t=!1){let s=_(n,"x","prod");s.dtype==="bool"&&(s=at(s,"int32"));const r={x:s},o={axis:e,keepDims:t};return z.runKernel(Pp,r,o)}const pS=M({prod_:zO});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WO(n,e,t,s){const r=n.map((p,f)=>_(p,`tensors${f}`,"raggedGather","int32")),o=_(e,"paramsDenseValues","raggedGather"),a=_(t,"indices","raggedGather","int32"),l={paramsNestedSplits:r,paramsDenseValues:o,indices:a},u={outputRaggedRank:s},d=z.runKernel(Lp,l,u);return{outputNestedSplits:d.slice(0,d.length-1),outputDenseValues:d[d.length-1]}}const fS=M({raggedGather_:WO});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UO(n,e,t){const s=_(n,"starts","raggedRange"),r=_(e,"limits","raggedRange",s.dtype),o=_(t,"deltas","raggedRange",s.dtype),a={starts:s,limits:r,deltas:o},l=z.runKernel(Vp,a);return{rtNestedSplits:l[0],rtDenseValues:l[1]}}const hS=M({raggedRange_:UO});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GO(n,e,t,s,r){const o=_(n,"shape","raggedTensorToTensor","int32"),a=_(e,"values","raggedTensorToTensor"),l=_(t,"defaultValue","raggedTensorToTensor",a.dtype),u=s.map((f,m)=>_(f,`tensors${m}`,"raggedTensorToTensor","int32")),d={shape:o,values:a,defaultValue:l,rowPartitionTensors:u},p={rowPartitionTypes:r};return z.runKernel(Bp,d,p)}const mS=M({raggedTensorToTensor_:GO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HO(n,e,t){_n(n);const s=oe(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let o=0;o<s;o++)r[o]=e();return z.makeTensor(r,n,t)}const gS=M({rand_:HO});var Yc={exports:{}},jO=Yc.exports,ow;function qO(){return ow||(ow=1,function(n){(function(e,t,s){function r(u){var d=this,p=l();d.next=function(){var f=2091639*d.s0+d.c*23283064365386963e-26;return d.s0=d.s1,d.s1=d.s2,d.s2=f-(d.c=f|0)},d.c=1,d.s0=p(" "),d.s1=p(" "),d.s2=p(" "),d.s0-=p(u),d.s0<0&&(d.s0+=1),d.s1-=p(u),d.s1<0&&(d.s1+=1),d.s2-=p(u),d.s2<0&&(d.s2+=1),p=null}function o(u,d){return d.c=u.c,d.s0=u.s0,d.s1=u.s1,d.s2=u.s2,d}function a(u,d){var p=new r(u),f=d&&d.state,m=p.next;return m.int32=function(){return p.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,f&&(typeof f=="object"&&o(f,p),m.state=function(){return o(p,{})}),m}function l(){var u=4022871197,d=function(p){p=String(p);for(var f=0;f<p.length;f++){u+=p.charCodeAt(f);var m=.02519603282416938*u;u=m>>>0,m-=u,m*=u,u=m>>>0,m-=u,u+=m*4294967296}return(u>>>0)*23283064365386963e-26};return d}t&&t.exports?t.exports=a:this.alea=a})(jO,n)}(Yc)),Yc.exports}var Qc={exports:{}},KO=Qc.exports,aw;function XO(){return aw||(aw=1,function(n){(function(e,t,s){function r(l){var u=this,d="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var f=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^f^f>>>8},l===(l|0)?u.x=l:d+=l;for(var p=0;p<d.length+64;p++)u.x^=d.charCodeAt(p)|0,u.next()}function o(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u}function a(l,u){var d=new r(l),p=u&&u.state,f=function(){return(d.next()>>>0)/4294967296};return f.double=function(){do var m=d.next()>>>11,g=(d.next()>>>0)/4294967296,x=(m+g)/(1<<21);while(x===0);return x},f.int32=d.next,f.quick=f,p&&(typeof p=="object"&&o(p,d),f.state=function(){return o(d,{})}),f}t&&t.exports?t.exports=a:this.xor128=a})(KO,n)}(Qc)),Qc.exports}var Zc={exports:{}},YO=Zc.exports,iw;function QO(){return iw||(iw=1,function(n){(function(e,t,s){function r(l){var u=this,d="";u.next=function(){var f=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(f^f<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,l===(l|0)?u.x=l:d+=l;for(var p=0;p<d.length+64;p++)u.x^=d.charCodeAt(p)|0,p==d.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function o(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u.v=l.v,u.d=l.d,u}function a(l,u){var d=new r(l),p=u&&u.state,f=function(){return(d.next()>>>0)/4294967296};return f.double=function(){do var m=d.next()>>>11,g=(d.next()>>>0)/4294967296,x=(m+g)/(1<<21);while(x===0);return x},f.int32=d.next,f.quick=f,p&&(typeof p=="object"&&o(p,d),f.state=function(){return o(d,{})}),f}t&&t.exports?t.exports=a:this.xorwow=a})(YO,n)}(Zc)),Zc.exports}var Jc={exports:{}},ZO=Jc.exports,lw;function JO(){return lw||(lw=1,function(n){(function(e,t,s){function r(l){var u=this;u.next=function(){var p=u.x,f=u.i,m,g;return m=p[f],m^=m>>>7,g=m^m<<24,m=p[f+1&7],g^=m^m>>>10,m=p[f+3&7],g^=m^m>>>3,m=p[f+4&7],g^=m^m<<7,m=p[f+7&7],m=m^m<<13,g^=m^m<<9,p[f]=g,u.i=f+1&7,g};function d(p,f){var m,g=[];if(f===(f|0))g[0]=f;else for(f=""+f,m=0;m<f.length;++m)g[m&7]=g[m&7]<<15^f.charCodeAt(m)+g[m+1&7]<<13;for(;g.length<8;)g.push(0);for(m=0;m<8&&g[m]===0;++m);for(m==8?g[7]=-1:g[m],p.x=g,p.i=0,m=256;m>0;--m)p.next()}d(u,l)}function o(l,u){return u.x=l.x.slice(),u.i=l.i,u}function a(l,u){l==null&&(l=+new Date);var d=new r(l),p=u&&u.state,f=function(){return(d.next()>>>0)/4294967296};return f.double=function(){do var m=d.next()>>>11,g=(d.next()>>>0)/4294967296,x=(m+g)/(1<<21);while(x===0);return x},f.int32=d.next,f.quick=f,p&&(p.x&&o(p,d),f.state=function(){return o(d,{})}),f}t&&t.exports?t.exports=a:this.xorshift7=a})(ZO,n)}(Jc)),Jc.exports}var ed={exports:{}},eD=ed.exports,uw;function tD(){return uw||(uw=1,function(n){(function(e,t,s){function r(l){var u=this;u.next=function(){var p=u.w,f=u.X,m=u.i,g,x;return u.w=p=p+1640531527|0,x=f[m+34&127],g=f[m=m+1&127],x^=x<<13,g^=g<<17,x^=x>>>15,g^=g>>>12,x=f[m]=x^g,u.i=m,x+(p^p>>>16)|0};function d(p,f){var m,g,x,w,v,b=[],C=128;for(f===(f|0)?(g=f,f=null):(f=f+"\0",g=0,C=Math.max(C,f.length)),x=0,w=-32;w<C;++w)f&&(g^=f.charCodeAt((w+32)%f.length)),w===0&&(v=g),g^=g<<10,g^=g>>>15,g^=g<<4,g^=g>>>13,w>=0&&(v=v+1640531527|0,m=b[w&127]^=g+v,x=m==0?x+1:0);for(x>=128&&(b[(f&&f.length||0)&127]=-1),x=127,w=4*128;w>0;--w)g=b[x+34&127],m=b[x=x+1&127],g^=g<<13,m^=m<<17,g^=g>>>15,m^=m>>>12,b[x]=g^m;p.w=v,p.X=b,p.i=x}d(u,l)}function o(l,u){return u.i=l.i,u.w=l.w,u.X=l.X.slice(),u}function a(l,u){l==null&&(l=+new Date);var d=new r(l),p=u&&u.state,f=function(){return(d.next()>>>0)/4294967296};return f.double=function(){do var m=d.next()>>>11,g=(d.next()>>>0)/4294967296,x=(m+g)/(1<<21);while(x===0);return x},f.int32=d.next,f.quick=f,p&&(p.X&&o(p,d),f.state=function(){return o(d,{})}),f}t&&t.exports?t.exports=a:this.xor4096=a})(eD,n)}(ed)),ed.exports}var td={exports:{}},nD=td.exports,cw;function sD(){return cw||(cw=1,function(n){(function(e,t,s){function r(l){var u=this,d="";u.next=function(){var f=u.b,m=u.c,g=u.d,x=u.a;return f=f<<25^f>>>7^m,m=m-g|0,g=g<<24^g>>>8^x,x=x-f|0,u.b=f=f<<20^f>>>12^m,u.c=m=m-g|0,u.d=g<<16^m>>>16^x,u.a=x-f|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,l===Math.floor(l)?(u.a=l/4294967296|0,u.b=l|0):d+=l;for(var p=0;p<d.length+20;p++)u.b^=d.charCodeAt(p)|0,u.next()}function o(l,u){return u.a=l.a,u.b=l.b,u.c=l.c,u.d=l.d,u}function a(l,u){var d=new r(l),p=u&&u.state,f=function(){return(d.next()>>>0)/4294967296};return f.double=function(){do var m=d.next()>>>11,g=(d.next()>>>0)/4294967296,x=(m+g)/(1<<21);while(x===0);return x},f.int32=d.next,f.quick=f,p&&(typeof p=="object"&&o(p,d),f.state=function(){return o(d,{})}),f}t&&t.exports?t.exports=a:this.tychei=a})(nD,n)}(td)),td.exports}var nd={exports:{}};const rD={},oD=Object.freeze(Object.defineProperty({__proto__:null,default:rD},Symbol.toStringTag,{value:"Module"})),aD=Ug(oD);var iD=nd.exports,dw;function lD(){return dw||(dw=1,function(n){(function(e,t,s){var r=256,o=6,a=52,l="random",u=s.pow(r,o),d=s.pow(2,a),p=d*2,f=r-1,m;function g(N,R,D){var F=[];R=R==!0?{entropy:!0}:R||{};var V=b(v(R.entropy?[N,I(t)]:N??C(),3),F),P=new x(F),A=function(){for(var T=P.g(o),W=u,j=0;T<d;)T=(T+j)*r,W*=r,j=P.g(1);for(;T>=p;)T/=2,W/=2,j>>>=1;return(T+j)/W};return A.int32=function(){return P.g(4)|0},A.quick=function(){return P.g(4)/4294967296},A.double=A,b(I(P.S),t),(R.pass||D||function(T,W,j,Y){return Y&&(Y.S&&w(Y,P),T.state=function(){return w(P,{})}),j?(s[l]=T,W):T})(A,V,"global"in R?R.global:this==s,R.state)}function x(N){var R,D=N.length,F=this,V=0,P=F.i=F.j=0,A=F.S=[];for(D||(N=[D++]);V<r;)A[V]=V++;for(V=0;V<r;V++)A[V]=A[P=f&P+N[V%D]+(R=A[V])],A[P]=R;(F.g=function(T){for(var W,j=0,Y=F.i,Q=F.j,Z=F.S;T--;)W=Z[Y=f&Y+1],j=j*r+Z[f&(Z[Y]=Z[Q=f&Q+W])+(Z[Q]=W)];return F.i=Y,F.j=Q,j})(r)}function w(N,R){return R.i=N.i,R.j=N.j,R.S=N.S.slice(),R}function v(N,R){var D=[],F=typeof N,V;if(R&&F=="object")for(V in N)try{D.push(v(N[V],R-1))}catch{}return D.length?D:F=="string"?N:N+"\0"}function b(N,R){for(var D=N+"",F,V=0;V<D.length;)R[f&V]=f&(F^=R[f&V]*19)+D.charCodeAt(V++);return I(R)}function C(){try{var N;return m&&(N=m.randomBytes)?N=N(r):(N=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(N)),I(N)}catch{var R=e.navigator,D=R&&R.plugins;return[+new Date,e,D,e.screen,I(t)]}}function I(N){return String.fromCharCode.apply(0,N)}if(b(s.random(),t),n.exports){n.exports=g;try{m=aD}catch{}}else s["seed"+l]=g})(typeof self<"u"?self:iD,[],Math)}(nd)),nd.exports}var Xm,pw;function uD(){if(pw)return Xm;pw=1;var n=qO(),e=XO(),t=QO(),s=JO(),r=tD(),o=sD(),a=lD();return a.alea=n,a.xor128=e,a.xorwow=t,a.xorshift7=s,a.xor4096=r,a.tychei=o,Xm=a,Xm}var Cf=uD();/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cD=.001,yS=.1;function dD(n,e,t){return t==null&&(t=zy()),bg(n,e,(s,r)=>Wy(s,r,t))}function zy(){return z.backend.floatPrecision()===32?cD:yS}function bg(n,e,t){let s=!0;if((Ot(n)||Ot(e))&&(s=!1),Ot(n)&&Ot(e)&&(s=!0),s){const a=n.constructor.name,l=e.constructor.name;if(a!==l)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${l}`)}if(Array.isArray(n)&&Array.isArray(e)){const a=Os(n),l=Os(e);if(!Qe(a,l))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${l}]`)}const r=Ot(n)?n:_s(n),o=Ot(e)?e:_s(e);if(r.length!==o.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${o.length}.
Actual:   ${r}.
Expected: ${o}.`);for(let a=0;a<o.length;++a){const l=r[a],u=o[a];if(!t(l,u))throw new Error(`Arrays differ: actual[${a}] = ${l}, expected[${a}] = ${u}.
Actual:   ${r}.
Expected: ${o}.`)}typeof expect<"u"&&expect().nothing()}function pD(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function fD(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return Is(n)||Is(n[0])||Is(e)||Is(e[0])?bg(n,t,(s,r)=>s==r):bg(n,e,(s,r)=>Wy(s,r,0))}function hD(n,e,t){if(t==null&&(t=zy()),!Wy(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function Wy(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function mD(n,e,t){for(let s=0;s<n.length;s++)if(n[s]<e||n[s]>t)throw new Error(`Value out of range:${n[s]} low: ${e}, high: ${t}`)}function gD(n,e){const t=new Float32Array(n),s=new Float32Array(e);if(t.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${t.length}`);for(let r=0;r<s.length;r++)if(t[r]!==s[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${s[r]} but got ${t[r]} instead`)}function xS(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?xS(t):n[e]=Es(t)}return n}function yD(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",s=>t(e)),e.load()})}async function xD(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const vD=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:yS,createVideoElement:yD,encodeStrings:xS,expectArrayBuffersEqual:gD,expectArraysClose:dD,expectArraysEqual:fD,expectNumbersClose:hD,expectPromiseToFail:pD,expectValuesInRange:mD,play:xD,testEpsilon:zy},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uy{constructor(e,t,s,r,o){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=o||Math.random();this.random=Cf.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,o,a;do r=2*this.random()-1,o=2*this.random()-1,a=r*r+o*o;while(a>=1||a===0);const l=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*l,t=this.mean+this.stdDev*o*l,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class wD{constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const o=r||Math.random();this.randu=Cf.alea(o.toString()),this.randn=new Uy(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,o,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-a+Math.log(a)),o=this.randu(),o<t||Math.log(o)<s)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class bD{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Cf.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $D(n,e,t=1,s="float32",r){if(_n(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const o=new wD(e,t,s,r),a=Ae(n,s);for(let l=0;l<a.values.length;l++)a.values[l]=o.nextValue();return a.toTensor()}const vS=M({randomGamma_:$D});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SD(n,e=0,t=1,s,r){if(_n(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const o=new Uy(e,t,s,!1,r),a=Ae(n,s);for(let l=0;l<a.values.length;l++)a.values[l]=o.nextValue();return a.toTensor()}const Gy=M({randomNormal_:SD});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CD(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return Gy(n,0,1,e,t)}const wS=M({randomStandardNormal_:CD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kD(n,e=0,t=1,s="float32",r){_n(n);const o=Ae(n,s),a=new bD(e,t,null,r);for(let l=0;l<o.values.length;l++)o.values[l]=a.nextValue();return o.toTensor()}const kf=M({randomUniform_:kD});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ND(n,e,t,s){return kf(n,e,t,"int32",s)}const bS=M({randomUniformInt_:ND});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ia(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return z.runKernel(Mp,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ID(n){const t={input:_(n,"input","real")};return z.runKernel(zp,t)}const Ta=M({real_:ID});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TD(n){const t={x:_(n,"x","reciprocal")};return z.runKernel(Gl,t)}const $S=M({reciprocal_:TD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ED(n){const t={x:_(n,"x","relu")};return z.runKernel(Hl,t)}const xu=M({relu_:ED});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RD(n){const t={x:_(n,"x","relu6")};return z.runKernel(jl,t)}const Hy=M({relu6_:RD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _D(n,e){const s={x:_(n,"x","reverse")},r={dims:e};return z.runKernel(Hp,s,r)}const Ur=M({reverse_:_D});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OD(n){const e=_(n,"x","reverse");return O(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Ur(e,0)}const SS=M({reverse1d_:OD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DD(n,e){const t=_(n,"x","reverse");return O(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Ur(t,e)}const CS=M({reverse2d_:DD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AD(n,e){const t=_(n,"x","reverse");return O(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Ur(t,e)}const kS=M({reverse3d_:AD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FD(n,e){const t=_(n,"x","reverse");return O(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Ur(t,e)}const NS=M({reverse4d_:FD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PD(n){const t={x:_(n,"x","round")};return z.runKernel(ql,t)}const jy=M({round_:PD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LD(n){const t={x:_(n,"x","rsqrt","float32")};return z.runKernel(Kl,t)}const IS=M({rsqrt_:LD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VD(n){const t={x:_(n,"x","selu")};return z.runKernel(Xl,t)}const TS=M({selu_:VD});function BD(n,e,t,s,r,o=[1,1],a="NHWC"){const l=_(n,"x","separableConv2d"),u=_(e,"depthwiseFilter","separableConv2d"),d=_(t,"pointwiseFilter","separableConv2d");let p=l,f=!1;if(l.rank===3&&(f=!0,p=le(l,[1,l.shape[0],l.shape[1],l.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");O(p.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),O(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),O(d.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),O(d.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${d.shape[0]}.`),O(d.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${d.shape[1]}.`);const m=u.shape[2],g=u.shape[3];O(d.shape[2]===m*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*g}, but got ${d.shape[2]}.`);const x=wf(p,u,s,r,a,o),v=fu(x,d,1,"valid",a);return f?le(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const ES=M({separableConv2d_:BD});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function MD(n,e){const t=_(n,"x","setdiff1d"),s=_(e,"y","setdiff1d");O(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),O(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),O(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),o=await s.data(),a=new Set(o);let l=0;for(let p=0;p<r.length;p++)a.has(r[p])||l++;const u=new kt([l],t.dtype),d=new kt([l],"int32");for(let p=0,f=0;p<r.length;p++)a.has(r[p])||(u.values[f]=r[p],d.values[f]=p,f++);return[u.toTensor(),d.toTensor()]}const RS=MD;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zD(n){const t={x:_(n,"x","sign")};return z.runKernel(Zl,t)}const _S=M({sign_:zD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WD(n){const t={x:_(n,"x","sin","float32")};return z.runKernel(Yl,t)}const OS=M({sin_:WD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UD(n){const t={x:_(n,"x","sinh")};return z.runKernel(Ql,t)}const DS=M({sinh_:UD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GD(n,e,t){const s=_(n,"x","slice1d");return O(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),tt(s,[e],[t])}const AS=M({slice1d_:GD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HD(n,e,t){const s=_(n,"x","slice2d");return O(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),tt(s,e,t)}const FS=M({slice2d_:HD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jD(n,e,t){const s=_(n,"x","slice3d");return O(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),tt(s,e,t)}const PS=M({slice3d_:jD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qD(n,e,t){const s=_(n,"x","slice4d");return O(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),tt(s,e,t)}const LS=M({slice4d_:qD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KD(n,e=-1){const t=_(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return z.runKernel(ef,s,r)}const VS=M({softmax_:KD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XD(n){O(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return z.runKernel(lp,e)}const Nf=M({fft_:XD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YD(n){O(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return z.runKernel(hp,e)}const Zi=M({ifft_:YD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QD(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=le(n,[t,e]);s=Zi(r)}else{const r=[t,2*(e-1)],o=le(Ta(n),[t,e]),a=le(yu(n),[t,e]),l=Ur(tt(o,[0,1],[t,e-2]),1),u=xe(Ur(tt(a,[0,1],[t,e-2]),1),Ve(-1)),d=Xt([o,l],1),p=Xt([a,u],1),f=le(nr(d,p),[r[0],r[1]]);s=Zi(f)}if(s=Ta(s),n.rank===3&&n.shape[0]!==0){const r=s,o=n.shape[0];s=le(s,[o,s.shape[0]/o,s.shape[1]]),r.dispose()}return s}const qy=M({irfft_:QD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZD(n,e,t=0){const r={x:_(n,"x","split")},o={numOrSizeSplits:e,axis:t};return z.runKernel(Jp,r,o)}const Ea=M({split_:ZD});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JD(n,e){O(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const x=n.shape.map(v=>0),w=n.shape.map(v=>v);w[n.shape.length-1]=e,r=tt(n,x,w),t=e}else if(e!=null&&e>t){const x=n.shape.map(w=>w);x[n.shape.length-1]=e-t,r=Xt([n,Wr(x)],n.shape.length-1),t=e}else r=n;const o=En(r),a=le(nr(r,o),[s,t]),l=Nf(a),u=Math.floor(t/2)+1,d=Ta(l),p=yu(l),f=Ea(d,[u,t-u],d.shape.length-1),m=Ea(p,[u,t-u],p.shape.length-1),g=r.shape.slice();return g[r.shape.length-1]=u,le(nr(f[0],m[0]),g)}const If=M({rfft_:JD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eA(n,e){let t=_(n,"a","squaredDifference"),s=_(e,"b","squaredDifference");[t,s]=ht(t,s),Le(t.shape,s.shape);const r={a:t,b:s},o={};return z.runKernel(nu,r,o)}const Ky=M({squaredDifference_:eA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tA(n,e){const t=_(n,"x","squeeze","string_or_numeric");return le(t,or(t.shape,e).newShape)}const Tf=M({squeeze_:tA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nA(n,e=0){const t=Hi(n,"tensors","stack","string_or_numeric");O(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&O(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return z.runKernel(Dp,s,r)}const Fs=M({stack_:nA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sA(n,e=0){const s={x:_(n,"x","step")},r={alpha:e};return z.runKernel(lu,s,r)}const Xy=M({step_:sA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rA(n,e,t,s,r=0,o=0,a=0,l=0,u=0){const p={x:_(n,"x","stridedSlice","string_or_numeric")},f={begin:e,end:t,strides:s,beginMask:r,endMask:o,ellipsisMask:a,newAxisMask:l,shrinkAxisMask:u};return z.runKernel(af,p,f)}const BS=M({stridedSlice_:rA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oA(n){const t={x:_(n,"x","tan","float32")};return z.runKernel(ou,t)}const MS=M({tan_:oA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bn(n,e){Lo(n);const t=Os(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return jr(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $a(n,e,t){if(Lo(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Os(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return jr(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yy(n,e,t){if(Lo(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Os(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return jr(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zS(n,e,t){if(Lo(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=Os(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return jr(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WS(n,e,t){if(Lo(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=Os(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return jr(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function US(n,e,t){if(Lo(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=Os(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,jr(n,e,s,t)}function Qy(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(o+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(o+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(o+` update.rank != ${r+n.length-s}`);for(let a=0;a<r;++a)if(t.shape[a]!==e.shape[a])throw new Error(o+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-r;++a)if(t.shape[a+r]!==n[a+s])throw new Error(o+` updates.shape[${a+r}] (${t.shape[a+r]}) != shape[${a+r}] (${n[a+r]})`)}function Ef(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Qy(t,e,n)}function Kr(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,o=t.length;let a=1;for(let f=r;f<o;++f)a*=t[f];const l=r<1?1:r,u=oe(e.shape)/l,d=[...Ie(t.slice(0,r)),1],p=oe(t);return{sliceRank:r,numUpdates:u,sliceSize:a,strides:d,outputSize:p}}const aA=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:Kr,validateInput:Ef,validateUpdateShape:Qy},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iA(n,e,t){const s=_(n,"tensor","tensorScatterupdate"),r=_(e,"indices","tensorScatterupdate","int32"),o=_(t,"updates","tensorScatterupdate");if(Ef(o,r,s.shape),s.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${o.dtype}.`);const a={tensor:s,indices:r,updates:o},l={};return z.runKernel(qp,a,l)}const GS=M({tensorScatterUpdate_:iA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lA(n,e=1,t=!0){const s=_(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const o={x:s},a={k:e,sorted:t},[l,u]=z.runKernel(df,o,a);return{values:l,indices:u}}const HS=M({topk_:lA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uA(n,e=0,t=1,s,r){if(_n(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new Uy(e,t,s,!0,r),a=Ae(n,s);for(let l=0;l<a.values.length;l++)a.values[l]=o.nextValue();return a.toTensor()}const jS=M({truncatedNormal_:uA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cA(n,e=0){const t=_(n,"x","unique","string_or_numeric");O(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[o,a]=z.runKernel(ff,s,r);return{values:o,indices:a}}const qS=M({unique_:cA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dA(n,e,t){const s=_(n,"x","unsortedSegmentSum"),r=_(e,"segmentIds","unsortedSegmentSum","int32");O(No(t),()=>"numSegments must be of dtype int");const o={x:s,segmentIds:r},a={numSegments:t};return z.runKernel(mf,o,a)}const KS=M({unsortedSegmentSum_:dA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pA(n,e=0){const t=_(n,"x","unstack","string_or_numeric");O(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return z.runKernel(hf,s,r)}const Xr=M({unstack_:pA});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XS(n,e){return Sf(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YS(n,e=!0,t,s){return z.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rf(n,e){const t=[];for(let o=0;o<e.length;o++)e[o]&&t.push(o);const s=Ae(n,"int32"),r=Ae([t.length,n.length],"int32");for(let o=0;o<t.length;o++){const a=s.indexToLoc(t[o]),l=o*n.length;r.values.set(a,l)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function fA(n){const e=_(n,"condition","whereAsync","bool"),t=await e.data(),s=Rf(e.shape,t);return n!==e&&e.dispose(),s}const Zy=fA;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function hA(n,e,t){const s=_(n,"tensor","boolMask"),r=_(e,"mask","boolMask","bool"),o=t??0,a=r.rank,l=s.shape;O(a>0,()=>"mask cannot be scalar"),zt(l.slice(o,o+a),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let w=o;w<o+a;w++)u*=l[w];const d=l.slice(0,o).concat([u],l.slice(o+a)),p=le(s,d),f=le(r,[-1]),m=await Zy(f),g=Tf(m,[1]),x=Ty(p,g,o);return n!==s&&s.dispose(),e!==r&&r.dispose(),g.dispose(),p.dispose(),f.dispose(),m.dispose(),x}const QS=hA;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mA(n,e,t){const s=_(n,"x","transpose");if(e==null&&(e=s.shape.map((a,l)=>l).reverse()),O(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(a=>{O(a>=0&&a<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},o={perm:e};return s.dtype==="complex64"?Ue(()=>{let a=Ta(s),l=yu(s);return a=z.runKernel(ya,{x:a},o),l=z.runKernel(ya,{x:l},o),t&&(l=ys(l)),nr(a,l)}):z.runKernel(ya,r,o)}const Ji=M({transpose_:mA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gA(n,e,t,s,r=!0){const o=_(n,"v","movingAverage"),a=_(e,"x","movingAverage"),l=_(t,"decay","movingAverage");Ob(o,a),O(Qe(o.shape,a.shape),()=>"Shape mismatch in v and x");const u=Ve(1),d=Fe(u,l);let p=xe(Fe(a,o),d);if(r){O(s!=null,()=>"When using zeroDebias: true, step is required.");const f=_(s,"step","movingAverage");p=ot(p,Fe(u,ka(l,f)))}return _e(o,p)}const ZS=M({movingAverage_:gA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yA(n,e,t){_n(t);const s=_(n,"indices","scatterND","int32"),r=_(e,"updates","scatterND");Ef(r,s,t);const o={indices:s,updates:r},a={shape:t};return z.runKernel(jp,o,a)}const JS=M({scatterND_:yA});function xA(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(t.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${o}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vA(n,e,t,s=0){_n(t);const r=_(n,"sparseIndices","sparseToDense","int32"),o=_(e,"sparseValues","sparseToDense","string_or_numeric"),a=_(s,"defaultValue","sparseToDense",o.dtype);xA(r,o,t,a);const l={sparseIndices:r,sparseValues:o,defaultValue:a},u={outputShape:t};return z.runKernel(of,l,u)}const eC=M({sparseToDense_:vA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wA(n,e){const t=_(e,"indices","gatherND","int32"),r={params:_(n,"x","gatherND","string_or_numeric"),indices:t};return z.runKernel(fp,r)}const tC=M({gatherND_:wA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bA(n,e){if(e==null)return n.shape.slice();if(Qe(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $A(n,e,t,s){const r=_(n,"x","dropout");if(O(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),O(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof yt?r.clone():r;const o=bA(r,t),a=1-e,l=ot(Iy(_e(kf(o,0,1,"float32",s),a)),a);return xe(r,l)}const nC=M({dropout_:$A});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jy(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function _f(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let o=0;o<n;++o){const a=2*Math.PI*o/(n+s-1);r[o]=e-t*Math.cos(a)}return Bn(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function SA(n,e,t=1){const s=_(n,"predictions","inTopK"),r=_(e,"targets","inTopK");O(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),O(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),zt(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=s.shape[s.shape.length-1];O(t>0&&t<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${t}`);const a=await s.data(),l=await r.data(),[u,d]=[a.length/o,o],p=Dt("bool",u);for(let f=0;f<u;f++){const m=f*d,g=a.subarray(m,m+d),x=[];for(let w=0;w<g.length;w++)x.push({value:g[w],index:w});x.sort((w,v)=>v.value-w.value),p[f]=0;for(let w=0;w<t;w++)if(x[w].index===l[f]){p[f]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),gs(p,r.shape,"bool")}const sC=SA;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CA(n,e,t,s,r,o="NHWC",a){let l=n;n.rank===3&&(l=le(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=le(e,[1,e.shape[0],e.shape[1],e.shape[2]])),O(l.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${l.shape}.`),O(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),O(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const d=o==="NHWC"?l.shape[3]:l.shape[1],p=o==="NHWC"?u.shape[3]:u.shape[1];O(d===t[2],()=>`Error in conv2dDerFilter: depth of input ${d}) must match input depth in filter (${t[2]}.`),O(p===t[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${t[3]}).`),ts("conv2dDerFilter",r,a);const f={x:l,dy:u},m={strides:s,pad:r,dataFormat:o,dimRoundingMode:a,filterShape:t};return z.runKernel(Hd,f,m)}const kA=M({conv2DBackpropFilter_:CA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Of(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return xe(n,Xy(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Df(n,e){let t=e;const s=$y(n.shape,e.shape);return s.length>0&&(t=rt(t,s)),le(t,n.shape)}function Af(n,e,t,s){if(e==="linear")return n;if(e==="relu")return xu(n);if(e==="elu")return Cy(n);if(e==="relu6")return Hy(n);if(e==="prelu")return My(n,t);if(e==="leakyrelu")return Ry(n,s);if(e==="sigmoid")return Co(n);throw new Error(`Unknown fused activation ${e}.`)}const Ff=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NA({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:l,activation:u="linear",preluActivationWeights:d,leakyreluAlpha:p}){if(u=u||"linear",Ff(z.state.gradientDepth,u)===!1){O(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let D=fu(n,e,t,s,r,o,a);return l!=null&&(D=_e(D,l)),Af(D,u,d,p)}const f=_(n,"x","conv2d","float32"),m=_(e,"filter","conv2d","float32");let g=f,x=!1;f.rank===3&&(x=!0,g=le(f,[1,f.shape[0],f.shape[1],f.shape[2]])),O(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),O(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),ts("fused conv2d",s,a);const w=r==="NHWC"?g.shape[3]:g.shape[1];O(m.shape[2]===w,()=>`Error in conv2d: depth of input (${w}) must match input depth for filter ${m.shape[2]}.`),O(Yt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const v=At(g.shape,m.shape,t,o,s,a);let b;l!=null&&(b=_(l,"bias","fused conv2d"),[b]=ht(b,f),r==="NHWC"?Le(v.outShape,b.shape):(O(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),O(b.shape.length===0||b.shape[0]===v.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${v.outChannels})`)));let C;if(d!=null){const D=d.shape;if(O(D.length<=1||D.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${D.length}.`),D.length===1)O(D[0]===1||D[0]===v.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${D}) is not compatible with the number of output channels (${v.outChannels}).`);else if(D.length===3)try{Le(D,v.outShape)}catch{const V=`Error in fused conv2d: PReLU activation weights (${D}) is not compatible with the output shape of the conv2d (${v.outShape}).`;throw Error(V)}C=_(d,"prelu weights","fused conv2d")}const I=(D,F)=>{O(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[V,P,A,T]=F,W=Of(D,A,u);O(Ki(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const j=b$(P.shape,W,V,t,s),Y=kA(P,W,V.shape,t,s),Q=[j,Y];if(T!=null){const Z=Df(T,W);Q.push(Z)}return Q},N={x:g,filter:m,bias:b,preluActivationWeights:C},R={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a,activation:u,leakyreluAlpha:p};return l==null?As((F,V,P)=>{let A=z.runKernel(Mi,N,R);return P([V,F,A]),x&&(A=le(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:I}})(g,m):As((F,V,P,A)=>{let T=z.runKernel(Mi,N,R);return A([V,F,T,P]),x&&(T=le(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:I}})(g,m,b)}const IA=M({fusedConv2d_:NA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TA(n,e,t,s,r,o=[1,1],a){let l=n;n.rank===3&&(l=le(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=le(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const d={x:l,dy:u},p={strides:s,pad:r,dimRoundingMode:a,dilations:o,filterShape:t};return z.runKernel(tp,d,p)}const EA=M({depthwiseConv2dNativeBackpropFilter_:TA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RA(n,e,t,s,r,o=[1,1],a){let l=e,u=!1;e.rank===3&&(u=!0,l=le(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const d={dy:l,filter:t},p={strides:s,pad:r,dimRoundingMode:a,dilations:o,inputShape:n},f=z.runKernel(np,d,p);return u?le(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const _A=M({depthwiseConv2dNativeBackpropInput_:RA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OA({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:l,activation:u="linear",preluActivationWeights:d,leakyreluAlpha:p}){if(Ff(z.state.gradientDepth,u)===!1){let R=wf(n,e,t,s,r,o,a);return l!=null&&(R=_e(R,l)),Af(R,u,d,p)}const f=_(n,"x","depthwiseConv2d","float32"),m=_(e,"filter","depthwiseConv2d","float32");let g=f,x=!1;f.rank===3&&(x=!0,g=le(f,[1,f.shape[0],f.shape[1],f.shape[2]])),O(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),O(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),O(g.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),o==null&&(o=[1,1]),O(Yt(t,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),ts("fused depthwiseConv2d",s,a);const w=At(g.shape,m.shape,t,o,s,a,!0);let v;l!=null&&(v=_(l,"bias","fused conv2d"),[v]=ht(v,f),Le(w.outShape,v.shape));let b;d!=null&&(b=_(d,"prelu weights","fused depthwiseConv2d"));const C=(R,D)=>{O(Ki(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[F,V,P,A]=D,T=Of(R,P,u),W=_A(V.shape,T,F,t,s,o,a),j=EA(V,T,F.shape,t,s,o,a);if(A!=null){const Y=Df(v,T);return[W,j,Y]}return[W,j]},I={x:g,filter:m,bias:v,preluActivationWeights:b},N={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a,activation:u,leakyreluAlpha:p};return l==null?As((D,F,V)=>{let P=z.runKernel(zi,I,N);return V([F,D,P]),x&&(P=le(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:C}})(g,m):As((D,F,V,P)=>{let A=z.runKernel(zi,I,N);return P([F,D,A,V]),x&&(A=le(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:C}})(g,m,v)}const DA=M({fusedDepthwiseConv2d_:OA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AA({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:o="linear",preluActivationWeights:a,leakyreluAlpha:l=.2}){if(Ff(z.state.gradientDepth,o)===!1){let T=qe(n,e,t,s);return r!=null&&(T=_e(T,r)),Af(T,o,a,l)}let u=_(n,"a","fused matMul"),d=_(e,"b","fused matMul");[u,d]=ht(u,d);const p=t?u.shape[u.rank-2]:u.shape[u.rank-1],f=s?d.shape[d.rank-1]:d.shape[d.rank-2],m=t?u.shape[u.rank-1]:u.shape[u.rank-2],g=s?d.shape[d.rank-2]:d.shape[d.rank-1],x=u.shape.slice(0,-2),w=d.shape.slice(0,-2),v=oe(x),b=oe(w);O(p===f,()=>`Error in fused matMul: inner shapes (${p}) and (${f}) of Tensors with shapes ${u.shape} and ${d.shape} and transposeA=${t} and transposeB=${s} must match.`);const I=Le(u.shape.slice(0,-2),d.shape.slice(0,-2)).concat([m,g]),N=t?le(u,[v,p,m]):le(u,[v,m,p]),R=s?le(d,[b,g,f]):le(d,[b,f,g]);let D;r!=null&&(D=_(r,"bias","fused matMul"),[D]=ht(D,u),Le(I,D.shape));let F;a!=null&&(F=_(a,"prelu weights","fused matMul"));const V=(T,W)=>{const[j,Y,Q,Z]=W,ne=Of(le(T,Q.shape),Q,o);let U,K;if(!t&&!s?(U=qe(ne,Y,!1,!0),K=qe(j,ne,!0,!1)):!t&&s?(U=qe(ne,Y,!1,!1),K=qe(ne,j,!0,!1)):t&&!s?(U=qe(Y,ne,!1,!0),K=qe(j,ne,!1,!1)):(U=qe(Y,ne,!0,!0),K=qe(ne,j,!0,!0)),r!=null){const X=Df(Z,ne);return[U,K,X]}else return[U,K]},P={a:N,b:R,bias:D,preluActivationWeights:F},A={transposeA:t,transposeB:s,activation:o,leakyreluAlpha:l};return r==null?As((W,j,Y)=>{const Q=z.runKernel(Bi,P,A);return Y([W,j,Q]),{value:le(Q,I),gradFunc:V}})(N,R):As((W,j,Y,Q)=>{const Z=z.runKernel(Bi,P,A);return Q([W,j,Z,Y]),{value:le(Z,I),gradFunc:V}})(N,R,D)}const FA=M({fusedMatMul_:AA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rC=Object.freeze(Object.defineProperty({__proto__:null,conv2d:IA,depthwiseConv2d:DA,matMul:FA},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PA(n){return _f(n,.54,.46)}const LA=M({hammingWindow_:PA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VA(n){return _f(n,.5,.5)}const oC=M({hannWindow_:VA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BA(n,e,t,s=!1,r=0){let o=0;const a=[];for(;o+e<=n.size;)a.push(tt(n,o,e)),o+=t;if(s)for(;o<n.size;){const l=o+e-n.size,u=Xt([tt(n,o,e-l),Pa([l],r)]);a.push(u),o+=t}return a.length===0?$a([],[0,e]):le(Xt(a),[a.length,e])}const aC=M({frame_:BA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MA(n,e,t,s,r=oC){s==null&&(s=Jy(e));const o=aC(n,e,t),a=xe(o,r(e));return If(a,s)}const zA=M({stft_:MA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WA(n,e,t,s,r="bilinear",o=0){const a=_(n,"image","cropAndResize"),l=_(e,"boxes","cropAndResize","float32"),u=_(t,"boxInd","cropAndResize","int32"),d=l.shape[0];O(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),O(l.rank===2&&l.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${d},4] but had shape ${l.shape}.`),O(u.rank===1&&u.shape[0]===d,()=>`Error in cropAndResize: boxInd must be have size [${d}] but had shape ${l.shape}.`),O(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),O(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),O(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const p={image:a,boxes:l,boxInd:u},f={method:r,extrapolationValue:o,cropSize:s};return z.runKernel(Qd,p,f)}const UA=M({cropAndResize_:WA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GA(n){const e=_(n,"image","flipLeftRight","float32");O(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return z.runKernel(cp,t,{})}const HA=M({flipLeftRight_:GA});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jA(n){const e=_(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];O(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),O(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,ba(e,r)}const qA=M({grayscaleToRGB_:jA});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KA(n){const e=_(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];O(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),O(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,o=at(e,"float32"),a=Bn([.2989,.587,.114]);let l;switch(e.rank){case 2:l=xo("ij,j->i",o,a);break;case 3:l=xo("ijk,k->ij",o,a);break;case 4:l=xo("ijkl,l->ijk",o,a);break;case 5:l=xo("ijklm,m->ijkl",o,a);break;case 6:l=xo("ijklmn,n->ijklm",o,a);break;default:throw new Error("Not a valid tensor rank.")}return l=Ks(l,-1),at(l,r)}const XA=M({rgbToGrayscale_:KA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YA(n,e,t=0,s=.5){const r=_(n,"image","rotateWithOffset","float32");O(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const o={image:r},a={radians:e,fillValue:t,center:s};return z.runKernel(yf,o,a)}const QA=M({rotateWithOffset_:YA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Va(n,e,t,s,r,o){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),o==null&&(o=0);const a=n.shape[0];return t=Math.min(t,a),O(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),O(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),O(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),O(e.rank===1,()=>"scores must be a 1D tensor"),O(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),O(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZA(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const o=_(n,"boxes","nonMaxSuppression","float32"),a=_(e,"scores","nonMaxSuppression","float32"),l=Va(o,a,t,s,r);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold;const u={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return z.runKernel(Tp,{boxes:o,scores:a},u)}const JA=M({nonMaxSuppression_:ZA});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eF(n,e,t){const s=tF(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function tF(n,e,t){return sF(n,e,t||nF)}function nF(n,e){return n>e?1:n<e?-1:0}function sF(n,e,t){let s=0,r=n.length,o=0,a=!1;for(;s<r;){o=s+(r-s>>>1);const l=t(e,n[o]);l>0?s=o+1:(r=o,a=!l)}return a?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pf(n,e,t,s,r){return e0(n,e,t,s,r,0)}function Lf(n,e,t,s,r,o){return e0(n,e,t,s,r,0,!1,o,!0)}function Vf(n,e,t,s,r,o){return e0(n,e,t,s,r,o,!0)}function e0(n,e,t,s,r,o,a=!1,l=!1,u=!1){const d=[];for(let v=0;v<e.length;v++)e[v]>r&&d.push({score:e[v],boxIndex:v,suppressBeginIndex:0});d.sort(fw);const p=o>0?-.5/o:0,f=[],m=[];for(;f.length<t&&d.length>0;){const v=d.pop(),{score:b,boxIndex:C,suppressBeginIndex:I}=v;if(b<r)break;let N=!1;for(let R=f.length-1;R>=I;--R){const D=rF(n,C,f[R]);if(D>=s){N=!0;break}if(v.score=v.score*oF(s,p,D),v.score<=r)break}v.suppressBeginIndex=f.length,N||(v.score===b?(f.push(C),m.push(v.score)):v.score>r&&eF(d,v,fw))}const g=f.length,x=t-g;l&&x>0&&(f.push(...new Array(x).fill(0)),m.push(...new Array(x).fill(0)));const w={selectedIndices:f};return a&&(w.selectedScores=m),u&&(w.validOutputs=g),w}function rF(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),o=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),l=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),d=Math.min(r[0],r[2]),p=Math.min(r[1],r[3]),f=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),g=(l-o)*(u-a),x=(f-d)*(m-p);if(g<=0||x<=0)return 0;const w=Math.max(o,d),v=Math.max(a,p),b=Math.min(l,f),C=Math.min(u,m),I=Math.max(b-w,0)*Math.max(C-v,0);return I/(g+x-I)}function oF(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function fw(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function aF(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const o=_(n,"boxes","nonMaxSuppressionAsync"),a=_(e,"scores","nonMaxSuppressionAsync"),l=Va(o,a,t,s,r);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold;const u=await Promise.all([o.data(),a.data()]),d=u[0],p=u[1],{selectedIndices:f}=Pf(d,p,t,s,r);return o!==n&&o.dispose(),a!==e&&a.dispose(),Bn(f,"int32")}const iF=aF;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lF(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const a=_(n,"boxes","nonMaxSuppression"),l=_(e,"scores","nonMaxSuppression"),u=Va(a,l,t,s,r,o);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,o=u.softNmsSigma;const d={boxes:a,scores:l},p={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:o},f=z.runKernel(Rp,d,p);return{selectedIndices:f[0],selectedScores:f[1]}}const uF=M({nonMaxSuppressionWithScore_:lF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function cF(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const a=_(n,"boxes","nonMaxSuppressionAsync"),l=_(e,"scores","nonMaxSuppressionAsync"),u=Va(a,l,t,s,r,o);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,o=u.softNmsSigma;const d=await Promise.all([a.data(),l.data()]),p=d[0],f=d[1],{selectedIndices:m,selectedScores:g}=Vf(p,f,t,s,r,o);return a!==n&&a.dispose(),l!==e&&l.dispose(),{selectedIndices:Bn(m,"int32"),selectedScores:Bn(g)}}const dF=cF;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pF(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const a=_(n,"boxes","nonMaxSuppression"),l=_(e,"scores","nonMaxSuppression"),u=Va(a,l,t,s,r,null),d=u.maxOutputSize,p=u.iouThreshold,f=u.scoreThreshold,m={boxes:a,scores:l},g={maxOutputSize:d,iouThreshold:p,scoreThreshold:f,padToMaxOutputSize:o},x=z.runKernel(Ep,m,g);return{selectedIndices:x[0],validOutputs:x[1]}}const fF=M({nonMaxSuppressionPadded_:pF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function hF(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const a=_(n,"boxes","nonMaxSuppressionAsync"),l=_(e,"scores","nonMaxSuppressionAsync"),u=Va(a,l,t,s,r,null),d=u.maxOutputSize,p=u.iouThreshold,f=u.scoreThreshold,[m,g]=await Promise.all([a.data(),l.data()]),{selectedIndices:x,validOutputs:w}=Lf(m,g,d,p,f,o);return a!==n&&a.dispose(),l!==e&&l.dispose(),{selectedIndices:Bn(x,"int32"),validOutputs:Ve(w,"int32")}}const mF=hF;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gF(n,e,t=!1,s=!1){const r=_(n,"images","resizeBilinear");O(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),O(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),O(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=r,a=!1;r.rank===3&&(a=!0,o=le(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={images:o},u={alignCorners:t,halfPixelCenters:s,size:e},d=z.runKernel(Gp,l,u);return a?le(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const yF=M({resizeBilinear_:gF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xF(n,e,t=!1,s=!1){const r=_(n,"images","resizeNearestNeighbor");O(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),O(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),O(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),O(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=r,a=!1;r.rank===3&&(a=!0,o=le(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={images:o},u={alignCorners:t,halfPixelCenters:s,size:e},d=z.runKernel(Up,l,u);return a?le(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const vF=M({resizeNearestNeighbor_:xF});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wF(n,e="binary",t=!1,s=.5){const r=_(n,"image","threshold"),o=.2989,a=.587,l=.114,u=r.shape[0]*r.shape[1];let d=xe(Bn([s]),255),p,f,m,g;if(O(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),O(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),O(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),O(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[p,f,m]=Ea(r,[1,1,1],-1);const v=xe(p,o),b=xe(f,a),C=xe(m,l);g=_e(_e(v,b),C)}else g=n;if(e==="otsu"){const v=by(at(jy(g),"int32"),gs([]),256);d=bF(v,u)}const x=t?bf(g,d):gu(g,d);return at(xe(x,255),"int32")}function bF(n,e){let t=Bn([-1]),s=Bn([0]),r=Bn([0]),o,a,l,u,d,p;for(let f=0;f<n.size-1;f++){o=tt(n,0,f+1),a=tt(n,f+1),d=ot(rt(o),e),p=ot(rt(a),e);const m=rt(xe(o,Ia(0,o.size)));l=ot(m,rt(o));const g=Pa(a.shape,o.size),x=_e(Ia(0,a.size),g),w=xe(a,x);u=ot(rt(w),rt(a));const v=Fe(l,u),b=Fe(l,u),C=xe(d,p);r=xe(xe(C,v),b);const I=gu(r,s);s=er(I,r,s),t=er(I,Bn([f]),t)}return t}const $F=M({threshold_:wF});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SF(n,e,t="nearest",s="constant",r=0,o){const a=_(n,"image","transform","float32"),l=_(e,"transforms","transform","float32");O(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),O(l.rank===2&&(l.shape[0]===a.shape[0]||l.shape[0]===1)&&l.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),O(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const u={image:a,transforms:l},d={interpolation:t,fillMode:s,fillValue:r,outputShape:o};return z.runKernel(pf,u,d)}const CF=M({transform_:SF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kF(n,e,t){const s=_(n,"a","bandPart");O(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[o,a]=s.shape.slice(-2);let l,u;typeof e=="number"?(O(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),O(e<=o,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`),l=_(e<0?o:e,"numLower","bandPart")):(O(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),l=er(pd(e,0),o,Qi(e,o))),typeof t=="number"?(O(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),O(t<=a,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`),u=_(t<0?a:t,"numUpper","bandPart")):(O(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=er(pd(t,0),a,Qi(t,a)));const d=le(Ia(0,o,1,"int32"),[-1,1]),p=Ia(0,a,1,"int32"),f=Fe(d,p),m=Xi(bf(f,l),Ey(f,ys(u))),g=Wr([o,a],s.dtype);return le(Fs(Xr(le(s,[-1,o,a])).map(x=>er(m,x,g))),r)}const NF=M({bandPart_:kF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IF(n){let e;if(Array.isArray(n)){e=!1,O(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let o=1;o<n.length;++o)O(n[o].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${r})`)}else e=!0,n=Ea(n,n.shape[0],0).map(r=>Tf(r,[0]));O(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(z.tidy(()=>{let o=s[r];if(r>0)for(let a=0;a<r;++a){const l=xe(rt(xe(t[a],o)),t[a]);o=Fe(o,l)}return ot(o,mu(o,"euclidean"))}));return e?Fs(t,0):t}const TF=M({gramSchmidt_:IF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EF(n,e=!1){if(O(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return hw(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((u,d)=>u*d),s=Xr(le(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],o=[];s.forEach(u=>{const[d,p]=hw(u,e);r.push(d),o.push(p)});const a=le(Fs(r,0),n.shape),l=le(Fs(o,0),n.shape);return[a,l]}}function hw(n,e=!1){return z.tidy(()=>{O(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=Ny(t),o=Js(n);const a=$a([[1]],[1,1]);let l=Js(a);const u=t>=s?s:t;for(let d=0;d<u;++d){const p=o,f=l,m=r;[l,o,r]=z.tidy(()=>{const g=tt(o,[d,d],[t-d,1]),x=mu(g),w=tt(o,[d,d],[1,1]),v=er(gu(w,0),$a([[-1]]),$a([[1]])),b=Fe(w,xe(v,x)),C=ot(g,b);C.shape[0]===1?l=Js(a):l=Xt([a,tt(C,[1,0],[C.shape[0]-1,C.shape[1]])],0);const I=ys(ot(qe(v,b),x)),N=tt(o,[d,0],[t-d,s]),R=xe(I,l),D=Ji(l);if(d===0)o=Fe(N,qe(R,qe(D,N)));else{const P=Fe(N,qe(R,qe(D,N)));o=Xt([tt(o,[0,0],[d,s]),P],0)}const F=Ji(R),V=tt(r,[0,d],[t,r.shape[1]-d]);if(d===0)r=Fe(V,qe(qe(V,l),F));else{const P=Fe(V,qe(qe(V,l),F));r=Xt([tt(r,[0,0],[t,d]),P],1)}return[l,o,r]}),an([p,f,m])}return!e&&t>s&&(r=tt(r,[0,0],[t,s]),o=tt(o,[0,0],[s,s])),[r,o]})}const RF=M({qr_:EF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var rn;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(rn||(rn={}));function _F(n,e,t=rn.SUM_BY_NONZERO_WEIGHTS){const s=_(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=_(e,"weights","computeWeightedLoss"));const o=r==null?s:xe(s,r);if(t===rn.NONE)return o;if(t===rn.SUM)return rt(o);if(t===rn.MEAN){if(r==null)return Yi(o);{const a=s.size/r.size,l=ot(rt(o),rt(r));return a>1?ot(l,Ve(a)):l}}if(t===rn.SUM_BY_NONZERO_WEIGHTS){if(r==null)return ot(rt(o),Ve(s.size));{const a=xe(r,Ar(s.shape)),l=at(rt(Vy(a,Ve(0))),"float32");return ot(rt(o),l)}}throw Error(`Unknown reduction: ${t}`)}const ur=M({computeWeightedLoss_:_F});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OF(n,e,t,s=rn.SUM_BY_NONZERO_WEIGHTS){const r=_(n,"labels","absoluteDifference"),o=_(e,"predictions","absoluteDifference");let a=null;t!=null&&(a=_(t,"weights","absoluteDifference")),zt(r.shape,o.shape,"Error in absoluteDifference: ");const l=Nn(Fe(r,o));return ur(l,a,s)}const DF=M({absoluteDifference_:OF});function AF(n,e,t,s,r=rn.SUM_BY_NONZERO_WEIGHTS){const o=_(n,"labels","cosineDistance"),a=_(e,"predictions","cosineDistance");let l=null;s!=null&&(l=_(s,"weights","cosineDistance")),zt(o.shape,a.shape,"Error in cosineDistance: ");const u=Ve(1),d=Fe(u,rt(xe(o,a),t,!0));return ur(d,l,r)}const FF=M({cosineDistance_:AF});function PF(n,e,t,s=rn.SUM_BY_NONZERO_WEIGHTS){let r=_(n,"labels","hingeLoss");const o=_(e,"predictions","hingeLoss");let a=null;t!=null&&(a=_(t,"weights","hingeLoss")),zt(r.shape,o.shape,"Error in hingeLoss: ");const l=Ve(1);r=Fe(xe(Ve(2),r),l);const u=xu(Fe(l,xe(r,o)));return ur(u,a,s)}const LF=M({hingeLoss_:PF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VF(n,e,t,s=1,r=rn.SUM_BY_NONZERO_WEIGHTS){const o=_(n,"labels","huberLoss"),a=_(e,"predictions","huberLoss");let l=null;t!=null&&(l=_(t,"weights","huberLoss")),zt(o.shape,a.shape,"Error in huberLoss: ");const u=Ve(s),d=Nn(Fe(a,o)),p=Qi(d,u),f=Fe(d,p),m=_e(xe(Ve(.5),Jn(p)),xe(u,f));return ur(m,l,r)}const BF=M({huberLoss_:VF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MF(n,e,t,s=1e-7,r=rn.SUM_BY_NONZERO_WEIGHTS){const o=_(n,"labels","logLoss"),a=_(e,"predictions","logLoss");let l=null;t!=null&&(l=_(t,"weights","logLoss")),zt(o.shape,a.shape,"Error in logLoss: ");const u=Ve(1),d=Ve(s),p=ys(xe(o,Na(_e(a,d)))),f=xe(Fe(u,o),Na(_e(Fe(u,a),d))),m=Fe(p,f);return ur(m,l,r)}const zF=M({logLoss_:MF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WF(n,e,t,s=rn.SUM_BY_NONZERO_WEIGHTS){const r=_(n,"labels","meanSquaredError"),o=_(e,"predictions","meanSquaredError");let a=null;t!=null&&(a=_(t,"weights","meanSquaredError")),zt(r.shape,o.shape,"Error in meanSquaredError: ");const l=Ky(r,o);return ur(l,a,s)}const UF=M({meanSquaredError_:WF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GF(n,e){const t=_(n,"labels","sigmoidCrossEntropyWithLogits"),s=_(e,"logits","sigmoidCrossEntropyWithLogits");zt(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=xu(s),o=xe(s,t),a=_y(zr(ys(Nn(s))));return _e(Fe(r,o),a)}function HF(n,e,t,s=0,r=rn.SUM_BY_NONZERO_WEIGHTS){let o=_(n,"multiClassLabels","sigmoidCrossEntropy");const a=_(e,"logits","sigmoidCrossEntropy");let l=null;if(t!=null&&(l=_(t,"weights","sigmoidCrossEntropy")),zt(o.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const d=Ve(s),p=Ve(1),f=Ve(.5);o=_e(xe(o,Fe(p,d)),xe(f,d))}const u=GF(o,a);return ur(u,l,r)}const jF=M({sigmoidCrossEntropy_:HF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qF(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return As((r,o,a)=>{const u=Dy(o,[t],!0),d=Fe(at(o,"float32"),u);a([r,d]);const p=ys(xe(d,r));return{value:rt(p,[t]),gradFunc:(g,x)=>{const[w,v]=x,b=It(g.shape,[t]);return[xe(le(g,b),Fe(at(w,"float32"),zr(v))),xe(le(g,b),Fe(zr(v),at(w,"float32")))]}}})(n,e)}function KF(n,e,t,s=0,r=rn.SUM_BY_NONZERO_WEIGHTS){let o=_(n,"onehotLabels","softmaxCrossEntropy");const a=_(e,"logits","softmaxCrossEntropy");let l=null;if(t!=null&&(l=_(t,"weights","softmaxCrossEntropy")),zt(o.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const d=Ve(s),p=Ve(1),f=Ve(o.shape[1]);o=_e(xe(o,Fe(p,d)),ot(d,f))}const u=qF(o,a);return ur(u,l,r)}const XF=M({softmaxCrossEntropy_:KF});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YF(n,e,t,s){const r=_(n,"indices","sparseFillEmptyRows","int32"),o=_(e,"values","sparseFillEmptyRows"),a=_(t,"denseShape","sparseFillEmptyRows","int32"),l=_(s,"defaultValue","sparseFillEmptyRows",o.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(l.rank!==0)throw new Error(`Default value should be a scalar but received shape ${l.shape}`);const u={indices:r,values:o,denseShape:a,defaultValue:l},d=z.runKernel(tf,u);return{outputIndices:d[0],outputValues:d[1],emptyRowIndicator:d[2],reverseIndexMap:d[3]}}const QF=M({sparseFillEmptyRows_:YF});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZF(n,e,t){const s=_(n,"inputIndices","sparseReshape","int32"),r=_(e,"inputShape","sparseReshape","int32"),o=_(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const a={inputIndices:s,inputShape:r,newShape:o},l=z.runKernel(nf,a);return{outputIndices:l[0],outputShape:l[1]}}const JF=M({sparseReshape_:ZF});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eP(n,e,t){const s=_(n,"data","sparseSegmentMean"),r=_(e,"indices","sparseSegmentMean","int32"),o=_(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const a={data:s,indices:r,segmentIds:o};return z.runKernel(sf,a)}const tP=M({sparseSegmentMean_:eP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nP(n,e,t){const s=_(n,"data","sparseSegmentSum"),r=_(e,"indices","sparseSegmentSum","int32"),o=_(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const a={data:s,indices:r,segmentIds:o};return z.runKernel(rf,a)}const sP=M({sparseSegmentSum_:nP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rP(n,e,t,s,r,o,a,l){const u=_(n,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const d=_(e,"dataSplits","stringNGrams");if(d.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const p={separator:t,nGramWidths:s,leftPad:r,rightPad:o,padWidth:a,preserveShortSequences:l},f={data:u,dataSplits:d},m=z.runKernel(lf,f,p);return{nGrams:m[0],nGramsSplits:m[1]}}const oP=M({stringNGrams_:rP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aP(n,e,t=!0){const s=_(n,"input","stringSplit","string"),r=_(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const o={skipEmpty:t},a={input:s,delimiter:r},l=z.runKernel(uf,a,o);return{indices:l[0],values:l[1],shape:l[2]}}const iP=M({stringSplit_:aP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lP(n,e){const t=_(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return z.runKernel(cf,r,s)}const uP=M({stringToHashBucketFast_:lP});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cP(n,e,t,s=!0){const r=_(n,"input","staticRegexReplace","string"),o={pattern:e,rewrite:t,replaceGlobal:s};return z.runKernel(su,{x:r},o)}const dP=M({staticRegexReplace_:cP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iC={fft:Nf,ifft:Zi,rfft:If,irfft:qy},lC={hammingWindow:LA,hannWindow:oC,frame:aC,stft:zA},uC={flipLeftRight:HA,grayscaleToRGB:qA,resizeNearestNeighbor:vF,resizeBilinear:yF,rgbToGrayscale:XA,rotateWithOffset:QA,cropAndResize:UA,nonMaxSuppression:JA,nonMaxSuppressionAsync:iF,nonMaxSuppressionWithScore:uF,nonMaxSuppressionWithScoreAsync:dF,nonMaxSuppressionPadded:fF,nonMaxSuppressionPaddedAsync:mF,threshold:$F,transform:CF},cC={bandPart:NF,gramSchmidt:TF,qr:RF},dC={absoluteDifference:DF,computeWeightedLoss:ur,cosineDistance:FF,hingeLoss:LF,huberLoss:BF,logLoss:zF,meanSquaredError:UF,sigmoidCrossEntropy:jF,softmaxCrossEntropy:XF},pC={sparseFillEmptyRows:QF,sparseReshape:JF,sparseSegmentMean:tP,sparseSegmentSum:sP},fC={stringNGrams:oP,stringSplit:iP,stringToHashBucketFast:uP,staticRegexReplace:dP};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pP=new Map,$g=new Map;class hC{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Or{constructor(){this.classNameMap={}}static getMap(){return Or.instance==null&&(Or.instance=new Or),Or.instance}static register(e){Or.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function mC(n,e,t){O(n.className!=null,()=>"Class being registered does not have the static className property defined."),O(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),O(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return Or.register(n),pP.set(r,n),$g.set(n,r),n}function fP(n){return $g.has(n)?$g.get(n):n.className}const hP=Object.freeze(Object.defineProperty({__proto__:null,Serializable:hC,SerializationMap:Or,getRegisteredName:fP,registerClass:mC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yr extends hC{minimize(e,t=!1,s){const{value:r,grads:o}=this.computeGradients(e,s);if(s!=null){const a=s.map(l=>({name:l.name,tensor:o[l.name]}));this.applyGradients(a)}else this.applyGradients(o);return an(o),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return j$(e,t)}dispose(){this.iterations_!=null&&an(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Ve(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Yr,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t0 extends Yr{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=z.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=z.registeredVariables[s],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:Ue(()=>En(o).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:Ue(()=>En(o).variable(a))});const l=Array.isArray(e)?e[r].tensor:e[s];if(l==null)return;const u=this.accumulatedGrads[r].variable,d=this.accumulatedUpdates[r].variable;Ue(()=>{const p=_e(xe(u,this.rho),xe(Jn(l),1-this.rho)),f=xe(ot(Ds(_e(d,this.epsilon)),Ds(_e(u,this.epsilon))),l),m=_e(xe(d,this.rho),xe(Jn(f),1-this.rho));u.assign(p),d.assign(m);const g=_e(xe(f,-this.learningRate),o);o.assign(g)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(an(this.accumulatedGrads.map(e=>e.variable)),an(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n0 extends Yr{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=z.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:Ue(()=>Pa(o.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const l=this.accumulatedGrads[r].variable;Ue(()=>{const u=_e(l,Jn(a));l.assign(u);const d=_e(xe(ot(a,Ds(_e(u,z.backend.epsilon()))),-this.learningRate),o);o.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&an(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s0 extends Yr{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Ue(()=>{this.accBeta1=Ve(t).variable(),this.accBeta2=Ve(s).variable()}),r==null&&(this.epsilon=z.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);Ue(()=>{const s=Fe(1,this.accBeta1),r=Fe(1,this.accBeta2);t.forEach((o,a)=>{const l=z.registeredVariables[o],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:Ue(()=>En(l).variable(u))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:Ue(()=>En(l).variable(u))});const d=Array.isArray(e)?e[a].tensor:e[o];if(d==null)return;const p=this.accumulatedFirstMoment[a].variable,f=this.accumulatedSecondMoment[a].variable,m=_e(xe(p,this.beta1),xe(d,1-this.beta1)),g=_e(xe(f,this.beta2),xe(Jn(d),1-this.beta2)),x=ot(m,s),w=ot(g,r);p.assign(m),f.assign(g);const v=_e(xe(ot(x,_e(Ds(w),this.epsilon)),-this.learningRate),l);l.assign(v)}),this.accBeta1.assign(xe(this.accBeta1,this.beta1)),this.accBeta2.assign(xe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&an(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&an(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),Ue(()=>{this.accBeta1.assign(ka(this.beta1,this.iterations_+1)),this.accBeta2.assign(ka(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r0 extends Yr{static get className(){return"Adamax"}constructor(e,t,s,r=null,o=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Ue(()=>{this.iteration=Ve(0).variable(),this.accBeta1=Ve(t).variable()}),r==null&&(this.epsilon=z.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);Ue(()=>{const s=Fe(1,this.accBeta1),r=ot(-this.learningRate,_e(xe(this.iteration,this.decay),1));t.forEach((o,a)=>{const l=z.registeredVariables[o],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:En(l).variable(u)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:En(l).variable(u)});const d=Array.isArray(e)?e[a].tensor:e[o];if(d==null)return;const p=this.accumulatedFirstMoment[a].variable,f=this.accumulatedWeightedInfNorm[a].variable,m=_e(xe(p,this.beta1),xe(d,1-this.beta1)),g=xe(f,this.beta2),x=Nn(d),w=Ly(g,x);p.assign(m),f.assign(w);const v=_e(xe(ot(r,s),ot(m,_e(w,this.epsilon))),l);l.assign(v)}),this.iteration.assign(_e(this.iteration,1)),this.accBeta1.assign(xe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&an(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&an(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bf extends Yr{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const a=z.registeredVariables[s];Ue(()=>{const l=_e(xe(this.c,o),a);a.assign(l)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=hs(Ve(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o0 extends Bf{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=Ve(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=z.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:Ue(()=>En(o).variable(!1))});const a=this.accumulations[r].variable,l=Array.isArray(e)?e[r].tensor:e[s];l!=null&&Ue(()=>{let u;const d=_e(xe(this.m,a),l);this.useNesterov?u=_e(xe(this.c,_e(l,xe(d,this.m))),o):u=_e(xe(this.c,d),o),a.assign(d),o.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&an(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a0 extends Yr{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,o=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,r==null&&(this.epsilon=z.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=z.registeredVariables[s],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:Ue(()=>En(o).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:Ue(()=>En(o).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:Ue(()=>En(o).variable(a))});const l=Array.isArray(e)?e[r].tensor:e[s];if(l==null)return;const u=this.accumulatedMeanSquares[r].variable,d=this.accumulatedMoments[r].variable;Ue(()=>{const p=_e(xe(u,this.decay),xe(Jn(l),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[r].variable,m=_e(xe(f,this.decay),xe(l,1-this.decay)),g=ot(xe(l,this.learningRate),Ds(Fe(p,_e(Jn(m),this.epsilon)))),x=_e(xe(d,this.momentum),g);u.assign(p),f.assign(m),d.assign(x);const w=Fe(o,x);o.assign(w)}else{const f=_e(xe(u,this.decay),xe(Jn(l),1-this.decay)),m=_e(xe(d,this.momentum),ot(xe(l,this.learningRate),Ds(_e(f,this.epsilon))));u.assign(f),d.assign(m);const g=Fe(o,m);o.assign(g)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&an(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&an(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&an(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mP=[t0,n0,s0,r0,o0,a0,Bf];function gP(){for(const n of mP)mC(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yP="model",xP=".json",vP=".weights.bin";function mw(n){return new Promise(e=>setTimeout(e)).then(n)}class Oo{constructor(e){if(!J().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Oo.URL_SCHEME)&&(e=e.slice(Oo.URL_SCHEME.length)),(e==null||e.length===0)&&(e=yP),this.modelJsonFileName=e+xP,this.weightDataFileName=e+vP}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=vs.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=zb(e,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),l=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(l.download=this.modelJsonFileName,l.href=a,await mw(()=>l.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=s,await mw(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:cu(e)}}}}Oo.URL_SCHEME="downloads://";class wP{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const o=JSON.parse(r.target.result),a=o.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const u=my(o,d=>this.loadWeights(d));e(u)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const a of e)t.push(...a.weights),s.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),o=s.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(o).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((s,r)=>{const o=new FileReader;o.onload=a=>{const l=a.target.result;s(l)},o.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(o=>rw(o.name)),r={};for(const o of e)o.paths.forEach(a=>{const l=rw(a);if(t.indexOf(l)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${l}'`);if(t.push(l),s.indexOf(l)===-1)throw new Error(`Weight file with basename '${l}' is not provided.`);r[a]=this.weightsFiles[s.indexOf(l)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const bP=n=>J().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Oo.URL_SCHEME)?$P(n.slice(Oo.URL_SCHEME.length)):null;ft.registerSaveRouter(bP);function $P(n="model"){return new Oo(n)}function SP(n){return new wP(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gw(n,e,t,s){a(n),t=t??0,s=s??1,l(t,s);let r=0;const o=u=>(u.then(d=>{const p=t+ ++r/n.length*(s-t);return e(p),d}),u);function a(u){O(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function l(u,d){O(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),O(d>=0&&d<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${d}`),O(d>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${d}`)}return Promise.all(n.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function gC(n,e){e==null&&(e={});const t=e.fetchFunc==null?J().platform.fetch:e.fetchFunc,s=n.map(f=>t(f,e.requestInit,{isBinary:!0})),l=(e.onProgress==null?await Promise.all(s):await gw(s,e.onProgress,0,.5)).map(f=>f.arrayBuffer());return e.onProgress==null?await Promise.all(l):await gw(l,e.onProgress,.5,1)}function CP(n,e){var t;const s=e.fetchFunc==null?J().platform.fetch:e.fetchFunc;let r=0,o;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async a=>{for(var l;r<n.length;){o||(o=(await s(n[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:d}=await o.read();if(u){r++,o=void 0,(l=e.onProgress)===null||l===void 0||l.call(e,r/n.length);continue}a.enqueue(d);return}a.close()}})}async function kP(n,e="",t,s){return yC(a=>gC(a,{requestInit:s}))(n,e,t)}function yC(n){return async(e,t="",s)=>{const r=e.map(()=>!1),o={},a=s!=null?s.map(()=>!1):[],l=[];if(e.forEach((g,x)=>{let w=0;g.weights.forEach(v=>{const b="quantization"in v?v.quantization.dtype:v.dtype,C=Io[b]*oe(v.shape),I=()=>{r[x]=!0,o[x]==null&&(o[x]=[]),o[x].push({manifestEntry:v,groupOffset:w,sizeBytes:C})};s!=null?s.forEach((N,R)=>{N===v.name&&(I(),a[R]=!0)}):I(),l.push(v.name),w+=C})}),!a.every(g=>g)){const g=s.filter((x,w)=>!a[w]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${l.join(", ")}.`)}const u=r.reduce((g,x,w)=>(x&&g.push(w),g),[]),d=[];u.forEach(g=>{e[g].paths.forEach(x=>{const w=t+(t.endsWith("/")?"":"/")+x;d.push(w)})});const p=await n(d),f={};let m=0;return u.forEach(g=>{const x=e[g].paths.length,w=new vs(p.slice(m,m+x));o[g].forEach(b=>{const C=w.slice(b.groupOffset,b.groupOffset+b.sizeBytes),I=Vb(C,[b.manifestEntry]);for(const N in I)f[N]=I[N]}),m+=x}),f}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NP="application/octet-stream",IP="application/json";class i0{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(O(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=J().platform.fetch,O(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&O(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=zb(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:IP}),"model.json"),e.weightData!=null){const a=vs.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:NP}),"model.weights.bin")}const o=await this.fetch(this.path,t);if(o.ok)return{modelArtifactsInfo:cu(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return my(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=ud(e.weightsManifest),r=()=>CP(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=TP(t),o=this.weightPathPrefix||s,a=[],l=[];for(const u of e)for(const d of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(d)):a.push(o+d+r);return this.weightUrlConverter&&a.push(...await Promise.all(l)),a}async loadWeights(e){const t=await this.getWeightUrls(e),s=ud(e),r=await gC(t,this.loadOptions);return[s,r]}}i0.URL_SCHEME_REGEX=/^https?:\/\//;function TP(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function Sg(n){return n.match(i0.URL_SCHEME_REGEX)!=null}const xC=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>Sg(s)):t=Sg(n),t)return l0(n,e)}return null};ft.registerSaveRouter(xC);ft.registerLoadRouter(xC);function l0(n,e){return new i0(n,e)}function EP(n,e){return l0(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ym{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class vC{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class RP{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function _P(n,e,t,s){const r=arguments;return new RP(hd(...r))}function hd(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Ym(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ym({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ym({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function OP(n){return new vC(n)}function DP(n){return new vC(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u0=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:vs,browserFiles:SP,browserHTTPRequest:EP,concatenateArrayBuffers:DE,copyModel:tR,decodeWeights:Vb,decodeWeightsStream:Mb,encodeWeights:IE,fromMemory:_P,fromMemorySync:hd,getLoadHandlers:zE,getModelArtifactsForJSON:my,getModelArtifactsForJSONSync:hy,getModelArtifactsInfoForJSON:cu,getSaveHandlers:ME,getWeightSpecs:ud,http:l0,isHTTPScheme:Sg,listModels:JE,loadWeights:kP,moveModel:nR,registerLoadRouter:BE,registerSaveRouter:VE,removeModel:eR,weightsLoaderFactory:yC,withSaveHandler:OP,withSaveHandlerSync:DP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AP(n,e,t){const s=_(n,"labels","confusionMatrix"),r=_(e,"predictions","confusionMatrix");O(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),O(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),O(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),O(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),O(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const o=fd(at(s,"int32"),t),a=fd(at(r,"int32"),t),l=Ji(o),u=qe(l,a);return at(u,"int32")}const FP=M({confusionMatrix_:AP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PP=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:FP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ho,yw=!1;function wC(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,o=!1,a=!1,l=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)o=!0;else if(n.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)l=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(Ui(id,z.backendName)!=null){const x={pixels:n},w={numChannels:e};return z.runKernel(id,x,w)}const[d,p]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let f;if(a)f=n.getContext("2d").getImageData(0,0,d,p).data;else if(s||t)f=n.data;else if(o||r||l){if(ho==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")ho=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else ho=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ho.canvas.width=d,ho.canvas.height=p,ho.drawImage(n,0,0,d,p),f=ho.getImageData(0,0,d,p).data}let m;if(e===4)m=new Int32Array(f);else{const x=d*p;m=new Int32Array(x*e);for(let w=0;w<x;w++)for(let v=0;v<e;++v)m[w*e+v]=f[w*4+v]}return Yy(m,[p,d,e],"int32")}function LP(n){return n!=null&&n.data instanceof Uint8Array}function VP(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function BP(n){return n!=null&&n.width!==0&&n.height!==0}function MP(n){return VP()&&!(n instanceof ImageBitmap)&&BP(n)&&!LP(n)}async function zP(n,e=3){let t=null;if(J().getBool("WRAP_TO_IMAGEBITMAP")&&MP(n)){let s;try{s=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===n.width&&s.height===n.height?t=s:t=n}else t=n;return wC(t,e)}function bC(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function WP(n){const e=(n==null?void 0:n.alpha)||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function UP(n,e){let t=_(n,"img","toPixels");if(!(n instanceof yt)){const d=t;t=at(d,"int32"),d.dispose()}bC(t);const[s,r]=t.shape.slice(0,2),o=t.rank===2?1:t.shape[2],a=await t.data(),l=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(r*s*4);for(let d=0;d<s*r;++d){const p=[0,0,0,255];for(let m=0;m<o;m++){const g=a[d*o+m];if(t.dtype==="float32"){if(g<0||g>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${g}.`)}else if(t.dtype==="int32"&&(g<0||g>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${g}.`);o===1?(p[0]=g*l,p[1]=g*l,p[2]=g*l):p[m]=g*l}const f=d*4;u[f+0]=Math.round(p[0]),u[f+1]=Math.round(p[1]),u[f+2]=Math.round(p[2]),u[f+3]=Math.round(p[3])}if(e!=null){yw||Ui(op,z.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),yw=!0),e.width=r,e.height=s;const d=e.getContext("2d"),p=new ImageData(u,r,s);d.putImageData(p,0,0)}return t!==n&&t.dispose(),u}function GP(n,e,t){let s=_(n,"img","draw");if(!(n instanceof yt)){const a=s;s=at(a,"int32"),a.dispose()}bC(s),WP(t==null?void 0:t.imageOptions);const r={image:s},o={canvas:e,options:t};z.runKernel(op,r,o)}const HP=M({fromPixels_:wC}),jP=Object.freeze(Object.defineProperty({__proto__:null,draw:GP,fromPixels:HP,fromPixelsAsync:zP,toPixels:UP},Symbol.toStringTag,{value:"Module"}));function Mf(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(oe(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,o=r[r.length-1];let a=1;for(let f=0;f<r.length-1;++f)a*=r[f];const l=n.shape,u=r.slice();u.pop();let d=1;for(let f=o;f<t;++f)d*=l[f],u.push(l[f]);const p=[...Ie(n.shape).map(f=>f/d),1].slice(0,o);return[u,a,d,p]}const qP=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:Mf},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cg=-2,KP=-1;function c0(n,e,t){const s=n.shape.length;O(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),O(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)O(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function XP(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function d0(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function $C(n,e,t,s){const r=[...n];for(let o=r.length;o<s.length;o++)r.push(1);for(let o=0;o<t;o++)o===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function SC(n,e,t){return t<=n?t:t-(e-1)}function CC(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function YP(n,e,t,s,r,o,a,l,u){const d=n.length;let p=new Array(d),f=new Array(d),m=new Array(d);if(e.length&&t>0){const g=e[0],x=t+1;p=kC(a,g,x,s,n),f=NC(l,g,x,r,n),m=$C(o,g,x,n)}else for(let g=0;g<d;g++)p[g]=TC(a,s,o,n,g,u),f[g]=EC(l,r,o,n,g,u),m[g]=IC(o,g,u);return{begin:p,end:f,strides:m}}function kC(n,e,t,s,r){const o=[...r],a=CC(t,e);for(let l=0;l<o.length;l++)if(a.indexOf(l)>-1)o[l]=0;else{const u=SC(e,t,l);let d=s[u];n&1<<u&&(d=0),o[l]=d}return o}function NC(n,e,t,s,r){const o=[...r],a=CC(t,e);for(let l=0;l<o.length;l++)if(a.indexOf(l)>-1)o[l]=Number.MAX_SAFE_INTEGER;else{const u=SC(e,t,l);let d=s[u];n&1<<u&&(d=Number.MAX_SAFE_INTEGER),o[l]=d}for(let l=0;l<o.length;l++){const u=r[l];o[l]<0&&(o[l]+=u),o[l]=Lr(0,o[l],r[l])}return o}function IC(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function TC(n,e,t,s,r,o){let a=e[r];const l=t[r]||1;(n&1<<r||o&1<<r||a==null)&&(l>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const u=s[r];return a<0&&(a+=u),a=Lr(0,a,u-1),a}function EC(n,e,t,s,r,o){let a=e[r];const l=t[r]||1;(n&1<<r||o&1<<r||a==null)&&(l>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const u=s[r];return a<0&&(a+=u),l>0?a=Lr(0,a,u):a=Lr(-1,a,u-1),a}function p0(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function f0(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function h0(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(a=>{O(a!==-1,()=>"slice() does not support negative begin indexing.")});let o;return t==null?o=new Array(r).fill(-1):typeof t=="number"?o=[t,...new Array(r-1).fill(-1)]:t.length<r?o=t.concat(new Array(r-t.length).fill(-1)):o=t,o=o.map((a,l)=>a>=0?a:(O(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${l}.`),n.shape[l]-s[l])),[s,o]}function m0(n,e,t,s,r,o,a,l,u){let d;if(s==null?(d=new Array(e.length),d.fill(1)):d=s,a!=null&&a&a-1)throw new Error("Multiple ellipses in slice is not allowed.");let p=!1;const f={dims:d.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:d.slice(),beginMask:r,endMask:o,ellipsisMask:a,newAxisMask:l,shrinkAxisMask:u};for(let I=0;I<f.dims;I++)p&&1<<I&l&&f.numAddAxisAfterEllipsis++,1<<I&a&&(p=!0);p||(f.ellipsisMask|=1<<f.dims,f.dims++);const m={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};QP(f,m);let g=!0,x=!0,w=!0;const v=[],b=[];for(let I=0;I<n.length;++I){if(m.strides[I]===0)throw Error(`strides[${I}] must be non-zero`);const N=!!(m.shrinkAxisMask&1<<I),R=n[I];if(R===-1){v.push(N?1:-1);continue}const D=[m.beginMask&1<<I,m.endMask&1<<I],F=[m.strides[I]>0?0:-1,m.strides[I]>0?R:R-1];if(N&&m.strides[I]<=0)throw Error("only stride 1 allowed on non-range indexing.");w=w&&m.strides[I]===1;const V=!!(m.beginMask&1<<I&&m.endMask&1<<I);if(m.beginValid&&m.endValid){if(N){const W=m.begin[I]<0?R+m.begin[I]:m.begin[I];if(m.begin[I]=W,m.end[I]=m.begin[I]+1,W<0||W>=R)throw Error(`slice index ${m.begin[I]} of dimension ${I} out of bounds.`)}else m.begin[I]=xw(m.begin[I],0,m.strides[I],R,D,F),m.end[I]=xw(m.end[I],1,m.strides[I],R,D,F);const T=m.strides[I]===1&&m.begin[I]===0&&m.end[I]===R;g=g&&T,x=x&&(I===0&&m.strides[I]===1||T)}else g=g&&m.strides[I]===1&&V,x=x&&(I===0&&m.strides[I]===1||V);let P,A=!1;if(m.beginValid&&m.endValid?(P=m.end[I]-m.begin[I],A=!0):N?(P=1,A=!0):V&&R>=0&&(m.strides[I]<0?P=-R:P=R,A=!0),A){let T;P===0||P<0!=m.strides[I]<0?T=0:T=Math.trunc(P/m.strides[I])+(P%m.strides[I]!==0?1:0),v.push(T)}else v.push(-1)}for(let I=0;I<m.finalShapeGatherIndices.length;++I){const N=m.finalShapeGatherIndices[I];N>=0?b.push(v[N]):N===Cg&&b.push(1)}return{finalShapeSparse:b.filter((I,N)=>m.finalShapeGatherIndices[N]!==Cg),finalShape:b,isIdentity:g,sliceDim0:x,isSimpleSlice:w,begin:m.begin,end:m.end,strides:m.strides}}function QP(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(Cg),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(KP),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function xw(n,e,t,s,r,o){if(r[e])return t>0?o[e]:o[e+1&1];{const a=n<0?s+n:n;return a<o[0]?o[0]:a>o[1]?o[1]:a}}const RC=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:c0,computeFlatOffset:f0,computeOutShape:d0,getNormalizedAxes:YP,isSliceContinous:p0,maskToAxes:XP,parseSliceParams:h0,sliceInfo:m0,startForAxis:TC,startIndicesWithElidedDims:kC,stopForAxis:EC,stopIndicesWithElidedDims:NC,stridesForAxis:IC,stridesWithElidedDims:$C},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const ZP="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _C{static sgd(e){return new Bf(e)}static momentum(e,t,s=!1){return new o0(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,o=!1){return new a0(e,t,s,r,o)}static adam(e=.001,t=.9,s=.999,r=null){return new s0(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new t0(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,o=0){return new r0(e,t,s,r,o)}static adagrad(e,t=.1){return new n0(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JP=_C;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e3=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function OC(){return new Promise(n=>e3(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g0(n,e){const t=n[0].length;n.forEach((r,o)=>{O(r.length===t,()=>`Error in concat${t}D: rank of tensors[${o}] must be the same as the rank of the rest (${t})`)}),O(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,o)=>{for(let a=0;a<t;a++)O(a===e||r[a]===s[a],()=>`Error in concat${t}D: Shape of tensors[${o}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${o}.`)})}function Rs(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var fs;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(fs||(fs={}));function DC(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const o=t[r],a=s[s.length-t.length+r],l=s[a];if(o>=0)if(l>=0){if(l!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${o} but shape[${r+n}] = ${l}`)}else s[a]=o}return s}function AC(n){const e={FIRST_DIM_SIZE:fs.FIRST_DIM_SIZE,VALUE_ROWIDS:fs.VALUE_ROWIDS,ROW_LENGTHS:fs.ROW_LENGTHS,ROW_SPLITS:fs.ROW_SPLITS,ROW_LIMITS:fs.ROW_LIMITS,ROW_STARTS:fs.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function FC(n){return n.length===0?0:n[0]===fs.FIRST_DIM_SIZE?n.length-1:n.length}function PC(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const o=n[r],a=e[r+1];if(o>=0&&a>=0&&o!==1&&o!==a)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${o} but ragged tensor input.flatValues.shape[${r-n.length}] = ${a}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y0=30;function zf(n){return n<=y0?n:ad(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vu(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const o=e.length;for(let a=0;a<o;++a)r=r.concat([n[a+1]/e[a],e[a]]);r=r.concat(n.slice(o+1))}return r}function wu(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],o=[];for(let a=1;a<n;++a)a>=e*2+1||a%2===1?o.push(a):r.push(a);s.push(...r),s.push(0),s.push(...o)}return s}function bu(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let o=1;o<n.length;++o)o<=e.length?s?r.push(e[o-1]*n[o]):r.push(n[o]/e[o-1]):r.push(n[o]);return r}function v0(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function w0(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b0=1.7580993408473768,$0=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S0=.3275911,C0=.254829592,k0=-.284496736,N0=1.421413741,I0=-1.453152027,T0=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sr(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function LC(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function VC(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function BC(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function E0(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function MC(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function zC(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const o=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(o),s[r]=Math.sin(o)}return{real:t,imag:s}}function WC(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),o=Math.sin(s);return{real:r,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qm="->",t3=/->/g,vw=",",ww="...";function R0(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(t3,"").length)/Qm.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Qm}").`);const[s,r]=n.split(Qm);O(s.indexOf(ww)===-1,()=>`The ellipsis notation ("${ww}") is not supported yet.`);const o=s.split(vw),a=o.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const l=[];for(let m=0;m<r.length;++m){const g=r[m];if(!o.some(x=>x.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);l.indexOf(g)===-1&&l.push(g)}for(let m=0;m<s.length;++m){const g=s[m];l.indexOf(g)===-1&&g!==vw&&l.push(g)}const u=new Array(o.length);for(let m=0;m<a;++m){if(new Set(o[m].split("")).size!==o[m].length)throw new Error(`Found duplicate axes in input component ${o[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let g=0;g<o[m].length;++g)u[m].push(l.indexOf(o[m][g]))}const d=l.length,p=r.length,f=[];for(let m=p;m<d;++m)f.push(m);return{allDims:l,summedDims:f,idDims:u}}function _0(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function O0(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const o=t[r].shape;for(let a=0;a<e[r].length;++a)s[e[r][a]]===void 0?s[e[r][a]]=o[a]:O(s[e[r][a]]===o[a],()=>`Expected dimension ${s[e[r][a]]} at axis ${a} of input shaped ${JSON.stringify(o)}, but got dimension ${o[a]}`)}}function D0(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let a=0;a<r;++a)s.push([]);const o=[];for(let a=0;a<t.length;++a){const l=t[a],u=n3(e,l);for(const d of u)o.indexOf(d)===-1&&(s[a].push(d),o.push(d))}return{path:t,steps:s}}function A0(n){return n.every((e,t)=>e===t)}function n3(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function F0(n,e,t=0){let s=[];if(typeof e=="number")O(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((a,l)=>(l===-1&&(a+=1),a),0);O(r<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const a=e.reduce((l,u)=>u>0?l+u:l);e[o]=n.shape[t]-a}O(n.shape[t]===e.reduce((a,l)=>a+l),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UC(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function GC(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function HC(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jC(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function qC(n,e){return`size ${n} must be non-negative, not ${e}`}function KC(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function XC(n,e){const t=oe(n),s=oe(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function YC(n,e){const t=oe(n),s=oe(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kg(){return"segment ids must be >= 0"}function QC(){return"segment ids are not increasing"}function ZC(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function JC(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ek(n,e){let t=!1,s;for(n<=y0?(s=n,t=!0):s=ad(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=ad(n,s+1);return s}function tk(n,e,t){const s=[],r=n.length;for(let o=0;o<r;o++)o!==e?s.push(n[o]):s.push(t);return s}function P0(n,e,t,s){const r=e.shape.length,o=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>o)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${o}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let f=0;f<s;++f)if(n.shape[f]!==e.shape[f])throw new Error(`x.shape[${f}]: ${n.shape[f]} should be equal to indices.shape[${f}]: ${e.shape[f]}.`);const a=n.shape[t],l=[];let u=1,d=1,p=1;for(let f=0;f<s;++f)l.push(n.shape[f]),u*=n.shape[f];for(let f=s;f<t;f++)l.push(n.shape[f]),d*=n.shape[f];for(let f=s;f<r;f++)l.push(e.shape[f]);for(let f=t+1;f<o;f++)l.push(n.shape[f]),p*=n.shape[f];return{batchSize:u,sliceSize:p,outerSize:d,dimSize:a,outputShape:l}}const s3=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:P0,computeOutShape:tk,segOpComputeOptimalWindowSize:ek},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rr(n){try{return n.map(e=>tr(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function nk(n){return n.map(e=>Es(e))}const sk=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:C0,ERF_A2:k0,ERF_A3:N0,ERF_A4:I0,ERF_A5:T0,ERF_P:S0,PARALLELIZE_THRESHOLD:y0,get RowPartitionType(){return fs},SELU_SCALE:$0,SELU_SCALEALPHA:b0,applyActivation:Af,assertAndGetBroadcastShape:Le,assertAxesAreInnerMostDims:Ut,assertParamsConsistent:g0,assignToTypedArray:MC,axesAreInnerMostDims:ky,calculateShapes:Kr,checkEinsumDimSizes:O0,checkPadOnDimRoundingMode:ts,combineLocations:L$,combineRaggedTensorToTensorShapes:DC,complexWithEvenIndex:VC,complexWithOddIndex:BC,computeConv2DInfo:At,computeConv3DInfo:qr,computeDefaultPad:xy,computeDilation2DInfo:du,computeOptimalWindowSize:zf,computeOutAndReduceShapes:Wt,computeOutShape:Rs,computePool2DInfo:es,computePool3DInfo:ir,convertConv2DDataFormat:lr,decodeEinsumEquation:R0,eitherStridesOrDilationsAreOne:Yt,expandShapeToKeepDim:It,exponent:WC,exponents:zC,fromStringArrayToUint8:nk,fromUint8ToStringArray:rr,getAxesPermutation:wt,getBroadcastDims:_o,getComplexWithIndex:E0,getEinsumComputePath:D0,getEinsumPermutation:_0,getFusedBiasGradient:Df,getFusedDyActivation:Of,getImageCenter:x0,getInnerMostAxes:bt,getPermuted:wu,getRaggedRank:FC,getReductionAxes:$y,getReshaped:vu,getReshapedPermuted:bu,getRowPartitionTypesHelper:AC,getSliceBeginCoords:v0,getSliceSize:w0,getSparseFillEmptyRowsIndicesDenseShapeMismatch:UC,getSparseFillEmptyRowsNegativeIndexErrorMessage:GC,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:HC,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:KC,getSparseReshapeInputOutputMismatchErrorMessage:YC,getSparseReshapeInputOutputMultipleErrorMessage:XC,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:jC,getSparseReshapeNegativeOutputDimErrorMessage:qC,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:JC,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:kg,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:QC,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:ZC,getUndoAxesPermutation:hu,isIdentityPermutation:A0,log:DT,mergeRealAndImagArrays:sr,prepareAndValidate:Mf,prepareSplitSize:F0,segment_util:s3,shouldFuse:Ff,slice_util:RC,splitRealAndImagArrays:LC,stridesOrDilationsArePositive:Ro,tupleValuesAreOne:Ki,upcastType:fn,validateDefaultValueShape:PC,validateInput:Ef,validateUpdateShape:Qy,warn:Vn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r3=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:Pf,nonMaxSuppressionV4Impl:Lf,nonMaxSuppressionV5Impl:Vf,whereImpl:Rf},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */gP();const o3=Object.freeze(Object.defineProperty({__proto__:null,Abs:Ed,Acos:rl,Acosh:ol,AdadeltaOptimizer:t0,AdagradOptimizer:n0,AdamOptimizer:s0,AdamaxOptimizer:r0,Add:Fa,AddN:Rd,All:_d,Any:Od,ArgMax:Dd,ArgMin:Ad,Asin:al,Asinh:il,Atan:ll,Atan2:cl,Atanh:ul,AvgPool:Fd,AvgPool3D:Pd,AvgPool3DGrad:Zg,AvgPoolGrad:Qg,BatchMatMul:Ld,BatchToSpaceND:Vd,Bincount:Bd,BitwiseAnd:dl,BroadcastArgs:Md,BroadcastTo:NT,Cast:pl,Ceil:fl,ClipByValue:hl,Complex:zd,ComplexAbs:Wd,Concat:Ud,Conv2D:Gd,Conv2DBackpropFilter:Hd,Conv2DBackpropInput:jd,Conv3D:qd,Conv3DBackpropFilterV2:Jg,Conv3DBackpropInputV2:Kd,Cos:ml,Cosh:gl,CropAndResize:Qd,Cumprod:Xd,Cumsum:Yd,DataStorage:Hg,DenseBincount:Zd,DepthToSpace:Jd,DepthwiseConv2dNative:ep,DepthwiseConv2dNativeBackpropFilter:tp,DepthwiseConv2dNativeBackpropInput:np,Diag:sp,Dilation2D:rp,Dilation2DBackpropFilter:lg,Dilation2DBackpropInput:ig,Draw:op,get ENV(){return Xg},Einsum:ap,Elu:xl,EluGrad:ey,Environment:wb,Equal:wl,Erf:vl,Exp:bl,ExpandDims:ip,Expm1:$l,FFT:lp,Fill:up,FlipLeftRight:cp,Floor:Sl,FloorDiv:Cl,FromPixels:id,FusedBatchNorm:dp,FusedConv2D:Mi,FusedDepthwiseConv2D:zi,GatherNd:fp,GatherV2:pp,Greater:kl,GreaterEqual:Nl,IFFT:hp,Identity:Il,Imag:mp,IsFinite:Tl,IsInf:El,IsNan:Rl,KernelBackend:Nd,LRN:xp,LRNGrad:ty,LeakyRelu:gp,Less:_l,LessEqual:Ol,LinSpace:yp,Log:Dl,Log1p:Al,LogSoftmax:TT,LogicalAnd:Fl,LogicalNot:Pl,LogicalOr:Ll,LogicalXor:IT,LowerBound:ET,MatrixBandPart:RT,Max:vp,MaxPool:wp,MaxPool3D:bp,MaxPool3DGrad:sy,MaxPoolGrad:ny,MaxPoolWithArgmax:$p,Maximum:Vl,Mean:Sp,Min:Cp,Minimum:Bl,MirrorPad:kp,Mod:Ml,MomentumOptimizer:o0,Multinomial:Np,Multiply:zl,Neg:Ip,NonMaxSuppressionV3:Tp,NonMaxSuppressionV4:Ep,NonMaxSuppressionV5:Rp,NotEqual:Wl,OP_SCOPE_SUFFIX:dy,OneHot:Op,OnesLike:_p,Optimizer:Yr,OptimizerConstructors:_C,Pack:Dp,PadV2:Ap,Pool:_T,Pow:Ul,Prelu:Fp,Prod:Pp,RMSPropOptimizer:a0,RaggedGather:Lp,RaggedRange:Vp,RaggedTensorToTensor:Bp,Range:Mp,get Rank(){return dg},Real:zp,RealDiv:yl,Reciprocal:Gl,get Reduction(){return rn},Relu:Hl,Relu6:jl,Reshape:Wp,ResizeBilinear:Gp,ResizeBilinearGrad:oy,ResizeNearestNeighbor:Up,ResizeNearestNeighborGrad:ry,Reverse:Hp,RotateWithOffset:yf,Round:ql,Rsqrt:Kl,SGDOptimizer:Bf,ScatterNd:jp,SearchSorted:Kp,Select:Xp,Selu:Xl,Sigmoid:Jl,Sign:Zl,Sin:Yl,Sinh:Ql,Slice:Yp,Softmax:ef,Softplus:eu,SpaceToBatchND:Zp,SparseFillEmptyRows:tf,SparseReshape:nf,SparseSegmentMean:sf,SparseSegmentSum:rf,SparseToDense:of,SplitV:Jp,Sqrt:tu,Square:ay,SquaredDifference:nu,StaticRegexReplace:su,Step:lu,StridedSlice:af,StringNGrams:lf,StringSplit:uf,StringToHashBucketFast:cf,Sub:ru,Sum:Qp,Tan:ou,Tanh:au,Tensor:yt,TensorBuffer:kt,TensorScatterUpdate:qp,Tile:iu,TopK:df,Transform:pf,Transpose:ya,Unique:ff,Unpack:hf,UnsortedSegmentSum:mf,UpperBound:OT,Variable:Gi,ZerosLike:gf,_FusedMatMul:Bi,abs:Nn,acos:Xb,acosh:Yb,add:_e,addN:Qb,all:Zb,any:Jb,argMax:e$,argMin:t$,asin:n$,asinh:s$,atan:r$,atan2:o$,atanh:a$,avgPool:vy,avgPool3d:i$,backend:Lb,backend_util:sk,basicLSTMCell:l$,batchNorm:pu,batchNorm2d:u$,batchNorm3d:c$,batchNorm4d:d$,batchToSpaceND:wy,bincount:by,bitwiseAnd:p$,booleanMaskAsync:QS,broadcastArgs:f$,broadcastTo:wa,broadcast_util:x_,browser:jP,buffer:Ae,cast:at,ceil:h$,clipByValue:m$,clone:Js,complex:nr,concat:Xt,concat1d:g$,concat2d:y$,concat3d:x$,concat4d:v$,conv1d:w$,conv2d:fu,conv2dTranspose:$$,conv3d:S$,conv3dTranspose:C$,copyRegisteredKernels:LT,cos:k$,cosh:N$,cosineWindow:_f,cumprod:I$,cumsum:T$,customGrad:As,denseBincount:E$,deprecationWarn:gE,depthToSpace:R$,depthwiseConv2d:wf,device_util:cE,diag:_$,dilation2d:O$,disableDeprecationWarnings:mE,dispose:an,disposeVariables:yE,div:ot,divNoNan:D$,dot:A$,dropout:nC,einsum:xo,elu:Cy,enableDebugMode:hE,enableProdMode:fE,enclosingPowerOfTwo:Jy,engine:ds,ensureShape:F$,env:J,equal:Sy,erf:P$,euclideanNorm:B$,exp:zr,expandDims:Ks,expm1:M$,eye:Ny,fft:Nf,fill:Pa,findBackend:CE,findBackendFactory:kE,floor:Iy,floorDiv:yy,fused:rC,gather:Ty,gatherND:tC,gather_util:qP,getBackend:Pb,getGradient:ug,getKernel:Ui,getKernelsForBackend:ld,grad:tO,grads:nO,greater:gu,greaterEqual:Ey,ifft:Zi,imag:yu,image:uC,inTopKAsync:sC,io:u0,irfft:qy,isFinite:z$,isInf:W$,isNaN:U$,keep:hs,kernel_impls:r3,leakyRelu:Ry,less:pd,lessEqual:bf,linalg:cC,linspace:G$,localResponseNormalization:H$,log:Na,log1p:_y,logSigmoid:q$,logSoftmax:K$,logSumExp:Dy,logicalAnd:Xi,logicalNot:Ay,logicalOr:Fy,logicalXor:X$,losses:dC,lowerBound:Y$,matMul:qe,math:PP,max:ko,maxPool:Py,maxPool3d:Q$,maxPoolWithArgmax:Z$,maximum:Ly,mean:Yi,memory:xE,meshgrid:J$,min:dd,minimum:Qi,mirrorPad:eS,mod:tS,moments:nS,movingAverage:ZS,mul:xe,multiRNNCell:sS,multinomial:rS,neg:ys,nextFrame:OC,norm:mu,notEqual:Vy,oneHot:fd,ones:Ar,onesLike:oS,op:M,outerProduct:aS,pad:La,pad1d:iS,pad2d:lS,pad3d:uS,pad4d:cS,pool:dS,pow:ka,prelu:My,print:gy,prod:pS,profile:vE,raggedGather:fS,raggedRange:hS,raggedTensorToTensor:mS,rand:gS,randomGamma:vS,randomNormal:Gy,randomStandardNormal:wS,randomUniform:kf,randomUniformInt:bS,range:Ia,ready:$E,real:Ta,reciprocal:$S,registerBackend:py,registerGradient:AT,registerKernel:xf,relu:xu,relu6:Hy,removeBackend:SE,reshape:le,reverse:Ur,reverse1d:SS,reverse2d:CS,reverse3d:kS,reverse4d:NS,rfft:If,round:jy,rsqrt:IS,scalar:Ve,scatterND:JS,scatter_util:aA,searchSorted:Sf,selu:TS,separableConv2d:ES,serialization:hP,setBackend:bE,setPlatform:NE,setdiff1dAsync:RS,sigmoid:Co,sign:_S,signal:lC,sin:OS,sinh:DS,slice:tt,slice1d:AS,slice2d:FS,slice3d:PS,slice4d:LS,slice_util:RC,softmax:VS,softplus:Oy,spaceToBatchND:By,sparse:pC,sparseToDense:eC,spectral:iC,split:Ea,sqrt:Ds,square:Jn,squaredDifference:Ky,squeeze:Tf,stack:Fs,step:Xy,stridedSlice:BS,string:fC,sub:Fe,sum:rt,sumOutType:vf,tan:MS,tanh:cd,tensor:gs,tensor1d:Bn,tensor2d:$a,tensor3d:Yy,tensor4d:zS,tensor5d:WS,tensor6d:US,tensorScatterUpdate:GS,tensor_util:oE,test_util:vD,tidy:Ue,tile:ba,time:wE,topk:HS,train:JP,transpose:Ji,truncatedNormal:jS,unique:qS,unregisterGradient:PT,unregisterKernel:FT,unsortedSegmentSum:KS,unstack:Xr,upcastType:fn,upperBound:XS,util:jT,valueAndGrad:sO,valueAndGrads:rO,variable:YS,variableGrads:j$,version_core:ZP,where:er,whereAsync:Zy,zeros:Wr,zerosLike:En},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a3=J();a3.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Cn;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Cn||(Cn={}));var bw;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(bw||(bw={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L0={};function i3(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};L0[n]=t}function rk(n){return L0[n]}function l3(n){delete L0[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k(n,e,t,s,r){const o=e.inputParams[n];if(o&&o.inputIndexStart!==void 0){const l=o.inputIndexStart,u=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?l+1:o.inputIndexEnd,d=l<0?e.inputNames.length+l:l;if(o.type==="tensor")return Vt(e.inputNames[d],t,s,r);if(o.type==="tensors"){const m=e.inputs.slice(l,u);return e.inputNames.slice(l,u).filter((x,w)=>{var v;return((v=m[w])===null||v===void 0?void 0:v.op)!=="NoOp"}).map(x=>Vt(x,t,s,r))}const p=Vt(e.inputNames[d],t,s,r),f=p.dataSync();return o.type==="number"?f[0]:zn(p.shape,f)}const a=e.attrParams[n];return a&&a.value}function Vt(n,e,t,s){const[r,o]=kn(n,t);if(s!=null){const l=s.getHashTableHandleByName(r);if(l!=null)return l}const a=t.currentContextIds.find(l=>!!e[md(r,l)]);return a!==void 0?e[md(r,a)][o]:void 0}function $w(n,e,t){return e[md(n,t.currentContextId)]}function Xs(n,e){const[t,s,r]=kn(n,e);return[md(t,e&&e.currentContextId),s,r]}function md(n,e){return e?`${n}-${e}`:n}function kn(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const o=e.parseNodeNameCache.get(n);if(o!=null)return o}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const o=s[0],a=s.length===3?s[1]:void 0,l=Number(s[s.length-1]);r=[o,l,a]}return t&&e.parseNodeNameCache.set(n,r),r}function sd(n,e,t){let s=k("pad",n,e,t);if(s==="explicit"){s=k("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)r[o][0]=s[o*2],r[o][1]=s[o*2+1];return r}return s}function Ys(n){return n.kept?n:Js(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u3=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],c3=Object.freeze(Object.defineProperty({__proto__:null,json:u3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d3=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],p3=Object.freeze(Object.defineProperty({__proto__:null,json:d3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f3=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],h3=Object.freeze(Object.defineProperty({__proto__:null,json:f3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m3=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],g3=Object.freeze(Object.defineProperty({__proto__:null,json:m3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y3=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],x3=Object.freeze(Object.defineProperty({__proto__:null,json:y3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v3=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],w3=Object.freeze(Object.defineProperty({__proto__:null,json:v3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b3=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],$3=Object.freeze(Object.defineProperty({__proto__:null,json:b3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S3=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],C3=Object.freeze(Object.defineProperty({__proto__:null,json:S3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k3=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],N3=Object.freeze(Object.defineProperty({__proto__:null,json:k3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I3=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],T3=Object.freeze(Object.defineProperty({__proto__:null,json:I3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E3=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],R3=Object.freeze(Object.defineProperty({__proto__:null,json:E3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _3=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],O3=Object.freeze(Object.defineProperty({__proto__:null,json:_3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D3=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],A3=Object.freeze(Object.defineProperty({__proto__:null,json:D3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F3=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],P3=Object.freeze(Object.defineProperty({__proto__:null,json:F3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L3=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],V3=Object.freeze(Object.defineProperty({__proto__:null,json:L3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B3=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],M3=Object.freeze(Object.defineProperty({__proto__:null,json:B3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z3=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],W3=Object.freeze(Object.defineProperty({__proto__:null,json:z3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U3=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],G3=Object.freeze(Object.defineProperty({__proto__:null,json:U3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H3=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],j3=Object.freeze(Object.defineProperty({__proto__:null,json:H3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sw{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[c3,p3,h3,g3,x3,w3,$3,C3,N3,T3,R3,O3,A3,P3,V3,M3,W3,G3,j3],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],o=[],a=[],l=s.reduce((w,v)=>(w[v.name]=this.mapNode(v),v.op.startsWith("Placeholder")?r.push(w[v.name]):v.op==="Const"?o.push(w[v.name]):(v.input==null||v.input.length===0)&&a.push(w[v.name]),w),{});let u=[];const d=[];let p={},f={};t!=null&&(p=this.mapSignatureEntries(t.inputs),f=this.mapSignatureEntries(t.outputs));const m=Object.keys(l);m.forEach(w=>{const v=l[w];v.inputNames.forEach((b,C)=>{const[I,,N]=Xs(b),R=l[I];if(R.outputs!=null){const D=R.outputs.indexOf(N);if(D!==-1){const F=`${I}:${D}`;v.inputNames[C]=F}}v.inputs.push(R),R.children.push(v)})}),Object.keys(f).length===0?m.forEach(w=>{const v=l[w];v.children.length===0&&d.push(v)}):Object.keys(f).forEach(w=>{const[v]=Xs(w),b=l[v];b!=null&&(b.signatureKey=f[w],d.push(b))}),Object.keys(p).length>0?Object.keys(p).forEach(w=>{const[v]=Xs(w),b=l[v];b&&(b.signatureKey=p[w],u.push(b))}):u=r;let g={};e.library!=null&&e.library.function!=null&&(g=e.library.function.reduce((w,v)=>(w[v.signature.name]=this.mapFunction(v),w),{}));const x={nodes:l,inputs:u,outputs:d,weights:o,placeholders:r,signature:t,functions:g};return a.length>0&&(x.initNodes=a),x}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=rk(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,o)=>(r[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,o)=>{const a=o.type;let l;switch(o.type){case"string":l=Ng(e.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Ng(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":l=Dg(e.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Dg(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":l=Tg(e.attr,o.tfName,o.defaultValue||0),l===void 0&&o.tfDeprecatedName&&(l=Tg(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":l=Og(e.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Og(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":l=Ig(e.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Ig(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":l=Fg(e.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Fg(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":l=_g(e.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=_g(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":l=Ag(e.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Ag(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":l=Eg(e.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Eg(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":l=Rg(e.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Rg(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":l=Cw(e.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Cw(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return r[o.name]={value:l,type:a},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let o={};t!=null&&(o=t.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op==="Const"&&r.push(f[m.name]),f),{}));const a=[],l=[];e.signature.inputArg.forEach(f=>{const[m]=Xs(f.name),g={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:V0(f.type),type:"dtype"}},children:[]};g.signatureKey=f.name,a.push(g),o[m]=g}),Object.keys(o).forEach(f=>{const m=o[f];m.inputNames.forEach((g,x)=>{const[w,,v]=Xs(g),b=o[w];if(b.outputs!=null){const C=b.outputs.indexOf(v);if(C!==-1){const I=`${w}:${C}`;m.inputNames[x]=I}}m.inputs.push(b),b.children.push(m)})});const d=e.ret;e.signature.outputArg.forEach(f=>{const[m,g]=Xs(d[f.name]),x=o[m];x!=null&&(x.defaultOutput=g,l.push(x))});const p=this.mapArgsToSignature(e);return{nodes:o,inputs:a,outputs:l,weights:r,placeholders:s,signature:p}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function q3(n){const e=J().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function ok(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):q3(n);return e?t:t.toLowerCase()}function Ng(n,e,t,s=!1){const r=n[e];return r!=null?ok(r.s,s):t}function Ig(n,e,t){const s=n[e];return s?s.b:t}function Tg(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function V0(n){switch(typeof n=="string"&&(n=Cn[n]),n){case Cn.DT_FLOAT:case Cn.DT_HALF:return"float32";case Cn.DT_INT32:case Cn.DT_INT64:case Cn.DT_INT8:case Cn.DT_UINT8:return"int32";case Cn.DT_BOOL:return"bool";case Cn.DT_DOUBLE:return"float32";case Cn.DT_STRING:return"string";case Cn.DT_COMPLEX64:case Cn.DT_COMPLEX128:return"complex64";default:return null}}function Cw(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function Eg(n,e,t){const s=n[e];return s&&s.type?V0(s.type):t}function Rg(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>V0(r)):t}function ak(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function _g(n,e,t){const s=n[e];return s&&s.shape?ak(s.shape):t}function Og(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function Dg(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(o=>ok(o,s)):t}function Ag(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>ak(r)):t}function Fg(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K3{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,o)=>(r[o]=this.getAttr(o),r),{}))}getInput(e){return Vt(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return Vt(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return Tg(this.node.rawAttrs,e,t);if(s.s!=null)return Ng(this.node.rawAttrs,e,t);if(s.b!=null)return Ig(this.node.rawAttrs,e,t);if(s.shape!=null)return _g(this.node.rawAttrs,e,t);if(s.type!=null)return Eg(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return Og(this.node.rawAttrs,e,t);if(s.list.s!=null)return Dg(this.node.rawAttrs,e,t);if(s.list.shape!=null)return Ag(this.node.rawAttrs,e,t);if(s.list.b!=null)return Fg(this.node.rawAttrs,e,t);if(s.list.type!=null)return Rg(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gt=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:dy,abs:Nn,acos:Xb,acosh:Yb,add:_e,addN:Qb,all:Zb,any:Jb,argMax:e$,argMin:t$,asin:n$,asinh:s$,atan:r$,atan2:o$,atanh:a$,avgPool:vy,avgPool3d:i$,basicLSTMCell:l$,batchNorm:pu,batchNorm2d:u$,batchNorm3d:c$,batchNorm4d:d$,batchToSpaceND:wy,bincount:by,bitwiseAnd:p$,booleanMaskAsync:QS,broadcastArgs:f$,broadcastTo:wa,buffer:Ae,cast:at,ceil:h$,clipByValue:m$,clone:Js,complex:nr,concat:Xt,concat1d:g$,concat2d:y$,concat3d:x$,concat4d:v$,conv1d:w$,conv2d:fu,conv2dTranspose:$$,conv3d:S$,conv3dTranspose:C$,cos:k$,cosh:N$,cosineWindow:_f,cumprod:I$,cumsum:T$,denseBincount:E$,depthToSpace:R$,depthwiseConv2d:wf,diag:_$,dilation2d:O$,div:ot,divNoNan:D$,dot:A$,dropout:nC,einsum:xo,elu:Cy,enclosingPowerOfTwo:Jy,ensureShape:F$,equal:Sy,erf:P$,euclideanNorm:B$,exp:zr,expandDims:Ks,expm1:M$,eye:Ny,fft:Nf,fill:Pa,floor:Iy,floorDiv:yy,fused:rC,gather:Ty,gatherND:tC,greater:gu,greaterEqual:Ey,ifft:Zi,imag:yu,image:uC,inTopKAsync:sC,irfft:qy,isFinite:z$,isInf:W$,isNaN:U$,leakyRelu:Ry,less:pd,lessEqual:bf,linalg:cC,linspace:G$,localResponseNormalization:H$,log:Na,log1p:_y,logSigmoid:q$,logSoftmax:K$,logSumExp:Dy,logicalAnd:Xi,logicalNot:Ay,logicalOr:Fy,logicalXor:X$,losses:dC,lowerBound:Y$,matMul:qe,max:ko,maxPool:Py,maxPool3d:Q$,maxPoolWithArgmax:Z$,maximum:Ly,mean:Yi,meshgrid:J$,min:dd,minimum:Qi,mirrorPad:eS,mod:tS,moments:nS,movingAverage:ZS,mul:xe,multiRNNCell:sS,multinomial:rS,neg:ys,norm:mu,notEqual:Vy,oneHot:fd,ones:Ar,onesLike:oS,op:M,outerProduct:aS,pad:La,pad1d:iS,pad2d:lS,pad3d:uS,pad4d:cS,pool:dS,pow:ka,prelu:My,print:gy,prod:pS,raggedGather:fS,raggedRange:hS,raggedTensorToTensor:mS,rand:gS,randomGamma:vS,randomNormal:Gy,randomStandardNormal:wS,randomUniform:kf,randomUniformInt:bS,range:Ia,real:Ta,reciprocal:$S,relu:xu,relu6:Hy,reshape:le,reverse:Ur,reverse1d:SS,reverse2d:CS,reverse3d:kS,reverse4d:NS,rfft:If,round:jy,rsqrt:IS,scalar:Ve,scatterND:JS,searchSorted:Sf,selu:TS,separableConv2d:ES,setdiff1dAsync:RS,sigmoid:Co,sign:_S,signal:lC,sin:OS,sinh:DS,slice:tt,slice1d:AS,slice2d:FS,slice3d:PS,slice4d:LS,softmax:VS,softplus:Oy,spaceToBatchND:By,sparse:pC,sparseToDense:eC,spectral:iC,split:Ea,sqrt:Ds,square:Jn,squaredDifference:Ky,squeeze:Tf,stack:Fs,step:Xy,stridedSlice:BS,string:fC,sub:Fe,sum:rt,tan:MS,tanh:cd,tensor:gs,tensor1d:Bn,tensor2d:$a,tensor3d:Yy,tensor4d:zS,tensor5d:WS,tensor6d:US,tensorScatterUpdate:GS,tile:ba,topk:HS,transpose:Ji,truncatedNormal:jS,unique:qS,unsortedSegmentSum:KS,unstack:Xr,upperBound:XS,variable:YS,where:er,whereAsync:Zy,zeros:Wr,zerosLike:En},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X3=(n,e,t,s=Gt)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(k("a",n,e,t),k("b",n,e,t))];case"AddN":return[s.addN(k("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(k("a",n,e,t),k("b",n,e,t))];case"Mul":return[s.mul(k("a",n,e,t),k("b",n,e,t))];case"RealDiv":case"Div":return[s.div(k("a",n,e,t),k("b",n,e,t))];case"DivNoNan":return[s.divNoNan(k("a",n,e,t),k("b",n,e,t))];case"FloorDiv":return[s.floorDiv(k("a",n,e,t),k("b",n,e,t))];case"Sub":return[s.sub(k("a",n,e,t),k("b",n,e,t))];case"Minimum":return[s.minimum(k("a",n,e,t),k("b",n,e,t))];case"Maximum":return[s.maximum(k("a",n,e,t),k("b",n,e,t))];case"Pow":return[s.pow(k("a",n,e,t),k("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(k("a",n,e,t),k("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y3=(n,e,t,s=Gt)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(k("x",n,e,t))];case"Acos":return[s.acos(k("x",n,e,t))];case"Acosh":return[s.acosh(k("x",n,e,t))];case"Asin":return[s.asin(k("x",n,e,t))];case"Asinh":return[s.asinh(k("x",n,e,t))];case"Atan":return[s.atan(k("x",n,e,t))];case"Atan2":return[s.atan2(k("x",n,e,t),k("y",n,e,t))];case"Atanh":return[s.atanh(k("x",n,e,t))];case"Ceil":return[s.ceil(k("x",n,e,t))];case"Complex":return[s.complex(k("real",n,e,t),k("imag",n,e,t))];case"Cos":return[s.cos(k("x",n,e,t))];case"Cosh":return[s.cosh(k("x",n,e,t))];case"Elu":return[s.elu(k("x",n,e,t))];case"Erf":return[s.erf(k("x",n,e,t))];case"Exp":return[s.exp(k("x",n,e,t))];case"Expm1":return[s.expm1(k("x",n,e,t))];case"Floor":return[s.floor(k("x",n,e,t))];case"Log":return[s.log(k("x",n,e,t))];case"Log1p":return[s.log1p(k("x",n,e,t))];case"Imag":return[s.imag(k("x",n,e,t))];case"Neg":return[s.neg(k("x",n,e,t))];case"Reciprocal":return[s.reciprocal(k("x",n,e,t))];case"Real":return[s.real(k("x",n,e,t))];case"Relu":return[s.relu(k("x",n,e,t))];case"Round":return[s.round(k("x",n,e,t))];case"Selu":return[s.selu(k("x",n,e,t))];case"Sigmoid":return[s.sigmoid(k("x",n,e,t))];case"Sin":return[s.sin(k("x",n,e,t))];case"Sign":return[s.sign(k("x",n,e,t))];case"Sinh":return[s.sinh(k("x",n,e,t))];case"Softplus":return[s.softplus(k("x",n,e,t))];case"Sqrt":return[s.sqrt(k("x",n,e,t))];case"Square":return[s.square(k("x",n,e,t))];case"Tanh":return[s.tanh(k("x",n,e,t))];case"Tan":return[s.tan(k("x",n,e,t))];case"ClipByValue":return[s.clipByValue(k("x",n,e,t),k("clipValueMin",n,e,t),k("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(k("x",n,e,t))];case"Rsqrt":return[s.rsqrt(Vt(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(k("x",n,e,t),k("alpha",n,e,t))];case"Prelu":return[s.prelu(k("x",n,e,t),k("alpha",n,e,t))];case"IsNan":return[s.isNaN(Vt(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(Vt(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(Vt(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qn(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){O(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],o=e[s];O(r<0||o<0||r===o,()=>t+` Shapes ${n} and ${e} must match`)}}}function kw(n){return!(typeof n=="number"||n.some(e=>e<0))}function _i(n,e,t){let s=Pg(n,t);const r=!kw(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(o=>{s=Pg(o.shape,s)}),!kw(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function Pg(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],o=e[s];if(r>=0&&o>=0&&r!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:o}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q3{constructor(e,t,s,r,o,a,l){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=a,this.clearAfterRead=l,this.tensors=[],this.closed_=!1,this.idTensor=Ve(0),hs(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Qn(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,hs(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return gs([],[0].concat(this.elementShape));const s=this.readMany(e);return Qn(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Fs(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return gs([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return Qn(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),Xt(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Xr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(u=>(s+=u,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=s===0?0:t.size/s,a=[];Ue(()=>{t=le(t,[1,s,o]);for(let u=0;u<e.length;++u){const p=[0,u===0?0:r[u-1],0],f=[1,e[u],o];a[u]=le(tt(t,p,f),this.elementShape)}return a});const l=[];for(let u=0;u<e.length;u++)l[u]=u;this.writeMany(l,a)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Do{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(o=>{if(s!==o.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${o.dtype}`);Qn(t,o.shape,"TensorList shape mismatch: "),hs(o)}),this.idTensor=Ve(0),this.maxNumElements=r,hs(this.idTensor)}copy(){return new Do([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);Qn(e,this.elementShape,"TensorList shape mismatch: ");const r=_i(this.elementShape,this.tensors,e);return Ue(()=>{const o=this.tensors.map(a=>le(a,r));return Fs(o,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=_i(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,Qn(r.shape,e,"TensorList shape mismatch: "),le(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Qn(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");hs(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Do([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Qn(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=_i(this.elementShape,this.tensors,t);return le(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Qn(this.elementShape,t.shape,"TensorList shape mismatch: "),hs(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Qn(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=_i(this.elementShape,this.tensors,s);return e.length===0?gs([],[0].concat(r)):Ue(()=>{const o=e.map(a=>le(this.tensors[a],r));return Fs(o,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Qn(this.elementShape,t,"TensorList shape mismatch: ");const s=_i(this.elementShape,this.tensors,t);return this.size()===0?gs([],[0].concat(s)):Ue(()=>{const r=this.tensors.map(o=>le(o,s));return Xt(r,0)})}}function Z3(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);Qn(r,e,"TensorList shape mismatch: ");const o=Xr(n);return new Do(o,e,s)}function J3(n,e,t,s){return new Do([],n,e,s)}function eL(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const o=new Do([],t,n.dtype,s),a=Xr(n,0);return e.forEach((l,u)=>{o.setItem(l,a[u])}),o}function tL(n,e,t){let s=0;const r=e.map(p=>(s+=p,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const o=n.shape.slice(1),a=Pg(o,t),l=s===0?0:n.size/s,u=Ue(()=>{const p=[];n=le(n,[1,s,l]);for(let f=0;f<e.length;++f){const g=[0,f===0?0:r[f-1],0],x=[1,e[f],l];p[f]=le(tt(n,g,x),a)}return n.dispose(),p}),d=new Do([],t,n.dtype,e.length);for(let p=0;p<u.length;p++)d.setItem(p,u[p]);return d}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nL=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=k("thenBranch",n,e,t),r=k("elseBranch",n,e,t),o=k("cond",n,e,t),a=k("args",n,e,t);return(await o.data())[0]?t.functionMap[s].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=k("body",n,e,t),r=k("cond",n,e,t),o=k("args",n,e,t),a=await t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap),l=o.map(p=>p.id);let u=await a[0].data();a.forEach(p=>{!p.kept&&l.indexOf(p.id)===-1&&p.dispose()});let d=o;for(;u[0];){const p=d;d=await t.functionMap[s].executeFunctionAsync(d,t.tensorArrayMap,t.tensorListMap);const f=d.map(g=>g.id);p.forEach(g=>{!g.kept&&l.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()});const m=await t.functionMap[r].executeFunctionAsync(d,t.tensorArrayMap,t.tensorListMap);u=await m[0].data(),m.forEach(g=>{!g.kept&&l.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()})}return d}case"LoopCond":{const s=k("pred",n,e,t);return[Ys(s)]}case"Switch":{const s=k("pred",n,e,t);let r=k("data",n,e,t);return r.kept||(r=Ys(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>Vt(r,e,t)!==void 0);if(s){const r=Vt(s,e,t);return[Ys(r)]}return}case"Enter":{const s=k("frameName",n,e,t),r=k("tensor",n,e,t);return t.enterFrame(s),[Ys(r)]}case"Exit":{const s=k("tensor",n,e,t);return t.exitFrame(),[Ys(s)]}case"NextIteration":{const s=k("tensor",n,e,t);return t.nextIteration(),[Ys(s)]}case"TensorArrayV3":{const s=k("size",n,e,t),r=k("dtype",n,e,t),o=k("elementShape",n,e,t),a=k("dynamicSize",n,e,t),l=k("clearAfterRead",n,e,t),u=k("identicalElementShapes",n,e,t),d=k("name",n,e,t),p=new Q3(d,r,s,o,u,a,l);return t.addTensorArray(p),[p.idTensor,Ve(1)]}case"TensorArrayWriteV3":{const s=k("tensorArrayId",n,e,t),r=k("index",n,e,t),o=k("tensor",n,e,t),a=t.getTensorArray(s.id);return a.write(r,o),[a.idTensor]}case"TensorArrayReadV3":{const s=k("tensorArrayId",n,e,t),r=k("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=k("tensorArrayId",n,e,t),r=k("indices",n,e,t),o=k("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,o)]}case"TensorArrayScatterV3":{const s=k("tensorArrayId",n,e,t),r=k("indices",n,e,t),o=k("tensor",n,e,t),a=t.getTensorArray(s.id);return a.scatter(r,o),[a.idTensor]}case"TensorArrayConcatV3":{const s=k("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),o=k("dtype",n,e,t);return[r.concat(o)]}case"TensorArraySplitV3":{const s=k("tensorArrayId",n,e,t),r=k("tensor",n,e,t),o=k("lengths",n,e,t),a=t.getTensorArray(s.id);return a.split(o,r),[a.idTensor]}case"TensorArraySizeV3":{const s=k("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[Ve(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=k("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=k("tensorListId",n,e,t),r=k("index",n,e,t),o=k("tensor",n,e,t),a=t.getTensorList(s.id);return a.setItem(r,o),[a.idTensor]}case"TensorListGetItem":{const s=k("tensorListId",n,e,t),r=k("index",n,e,t),o=k("elementShape",n,e,t),a=k("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=k("indices",n,e,t),r=k("tensor",n,e,t),o=k("elementShape",n,e,t),a=k("numElements",n,e,t),l=eL(r,s,o,a);return t.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=k("elementShape",n,e,t),r=k("elementDType",n,e,t);let o;n.op==="TensorListReserve"?o="numElements":o="maxNumElements";const a=k(o,n,e,t),l=n.op==="TensorListReserve"?-1:a,u=J3(s,r,a,l);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=k("tensorListId",n,e,t),r=k("indices",n,e,t),o=k("elementShape",n,e,t),a=k("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,a,o)]}case"TensorListStack":{const s=k("tensorListId",n,e,t),r=k("elementShape",n,e,t),o=k("elementDType",n,e,t),a=k("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,o,a)]}case"TensorListFromTensor":{const s=k("tensor",n,e,t),r=k("elementShape",n,e,t),o=k("elementDType",n,e,t),a=Z3(s,r,o);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=k("tensorListId",n,e,t),r=t.getTensorList(s.id),o=k("dtype",n,e,t),a=k("elementShape",n,e,t);return[r.concat(o,a)]}case"TensorListPushBack":{const s=k("tensorListId",n,e,t),r=k("tensor",n,e,t),o=t.getTensorList(s.id);return o.pushBack(r),[o.idTensor]}case"TensorListPopBack":{const s=k("tensorListId",n,e,t),r=k("elementShape",n,e,t),o=k("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,o)]}case"TensorListSplit":{const s=k("tensor",n,e,t),r=k("elementShape",n,e,t),o=k("lengths",n,e,t),a=tL(s,o,r);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=k("tensorListId",n,e,t),r=t.getTensorList(s.id);return[Ve(r.size(),"int32")]}case"TensorListResize":{const s=k("tensorListId",n,e,t),r=k("size",n,e,t),a=t.getTensorList(s.id).resize(r);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nw(n,e,t){const[s,r]=k("fusedOps",n,e,t),o=s==="biasadd",a=!o,l=r==="prelu",u=s==="fusedbatchnorm",d=k("numArgs",n,e,t);if(o){if(l&&d!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!l&&o&&d!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const p=k("strides",n,e,t),f=sd(n,e,t),m=k("dataFormat",n,e,t).toUpperCase(),g=k("dilations",n,e,t);let[x,w]=k("args",n,e,t);a&&(w=x,x=void 0);const v=k("leakyreluAlpha",n,e,t);return{stride:p,pad:f,dataFormat:m,dilations:g,biasArg:x,preluArg:w,activationFunc:r,leakyreluAlpha:v}}const sL=(n,e,t,s=Gt)=>{switch(n.op){case"Conv1D":{const r=k("stride",n,e,t),o=k("pad",n,e,t),a=k("dataFormat",n,e,t).toUpperCase(),l=k("dilation",n,e,t);return[s.conv1d(k("x",n,e,t),k("filter",n,e,t),r,o,a,l)]}case"Conv2D":{const r=k("strides",n,e,t),o=sd(n,e,t),a=k("dataFormat",n,e,t).toUpperCase(),l=k("dilations",n,e,t);return[s.conv2d(k("x",n,e,t),k("filter",n,e,t),[r[1],r[2]],o,a,[l[1],l[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:a,dilations:l,biasArg:u,preluArg:d,activationFunc:p,leakyreluAlpha:f}=Nw(n,e,t);return[s.fused.conv2d({x:k("x",n,e,t),filter:k("filter",n,e,t),strides:[r[1],r[2]],pad:o,dataFormat:a,dilations:[l[1],l[2]],bias:u,activation:p,preluActivationWeights:d,leakyreluAlpha:f})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:a,dilations:l,biasArg:u,preluArg:d,activationFunc:p,leakyreluAlpha:f}=Nw(n,e,t);return[s.fused.depthwiseConv2d({x:k("x",n,e,t),filter:k("filter",n,e,t),strides:[r[1],r[2]],pad:o,dataFormat:a,dilations:[l[1],l[2]],bias:u,activation:p,preluActivationWeights:d,leakyreluAlpha:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=k("outputShape",n,e,t),o=k("strides",n,e,t),a=sd(n,e,t);return[s.conv2dTranspose(k("x",n,e,t),k("filter",n,e,t),r,[o[1],o[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=k("strides",n,e,t),o=sd(n,e,t),a=k("dilations",n,e,t),l=k("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(k("input",n,e,t),k("filter",n,e,t),[r[1],r[2]],o,l,[a[1],a[2]])]}case"Conv3D":{const r=k("strides",n,e,t),o=k("pad",n,e,t),a=k("dataFormat",n,e,t).toUpperCase(),l=k("dilations",n,e,t);return[s.conv3d(k("x",n,e,t),k("filter",n,e,t),[r[1],r[2],r[3]],o,a,[l[1],l[2],l[3]])]}case"AvgPool":{const r=k("strides",n,e,t),o=k("pad",n,e,t),a=k("kernelSize",n,e,t);return[s.avgPool(k("x",n,e,t),[a[1],a[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=k("strides",n,e,t),o=k("pad",n,e,t),a=k("kernelSize",n,e,t);return[s.maxPool(k("x",n,e,t),[a[1],a[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=k("strides",n,e,t),o=k("pad",n,e,t),a=k("kernelSize",n,e,t),l=k("includeBatchInIndex",n,e,t),{result:u,indexes:d}=s.maxPoolWithArgmax(k("x",n,e,t),[a[1],a[2]],[r[1],r[2]],o,l);return[u,d]}case"AvgPool3D":{const r=k("strides",n,e,t),o=k("pad",n,e,t),a=k("kernelSize",n,e,t);return[s.avgPool3d(k("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=k("strides",n,e,t),o=k("pad",n,e,t),a=k("kernelSize",n,e,t);return[s.maxPool3d(k("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=k("strides",n,e,t),o=k("pad",n,e,t),a=k("dilations",n,e,t),l=r[1],u=r[2],d=a[1],p=a[2];return[s.dilation2d(k("x",n,e,t),k("filter",n,e,t),[l,u],o,[d,p],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rL=(n,e,t,s=Gt)=>{switch(n.op){case"Fill":{const r=k("shape",n,e,t),o=k("dtype",n,e,t),a=k("value",n,e,t);return[s.fill(r,a,o)]}case"LinSpace":{const r=k("start",n,e,t),o=k("stop",n,e,t),a=k("num",n,e,t);return[s.linspace(r,o,a)]}case"Multinomial":{const r=k("logits",n,e,t),o=k("numSamples",n,e,t),a=k("seed",n,e,t);return[s.multinomial(r,o,a)]}case"OneHot":{const r=k("indices",n,e,t),o=k("depth",n,e,t),a=k("onValue",n,e,t),l=k("offValue",n,e,t),u=k("dtype",n,e,t);return[s.oneHot(r,o,a,l,u)]}case"Ones":return[s.ones(k("shape",n,e,t),k("dtype",n,e,t))];case"OnesLike":return[s.onesLike(k("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(k("shape",n,e,t),k("dtype",n,e,t),k("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(k("shape",n,e,t),k("minval",n,e,t),k("maxval",n,e,t),k("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt(k("shape",n,e,t),k("minval",n,e,t),k("maxval",n,e,t),k("seed",n,e,t))];case"Range":{const r=k("start",n,e,t),o=k("stop",n,e,t),a=k("step",n,e,t);return[s.range(r,o,a,k("dtype",n,e,t))]}case"TruncatedNormal":{const r=k("shape",n,e,t),o=k("mean",n,e,t),a=k("stdDev",n,e,t),l=k("seed",n,e,t);return[s.truncatedNormal(r,o,a,k("dtype",n,e,t),l)]}case"Zeros":return[s.zeros(k("shape",n,e,t),k("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(k("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zm(n,e,t){const s=k("boxes",n,e,t),r=k("scores",n,e,t),o=k("maxOutputSize",n,e,t),a=k("iouThreshold",n,e,t),l=k("scoreThreshold",n,e,t),u=k("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}}const oL=async(n,e,t,s,r=Gt)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:d,softNmsSigma:p}=Zm(n,e,t),f=await r.image.nonMaxSuppressionWithScoreAsync(o,a,l,u,d,p);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:d}=Zm(n,e,t),p=k("padToMaxOutputSize",n,e,t),f=await r.image.nonMaxSuppressionPaddedAsync(o,a,l,u,d,p);return[f.selectedIndices,f.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:d}=Zm(n,e,t);return[await r.image.nonMaxSuppressionAsync(o,a,l,u,d)]}case"Where":{const o=r.cast(k("condition",n,e,t),"bool"),a=[await r.whereAsync(o)];return o.dispose(),a}case"ListDiff":return r.setdiff1dAsync(k("x",n,e,t),k("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aL=(n,e,t,s=Gt)=>{switch(n.op){case"LowerBound":{const r=k("sortedSequence",n,e,t),o=k("values",n,e,t);return[s.lowerBound(r,o)]}case"TopKV2":{const r=k("x",n,e,t),o=k("k",n,e,t),a=k("sorted",n,e,t),l=s.topk(r,o,a);return[l.values,l.indices]}case"UpperBound":{const r=k("sortedSequence",n,e,t),o=k("values",n,e,t);return[s.upperBound(r,o)]}case"Unique":{const r=k("x",n,e,t),o=s.unique(r);return[o.values,o.indices]}case"UniqueV2":{const r=k("x",n,e,t),o=k("axis",n,e,t),a=s.unique(r,o);return[a.values,a.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iL=(n,e,t,s=Gt)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=k("default",n,e,t);return[Vt(n.name,e,t)||r];case"Placeholder":return[Vt(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const p=k("x",n,e,t);return[Ys(p)]}case"IdentityN":return k("x",n,e,t).map(p=>Ys(p));case"Snapshot":const o=k("x",n,e,t);return[Ys(o)];case"Shape":return[s.tensor1d(k("x",n,e,t).shape,"int32")];case"ShapeN":return k("x",n,e,t).map(p=>s.tensor1d(p.shape));case"Size":return[s.scalar(k("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(k("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const a=k("x",n,e,t),l=k("data",n,e,t),u=k("message",n,e,t),d=k("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let p=0;p<l.length;p++)console.log(Array.prototype.slice.call(l[p].dataSync()).slice(0,d));return[a];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lL{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Ve(0),this.tensorMap=new Map,hs(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Ve(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),Ue(()=>{const r=Xr(t),o=s.length,a=r.length;O(o===a,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${a} elements.`);for(let l=0;l<o;l++){const u=s[l],d=r[l];hs(d),this.tensorMap.set(u,d)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return Ue(()=>{const r=[];for(let o=0;o<s.length;o++){const a=s[o],l=this.findWithDefault(a,t);r.push(l)}return Fs(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uL=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const o=k("keyDType",n,e,t),a=k("valueDType",n,e,t),l=new lL(o,a);return s.addHashTable(n.name,l),[l.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=k("tableHandle",n,e,t,s),o=k("keys",n,e,t),a=k("values",n,e,t);return[await s.getHashTableById(r.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{const r=k("tableHandle",n,e,t,s),o=k("keys",n,e,t),a=k("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(o,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=k("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cL=(n,e,t,s=Gt)=>{switch(n.op){case"ResizeBilinear":{const r=k("images",n,e,t),o=k("size",n,e,t),a=k("alignCorners",n,e,t),l=k("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(r,[o[0],o[1]],a,l)]}case"ResizeNearestNeighbor":{const r=k("images",n,e,t),o=k("size",n,e,t),a=k("alignCorners",n,e,t),l=k("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(r,[o[0],o[1]],a,l)]}case"CropAndResize":{const r=k("image",n,e,t),o=k("boxes",n,e,t),a=k("boxInd",n,e,t),l=k("cropSize",n,e,t),u=k("method",n,e,t),d=k("extrapolationValue",n,e,t);return[s.image.cropAndResize(r,o,a,l,u,d)]}case"ImageProjectiveTransformV3":{const r=k("images",n,e,t),o=k("transforms",n,e,t),a=k("outputShape",n,e,t),l=k("fillValue",n,e,t),u=k("interpolation",n,e,t),d=k("fillMode",n,e,t);return[s.image.transform(r,o,u.toLowerCase(),d.toLowerCase(),l,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dL=(n,e,t,s=Gt)=>{switch(n.op){case"Equal":return[s.equal(k("a",n,e,t),k("b",n,e,t))];case"NotEqual":return[s.notEqual(k("a",n,e,t),k("b",n,e,t))];case"Greater":return[s.greater(k("a",n,e,t),k("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(k("a",n,e,t),k("b",n,e,t))];case"Less":return[s.less(k("a",n,e,t),k("b",n,e,t))];case"LessEqual":return[s.lessEqual(k("a",n,e,t),k("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(k("a",n,e,t),k("b",n,e,t))];case"LogicalNot":return[s.logicalNot(k("a",n,e,t))];case"LogicalOr":return[s.logicalOr(k("a",n,e,t),k("b",n,e,t))];case"Select":case"SelectV2":return[s.where(k("condition",n,e,t),k("a",n,e,t),k("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(k("a",n,e,t),k("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pL=(n,e,t,s=Gt)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(k("a",n,e,t),k("b",n,e,t),k("transposeA",n,e,t),k("transposeB",n,e,t))];case"Einsum":return[s.einsum(k("equation",n,e,t),...k("tensors",n,e,t))];case"Transpose":return[s.transpose(k("x",n,e,t),k("perm",n,e,t))];case"_FusedMatMul":const[r,o]=k("fusedOps",n,e,t),a=r==="biasadd",l=o==="prelu",u=k("numArgs",n,e,t),d=k("leakyreluAlpha",n,e,t);if(a){if(l&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!l&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[p,f]=k("args",n,e,t);return[s.fused.matMul({a:k("a",n,e,t),b:k("b",n,e,t),transposeA:k("transposeA",n,e,t),transposeB:k("transposeB",n,e,t),bias:p,activation:o,preluActivationWeights:f,leakyreluAlpha:d})];case"MatrixBandPart":return[s.linalg.bandPart(k("a",n,e,t),k("numLower",n,e,t),k("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fL=(n,e,t,s=Gt)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(k("x",n,e,t),k("axis",n,e,t),k("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(k("x",n,e,t),k("mean",n,e,t),k("variance",n,e,t),k("offset",n,e,t),k("scale",n,e,t),k("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(k("x",n,e,t),k("mean",n,e,t),k("variance",n,e,t),k("offset",n,e,t),k("scale",n,e,t),k("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(k("x",n,e,t),k("radius",n,e,t),k("bias",n,e,t),k("alpha",n,e,t),k("beta",n,e,t))];case"Softmax":return[s.softmax(k("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(k("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hL=(n,e,t,s=Gt)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:o}=s.raggedGather(k("paramsNestedSplits",n,e,t),k("paramsDenseValues",n,e,t),k("indices",n,e,t),k("outputRaggedRank",n,e,t));return r.concat(o)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:o}=s.raggedRange(k("starts",n,e,t),k("limits",n,e,t),k("splits",n,e,t));return[r,o]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(k("shape",n,e,t),k("values",n,e,t),k("defaultValue",n,e,t),k("rowPartitionTensors",n,e,t),k("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mL=(n,e,t,s=Gt)=>{switch(n.op){case"Max":{const l=k("axis",n,e,t),u=k("keepDims",n,e,t);return[s.max(k("x",n,e,t),l,u)]}case"Mean":{const l=k("axis",n,e,t),u=k("keepDims",n,e,t);return[s.mean(k("x",n,e,t),l,u)]}case"Min":{const l=k("axis",n,e,t),u=k("keepDims",n,e,t);return[s.min(k("x",n,e,t),l,u)]}case"Sum":{const l=k("axis",n,e,t),u=k("keepDims",n,e,t);return[s.sum(k("x",n,e,t),l,u)]}case"All":{const l=k("axis",n,e,t),u=k("keepDims",n,e,t);return[s.all(k("x",n,e,t),l,u)]}case"Any":{const l=k("axis",n,e,t),u=k("keepDims",n,e,t);return[s.any(k("x",n,e,t),l,u)]}case"ArgMax":{const l=k("axis",n,e,t);return[s.argMax(k("x",n,e,t),l)]}case"ArgMin":{const l=k("axis",n,e,t);return[s.argMin(k("x",n,e,t),l)]}case"Prod":{const l=k("axis",n,e,t),u=k("keepDims",n,e,t);return[s.prod(k("x",n,e,t),l,u)]}case"Cumprod":{const l=k("axis",n,e,t),u=k("exclusive",n,e,t),d=k("reverse",n,e,t);return[s.cumprod(k("x",n,e,t),l,u,d)]}case"Cumsum":{const l=k("axis",n,e,t),u=k("exclusive",n,e,t),d=k("reverse",n,e,t);return[s.cumsum(k("x",n,e,t),l,u,d)]}case"Bincount":const r=k("x",n,e,t),o=k("weights",n,e,t),a=k("size",n,e,t);return[s.bincount(r,o,a)];case"DenseBincount":{const l=k("x",n,e,t),u=k("weights",n,e,t),d=k("size",n,e,t),p=k("binaryOutput",n,e,t);return[s.denseBincount(l,u,d,p)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gL=(n,e,t,s=Gt)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=k("n",n,e,t),o=k("axis",n,e,t);let a=k("tensors",n,e,t);return a=a.slice(0,r),[s.concat(a,o)]}case"Gather":{const r=k("x",n,e,t),o=k("indices",n,e,t);return[s.gather(r,s.cast(o,"int32"),0)]}case"GatherV2":{const r=k("axis",n,e,t),o=k("batchDims",n,e,t),a=k("x",n,e,t),l=k("indices",n,e,t);return[s.gather(a,s.cast(l,"int32"),r,o)]}case"Reverse":{const r=k("dims",n,e,t),o=[];for(let l=0;l<r.length;l++)r[l]&&o.push(l);const a=k("x",n,e,t);return[s.reverse(a,o)]}case"ReverseV2":{const r=k("axis",n,e,t),o=k("x",n,e,t);return[s.reverse(o,r)]}case"Slice":{const r=k("begin",n,e,t),o=k("size",n,e,t);return[s.slice(k("x",n,e,t),r,o)]}case"StridedSlice":{const r=k("begin",n,e,t),o=k("end",n,e,t),a=k("strides",n,e,t),l=k("beginMask",n,e,t),u=k("endMask",n,e,t),d=k("ellipsisMask",n,e,t),p=k("newAxisMask",n,e,t),f=k("shrinkAxisMask",n,e,t),m=k("x",n,e,t);return[s.stridedSlice(m,r,o,a,l,u,d,p,f)]}case"Pack":return Ue(()=>{const r=k("axis",n,e,t),o=k("tensors",n,e,t),a=o[0].shape,l=s.squeeze(o[0]).shape,u=o.map(d=>{const p=Qe(d.shape,a);if(!p&&!Qe(s.squeeze(d).shape,l))throw new Error("the input tensors shape does not match");return p?d:s.reshape(d,a)});return[s.stack(u,r)]});case"Unpack":{const r=k("axis",n,e,t),o=k("tensor",n,e,t);return s.unstack(o,r)}case"Tile":{const r=k("reps",n,e,t);return[s.tile(k("x",n,e,t),r)]}case"Split":case"SplitV":{const r=k("axis",n,e,t),o=k("numOrSizeSplits",n,e,t),a=k("x",n,e,t);return s.split(a,o,r)}case"ScatterNd":{const r=k("indices",n,e,t),o=k("values",n,e,t),a=k("shape",n,e,t);return[s.scatterND(r,o,a)]}case"GatherNd":{const r=k("x",n,e,t),o=k("indices",n,e,t);return[s.gatherND(r,o)]}case"SparseToDense":{const r=k("sparseIndices",n,e,t),o=k("outputShape",n,e,t),a=k("sparseValues",n,e,t),l=k("defaultValue",n,e,t);return[s.sparseToDense(r,a,o,a.dtype===l.dtype?l:s.cast(l,a.dtype))]}case"TensorScatterUpdate":{const r=k("indices",n,e,t),o=k("values",n,e,t),a=k("tensor",n,e,t);return[s.tensorScatterUpdate(a,r,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yL=(n,e,t,s=Gt)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:o,emptyRowIndicator:a,reverseIndexMap:l}=s.sparse.sparseFillEmptyRows(k("indices",n,e,t),k("values",n,e,t),k("denseShape",n,e,t),k("defaultValue",n,e,t));return[r,o,a,l]}case"SparseReshape":{const{outputIndices:r,outputShape:o}=s.sparse.sparseReshape(k("inputIndices",n,e,t),k("inputShape",n,e,t),k("newShape",n,e,t));return[r,o]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(k("data",n,e,t),k("indices",n,e,t),k("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(k("data",n,e,t),k("indices",n,e,t),k("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xL=(n,e,t,s=Gt)=>{switch(n.op){case"FFT":return[s.fft(k("x",n,e,t))];case"IFFT":return[s.ifft(k("x",n,e,t))];case"RFFT":return[s.rfft(k("x",n,e,t))];case"IRFFT":return[s.irfft(k("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vL=(n,e,t,s=Gt)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(k("input",n,e,t),k("pattern",n,e,t),k("rewrite",n,e,t),k("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:o}=s.string.stringNGrams(k("data",n,e,t),k("dataSplits",n,e,t),k("separator",n,e,t),k("nGramWidths",n,e,t),k("leftPad",n,e,t),k("rightPad",n,e,t),k("padWidth",n,e,t),k("preserveShortSequences",n,e,t));return[r,o]}case"StringSplit":{const{indices:r,values:o,shape:a}=s.string.stringSplit(k("input",n,e,t),k("delimiter",n,e,t),k("skipEmpty",n,e,t));return[r,o,a]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(k("input",n,e,t),k("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wL=(n,e,t,s=Gt)=>{switch(n.op){case"Cast":return[s.cast(k("x",n,e,t),k("dtype",n,e,t))];case"ExpandDims":{const r=k("axis",n,e,t);return[s.expandDims(k("x",n,e,t),r)]}case"Squeeze":{const r=k("axis",n,e,t);return[s.squeeze(k("x",n,e,t),r)]}case"Reshape":return[s.reshape(k("x",n,e,t),k("shape",n,e,t))];case"EnsureShape":return[s.ensureShape(k("x",n,e,t),k("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(k("x",n,e,t),k("padding",n,e,t),k("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(k("x",n,e,t),k("padding",n,e,t),k("constantValue",n,e,t))];case"SpaceToBatchND":{const r=k("blockShape",n,e,t),o=k("paddings",n,e,t);return[s.spaceToBatchND(k("x",n,e,t),r,o)]}case"BatchToSpaceND":{const r=k("blockShape",n,e,t),o=k("crops",n,e,t);return[s.batchToSpaceND(k("x",n,e,t),r,o)]}case"DepthToSpace":{const r=k("blockSize",n,e,t),o=k("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(k("x",n,e,t),r,o)]}case"BroadcastTo":return[s.broadcastTo(k("x",n,e,t),k("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(k("s0",n,e,t),k("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iw(n,e,t,s,r=Ue){const o=((a,l,u)=>{switch(a.category){case"arithmetic":return r(()=>X3(a,l,u));case"basic_math":return r(()=>Y3(a,l,u));case"control":return nL(a,l,u);case"convolution":return r(()=>sL(a,l,u));case"creation":return r(()=>rL(a,l,u));case"dynamic":return oL(a,l,u);case"evaluation":return r(()=>aL(a,l,u));case"image":return r(()=>cL(a,l,u));case"graph":return r(()=>iL(a,l,u));case"logical":return r(()=>dL(a,l,u));case"matrices":return r(()=>pL(a,l,u));case"normalization":return r(()=>fL(a,l,u));case"ragged":return r(()=>hL(a,l,u));case"reduction":return r(()=>mL(a,l,u));case"slice_join":return r(()=>gL(a,l,u));case"sparse":return r(()=>yL(a,l,u));case"spectral":return r(()=>xL(a,l,u));case"string":return r(()=>vL(a,l,u));case"transformation":return r(()=>wL(a,l,u));case"hash_table":return uL(a,l,u,s);case"custom":const d=rk(a.op);if(d&&d.customExecutor)return d.customExecutor(new K3(a,l,u));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Br(o)?o.then(a=>[].concat(a)):[].concat(o)}class Tw{constructor(e={},t={},s={},r={},o){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ew(n,e,t,s){const r=new Set,o=[];let a=null,l=null;const u=new Set,d=new Set(Object.keys(n).map(m=>kn(m)[0]));s=s||[];const p=new Set(s.map(m=>kn(m.name)[0])),f=[...e];for(;f.length>0;){const m=f.pop();if((vo(m)||TL(m)||EL(m))&&a==null&&(a=m,l=a.children.map(g=>g.name).filter(g=>r.has(g))),r.add(m.name),t[m.name]==null&&!d.has(m.name)&&!p.has(m.name)){if(m.inputs.length===0){o.push(m.name);continue}m.inputs.forEach(g=>{u.has(g.name)||(u.add(g.name),f.push(g))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:o,dynamicNode:a,syncInputs:l}}function bL(n,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(v=>kn(v)[0]).map(v=>n.nodes[v]),o=n.initNodes||[],a=v=>t.has(typeof v=="string"?v:v.name);function l(v){return[...new Map(v.map(b=>[b.name,b])).values()]}const u=l([...r,...n.weights,...o]).filter(a),d=l([...u,...Object.values(n.nodes)]).filter(a),p=new Map(d.map(v=>[v.name,v])),f={};for(const v of d){f[v.name]=f[v.name]||0;for(const b of v.children)a(b)||(f[b.name]=Number.POSITIVE_INFINITY),f[b.name]=(f[b.name]||0)+1}const m=Object.entries(f).filter(([,v])=>v===0).map(([v])=>v),g=[...m];for(;m.length>0;){const v=m.pop(),b=p.get(v);for(const C of b.children.filter(a))--f[C.name]===0&&(g.push(C.name),m.push(C.name))}const x=g.map(v=>p.get(v)),w=$L(x,u);return SL(w,u),w}function $L(n,e){const t=new Map(n.map(a=>[a.name,a])),s=e.map(a=>a.name),r=new Set(s);for(;s.length>0;){const a=s.pop(),l=t.get(a);for(const u of l.children)!t.has(u.name)||r.has(u.name)||(r.add(u.name),s.push(u.name))}return n.filter(a=>r.has(a.name))}class Bc extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function SL(n,e){const t=new Map(n.map((l,u)=>[l.name,u])),s=new Set(e.map(l=>l.name)),r=l=>s.has(typeof l=="string"?l:l.name),o=new Set(n.map(l=>l.name)),a=l=>o.has(typeof l=="string"?l:l.name);for(const l of n){for(const u of l.children.filter(a)){if(!t.has(u.name))throw new Bc(`Child ${u.name} of node ${l.name} is unreachable.`);if(t.get(l.name)>t.get(u.name))throw new Bc(`Node ${l.name} is scheduled to run after its child ${u.name}.`)}if(!r(l))for(const u of l.inputs){if(!t.has(u.name))throw new Bc(`Input ${u.name} of node ${l.name} is unreachable.`);if(t.get(u.name)>t.get(l.name))throw new Bc(`Node ${l.name} is scheduled to run before its input ${u.name}.`)}}}function CL(n){const e=new Map(n.map((l,u)=>[l.name,u])),t=Number.MAX_SAFE_INTEGER,s=n.map((l,u)=>vo(l)?t:u),r=l=>{const u=s[e.get(l.name)];return u??-1},o=n.map((l,u)=>l.children.map(r).reduce((d,p)=>Math.max(d,p),s[u])),a=new Map;for(let l=0;l<n.length;++l){const u=o[l];if(u===t)continue;const d=n[l],p=n[u];a.has(p.name)||a.set(p.name,[]),a.get(p.name).push(d)}return a}const kL=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),NL=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),IL=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function vo(n){return kL.has(n.op)}function TL(n){return NL.has(n.op)}function EL(n){return IL.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gd{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new gd(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(o=>o.name).sort(),r=t.map(o=>o.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=Ew(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:o,syncInputs:a}=s;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const d=t.map(f=>f.name),p=Object.keys(e);throw new Error(`Cannot compute the outputs [${d}] from the provided inputs [${p}]. Missing the following inputs: [${r}]`)}const l=bL(this.graph,s),u=CL(l);return{orderedNodes:l,nodeLiveUntilMap:u}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return hs(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(m=>this.graph.nodes[kn(m)[0]]),o=t.map(m=>kn(m)[0]),a=new Set(o);let l=o.map(m=>this.graph.nodes[m]);l.length===0&&(l=this._outputs);const u=this.getCompilationKey(r,l);let d=this.compiledMap.get(u);d==null&&(d=this.compile(e,l),this.compiledMap.set(u,d));try{this.keepIntermediateTensors=J().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const p={},f={};return Ue(()=>{const m=new Tw(this.weightMap,p,f,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(b=>{const[C,I]=kn(b,m),N=[];N[I]=e[b],g[C]=N,this.keepIntermediateTensors&&(this.clonedTensorsMap[C]=this.cloneTensorList(N))});const x=this.getFrozenTensorIds(g),{orderedNodes:w,nodeLiveUntilMap:v}=d;for(const b of w){if(g[b.name])continue;const C=Iw(b,g,m,this._resourceManager);if(Br(C))throw new Error(`The execution of the op '${b.op}' returned a promise. Please use model.executeAsync() instead.`);g[b.name]=C,this.keepIntermediateTensors&&(this.clonedTensorsMap[b.name]=this.cloneTensorList(C)),this.checkTensorForDisposalWithNodeLiveUntilInfo(b,g,m,x,a,v.get(b.name))}return this.parent==null&&m.dispose(x),t.map(b=>Vt(b,g,m))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,o,a,l){if(!(vo(t)||a.has(e))){for(const u of s[e])u!=null&&(l[u.id]=(l[u.id]||0)+t.children.length);for(const u of t.inputs){if(vo(u))continue;const d=$w(u.name,s,r);if(d!=null)for(const p of d){if(!p||p.kept||o.has(p.id))continue;const f=l[p.id];f===1?(p.dispose(),delete l[p.id]):f!=null&&l[p.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,o,a){function l(u){return vo(u)||o.has(u.name)}if(!(vo(e)||a==null))for(const u of a){if(l(u))continue;const d=$w(u.name,t,s);for(const p of d)!p||p.kept||r.has(p.id)||p.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},o={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=J().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const a=new Tw(this.weightMap,r,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const l=await this.executeWithControlFlow(e,a,t,s),u=t.map(m=>Vt(m,l,a)),d=u.map(m=>m.id),p=Object.keys(e).map(m=>e[m].id),f=new Set([...d,...p,...this.weightIds]);return Object.values(l).forEach(m=>{m.forEach(g=>{g&&!g.isDisposed&&!f.has(g.id)&&g.dispose()})}),this.parent==null&&a.dispose(f),u}async executeFunctionAsync(e,t,s){const r=e.reduce((o,a,l)=>(o[this.inputs[l].name]=a,o),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const o=Object.keys(e),a=o.map(N=>this.graph.nodes[kn(N)[0]]),l=s.map(N=>kn(N)[0]),u=new Set(l);let d=l.map(N=>this.graph.nodes[N]);d.length===0&&(d=this._outputs);const{usedNodes:p,missingInputs:f,dynamicNode:m,syncInputs:g}=Ew(e,d,this.weightMap,this._initNodes),x=[...a,...this.graph.weights,...this._initNodes||[]].map(N=>({node:N,contexts:t.currentContext})),w=Object.assign({},this.weightMap);Object.keys(e).forEach(N=>{const[R,D]=kn(N),F=[];F[D]=e[N],w[R]=F});const v={},b=this.getFrozenTensorIds(w),C={};for(;x.length>0;){const N=this.processStack(a,x,t,w,C,b,u,v,p);await Promise.all(N)}m==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const I=d.filter(N=>!vo(N)&&!Vt(N.name,w,t)).map(N=>N.name);if(I.length>0){let N="";throw m!=null&&(N=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${I}] from the provided inputs [${o}]. Consider providing the following inputs: [${f}]. ${N}`)}return w}processStack(e,t,s,r,o,a,l,u,d){const p=[];for(;t.length>0;){const f=t.pop();s.currentContext=f.contexts;let m="";if(f.node.op==="Enter"&&k("isConstant",f.node,r,s)&&([m]=Xs(f.node.name,s)),r[f.node.name]==null){const g=Iw(f.node,r,s,this._resourceManager);m||([m]=Xs(f.node.name,s));const x=s.currentContext;Br(g)?p.push(g.then(w=>(r[m]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(w)),s.currentContext=x,this.checkTensorForDisposal(m,f.node,r,s,a,l,u),this.processChildNodes(f.node,t,s,r,o,d),w))):(r[m]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(g)),this.checkTensorForDisposal(m,f.node,r,s,a,l,u),this.processChildNodes(f.node,t,s,r,o,d))}else this.processChildNodes(f.node,t,s,r,o,d)}return p}processChildNodes(e,t,s,r,o,a){e.children.forEach(l=>{const[u]=Xs(l.name,s);o[u]||!a.has(l.name)||(l.op==="Merge"?l.inputNames.some(d=>!!Vt(d,r,s))&&(o[u]=!0,t.push({contexts:s.currentContext,node:l})):l.inputNames.every(d=>!!Vt(d,r,s))&&(o[u]=!0,t.push({contexts:s.currentContext,node:l})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=kn(t),o=this.graph.nodes[r];if(o.attrParams.shape&&o.attrParams.shape.value){const a=o.attrParams.shape.value,l=a.length===s.shape.length&&s.shape.every((u,d)=>a[d]===-1||a[d]===u);O(l,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${a}], but was [${s.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&O(s.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const o in e){const a=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[o];a!=null?r[a.name]=e[o]:r[o]=e[o]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=kn(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const o=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return o!=null?o.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=kn(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class RL{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _L="?tfjs-format=file",OL="model.json";class B0{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=u0){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new RL}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Br(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await Mb(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(r=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new gd(Sw.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=Sw.Instance.transformGraph(e.modelInitializer);this.initializer=new gd(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof yt?[e]:e,s={};return t.forEach((r,o)=>s[this.structuredOutputKeys[o]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof yt)&&!Array.isArray(e)){const o=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(o!=null)for(const a in o){const l=o[a];l.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[l.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((o,a)=>{var l,u,d;const p=(d=(u=(l=this.signature)===null||l===void 0?void 0:l.inputs)===null||u===void 0?void 0:u[a])===null||d===void 0?void 0:d.resourceId;return p!=null?o[a]=this.resourceIdToCapturedInput[p]:o[a]=e[r++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const o=s[r],a=t[o];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&an(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function DL(n,e={},t=u0){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=FL(n));const s=new B0(n,e,t);return await s.load(),s}function AL(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[s,r]=n;if(!s)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const o=ud(s.weightsManifest),a=hy(s,o,r);e=hd(a)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=hd(n);else throw new Error("Unknown model format");const t=new B0(e);return t.load(),t}function FL(n){return n.endsWith("/")||(n=n+"/"),`${n}${OL}${_L}`}/** @license See the LICENSE file. */const PL="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LL=Object.freeze(Object.defineProperty({__proto__:null,GraphModel:B0,deregisterOp:l3,loadGraphModel:DL,loadGraphModelSync:AL,registerOp:i3,version_converter:PL},Symbol.toStringTag,{value:"Module"})),VL=Ug(LL),BL=Ug(o3);/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ML=Oi.exports,Rw;function zL(){return Rw||(Rw=1,function(n,e){(function(t,s){s(e,VL,BL)})(ML,function(t,s,r){const o={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class a{constructor(u,d){this.modelPath=d||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(u)}/model.json`}getPrefix(u){return u==="lite_mobilenet_v2"?`ssd${u}`:`ssd_${u}`}async load(){this.model=await s.loadGraphModel(this.modelPath);const u=r.zeros([1,300,300,3],"int32"),d=await this.model.executeAsync(u);await Promise.all(d.map(p=>p.data())),d.map(p=>p.dispose()),u.dispose()}async infer(u,d,p){const f=r.tidy(()=>(u instanceof r.Tensor||(u=r.browser.fromPixels(u)),r.expandDims(u))),m=f.shape[1],g=f.shape[2],x=await this.model.executeAsync(f),w=x[0].dataSync(),v=x[1].dataSync();f.dispose(),r.dispose(x);const[b,C]=this.calculateMaxScores(w,x[0].shape[1],x[0].shape[2]),I=r.getBackend();r.getBackend()==="webgl"&&r.setBackend("cpu");const N=r.tidy(()=>{const D=r.tensor2d(v,[x[1].shape[1],x[1].shape[3]]);return r.image.nonMaxSuppression(D,b,d,p,p)}),R=N.dataSync();return N.dispose(),I!==r.getBackend()&&r.setBackend(I),this.buildDetectedObjects(g,m,v,b,R,C)}buildDetectedObjects(u,d,p,f,m,g){const x=m.length,w=[];for(let v=0;v<x;v++){const b=[];for(let D=0;D<4;D++)b[D]=p[4*m[v]+D];const C=b[0]*d,I=b[1]*u,N=b[2]*d,R=b[3]*u;b[0]=I,b[1]=C,b[2]=R-I,b[3]=N-C,w.push({bbox:b,class:o[g[m[v]]+1].displayName,score:f[m[v]]})}return w}calculateMaxScores(u,d,p){const f=[],m=[];for(let g=0;g<d;g++){let x=Number.MIN_VALUE,w=-1;for(let v=0;v<p;v++)u[g*p+v]>x&&(x=u[g*p+v],w=v);f[g]=x,m[g]=w}return[f,m]}async detect(u,d=20,p=.5){return this.infer(u,d,p)}dispose(){this.model!=null&&this.model.dispose()}}t.ObjectDetection=a,t.load=async function(l={}){if(r==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const u=l.base||"lite_mobilenet_v2",d=l.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(u)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${u}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const p=new a(u,d);return await p.load(),p},t.version="2.2.3",Object.defineProperty(t,"__esModule",{value:!0})})}(Oi,Oi.exports)),Oi.exports}var WL=zL();/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $e(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&O(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UL=Rf;class Wf extends Nd{nextDataId(){return Wf.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Hg(this,ds())}write(e,t,s){this.firstUse&&(this.firstUse=!1,J().get("IS_NODE")&&Vn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Is(s[0])){const o=s.map(a=>Es(a));r=this.write(o,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,o){this.data.set(e,{values:t,dtype:r,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),o=this.readSync(s.imag.dataId);return sr(r,o)}return vb(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>tr(r));return Ae(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ae(e.shape,e.dtype,t)}makeOutput(e,t,s){return ds().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=In();return e(),{kernelMs:In()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){$e([e],"where");const t=this.readSync(e.dataId);return UL(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Wf.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ik(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const GL=n=>{const{x:e}=n.inputs,t=n.backend;$e(e,"abs");let s=new Float32Array(oe(e.shape));const r=t.data.get(e.dataId).values;return s=ik(r),t.makeOutput(s,e.shape,e.dtype)},HL={kernelName:Ed,backendName:"cpu",kernelFunc:GL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $t(n){return(e,t,s,r,o)=>{const a=Le(e,t),l=a.length,u=Ie(a),d=oe(a),p=Dt(o,d),f=e.length,m=t.length,g=Ie(e),x=Ie(t),w=_o(e,a),v=_o(t,a);if(w.length+v.length===0)for(let b=0;b<p.length;++b)p[b]=n(s[b%s.length],r[b%r.length]);else for(let b=0;b<p.length;++b){const C=Bo(b,l,u),I=C.slice(-f);w.forEach(F=>I[F]=0);const N=ms(I,f,g),R=C.slice(-m);v.forEach(F=>R[F]=0);const D=ms(R,m,x);p[b]=n(s[N],r[D])}return[p,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tn(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.makeTensorInfo(s.shape,"complex64"),u=t.data.get(l.dataId);return u.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",o),imag:t.makeTensorInfo(r.shape,"float32",a)},l}const jL={kernelName:zd,backendName:"cpu",kernelFunc:Tn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yd(n,e,t="float32"){if(t==="complex64"){const r=yd(n,e,"float32"),o=yd(n,e,"float32");return Tn({inputs:{real:r,imag:o},backend:n})}const s=Mt(oe(e),t);return n.makeTensorInfo(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ps(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const qL={kernelName:Il,backendName:"cpu",kernelFunc:Ps};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ao(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,o=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,o)}const KL={kernelName:zp,backendName:"cpu",kernelFunc:Ao};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lk(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=Hr([0],t),[o,a]=$t((l,u)=>l!==u?1:0)(e,[],n,r,"bool");return[a,"bool",o]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function Gr(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return Ps({inputs:{x:r},backend:t});const p=yd(t,r.shape,r.dtype),f=Gr({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),m=Tn({inputs:{real:f,imag:p},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),m}if(r.dtype==="complex64"){const p=Ao({inputs:{input:r},backend:t}),f=Gr({inputs:{x:p},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(p),f}if(!qg(r.dtype,o)){const p=Ps({inputs:{x:r},backend:t});return{dataId:p.dataId,shape:p.shape,dtype:o}}const a=t.data.get(r.dataId).values,[l,u,d]=lk(a,r.shape,r.dtype,o);return t.makeTensorInfo(l,u,d)}const XL={kernelName:pl,backendName:"cpu",kernelFunc:Gr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tt(n,e,t,s){return t==null?({inputs:r,backend:o})=>{const{a,b:l}=r,u=o;$e([a,l],n);const d=u.data.get(a.dataId).values,p=u.data.get(l.dataId).values,f=a.dtype==="string"?rr(d):d,m=a.dtype==="string"?rr(p):p,g=s||a.dtype,[x,w]=e(a.shape,l.shape,f,m,g);return u.makeTensorInfo(w,g,x)}:({inputs:r,backend:o})=>{const{a,b:l}=r,u=o;if(a.dtype==="complex64"||l.dtype==="complex64"){const d=Gr({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),p=u.data.get(d.dataId),f=p.complexTensorInfos.real,m=p.complexTensorInfos.imag,g=u.data.get(f.dataId).values,x=u.data.get(m.dataId).values,w=Gr({inputs:{x:l},backend:u,attrs:{dtype:"complex64"}}),v=u.data.get(w.dataId),b=v.complexTensorInfos.real,C=v.complexTensorInfos.imag,I=u.data.get(b.dataId).values,N=u.data.get(C.dataId).values,[R,D,F]=t(a.shape,l.shape,g,x,I,N),V=u.makeTensorInfo(F,"float32",R),P=u.makeTensorInfo(F,"float32",D),A=Tn({inputs:{real:V,imag:P},backend:u});return u.disposeIntermediateTensorInfo(d),u.disposeIntermediateTensorInfo(w),u.disposeIntermediateTensorInfo(V),u.disposeIntermediateTensorInfo(P),A}else{const d=u.data.get(a.dataId).values,p=u.data.get(l.dataId).values,f=s||a.dtype,[m,g]=e(a.shape,l.shape,d,p,f);return u.makeTensorInfo(g,f,m)}}}function M0(n){return(e,t,s,r,o,a)=>{const l=Le(e,t),u=oe(l),d=l.length,p=Ie(l),f=Dt("float32",u),m=Dt("float32",u),g=_o(e,l),x=_o(t,l),w=sr(s,r),v=sr(o,a),b=e.length,C=Ie(e),I=t.length,N=Ie(t);if(g.length+x.length===0)for(let R=0;R<f.length;R++){const D=R%w.length,F=R%v.length,V=n(w[D*2],w[D*2+1],v[F*2],v[F*2+1]);f[R]=V.real,m[R]=V.imag}else for(let R=0;R<f.length;R++){const D=Bo(R,d,p),F=D.slice(-b);g.forEach(W=>F[W]=0);const V=ms(F,b,C),P=D.slice(-I);x.forEach(W=>P[W]=0);const A=ms(P,I,N),T=n(w[V*2],w[V*2+1],v[A*2],v[A*2+1]);f[R]=T.real,m[R]=T.imag}return[f,m,l]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uk=$t((n,e)=>n+e),YL=M0((n,e,t,s)=>({real:n+t,imag:e+s})),Ra=Tt(Fa,uk,YL),QL={kernelName:Fa,backendName:"cpu",kernelFunc:Ra};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z0(n,e,t,s,r){const o=oe(s),a=Mt(r,t);for(let l=0;l<n.length;l++){const u=n[l];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(o>0?a[u]+=e[l]:a[u]+=1)}return a}function ck(n,e,t,s=!1){const r=n.shape[0],o=n.shape[1],a=Ae([r,t],e.dtype);for(let l=0;l<r;l++)for(let u=0;u<o;u++){const d=n.get(l,u);if(d<0)throw new Error("Input x must be non-negative!");d>=t||(s?a.set(1,l,d):e.size>0?a.set(a.get(l,d)+e.get(l,u),l,d):a.set(a.get(l,d)+1,l,d))}return a}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dk=$t((n,e)=>n&e),ZL=Tt(dl,dk),JL={kernelName:dl,backendName:"cpu",kernelFunc:ZL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ls(n){return(e,t,s)=>{const r=xt(t,e.length);for(let o=0;o<e.length;++o)r[o]=n(e[o],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xe(n,e,t){const s=Ls(e);return Qr(n,s,t)}function Qr(n,e,t){return({inputs:s,attrs:r,backend:o})=>{const{x:a}=s;$e(a,n);const l=o,u=l.data.get(a.dataId).values;let d;if(a.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");d=rr(u)}else d=u;const p=t||a.dtype,f=e(d,p,r);return l.makeTensorInfo(a.shape,p,f)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pk=Ls(n=>Math.ceil(n)),e4=Qr(fl,pk),t4={kernelName:fl,backendName:"cpu",kernelFunc:e4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fk(n,e,t,s){const r=xt(t,oe(e));if(s&&t!=="string"){let o=0;n.forEach(a=>{const l=oe(a.shape);r.set(a.vals,o),o+=l})}else{let o=0;n.forEach(a=>{const l=t==="string"?rr(a.vals):a.vals;let u=0;for(let d=0;d<a.shape[0];++d){const p=d*e[1]+o;for(let f=0;f<a.shape[1];++f)r[p+f]=l[u++]}o+=a.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hk=$t((n,e)=>n===e?1:0),mk=Tt(wl,hk,null,"bool"),n4={kernelName:wl,backendName:"cpu",kernelFunc:mk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gk=Ls(n=>Math.exp(n)),yk=Qr(bl,gk,"float32"),s4={kernelName:bl,backendName:"cpu",kernelFunc:yk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xk=Ls(n=>Math.expm1(n)),r4=Qr($l,xk),o4={kernelName:$l,backendName:"cpu",kernelFunc:r4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vk=Ls(n=>Math.floor(n)),a4=Qr(Sl,vk),i4={kernelName:Sl,backendName:"cpu",kernelFunc:a4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wk=$t((n,e)=>Math.floor(n/e)),l4=Tt(Cl,wk,null,"int32"),u4={kernelName:Cl,backendName:"cpu",kernelFunc:l4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bk(n,e,t,s,r,o,a,l,u){const d=Ae([s,o],t);for(let p=0;p<s;p++){const f=[];let m=0;for(let g=0;g<r;g++){const x=n[p*r+g];m+=x*a[g],f.push(x)}if(m<0||m>=u/o)throw new Error(`Invalid indices: ${f} does not index into ${l}`);for(let g=0;g<o;g++)d.values[p*o+g]=e.get(...e.indexToLoc(m*o+g))}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $k(n,e,t){const s=Ae(t,n.dtype);for(let r=0;r<s.size;++r){const a=s.indexToLoc(r).slice(),l=a[0],u=a[2],d=e.locToIndex([l,u]);a[2]=e.values[d];const p=n.locToIndex(a);0<=p&&p<n.values.length&&(s.values[r]=n.values[p])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sk=$t((n,e)=>n>e?1:0),c4=Tt(kl,Sk,null,"bool"),d4={kernelName:kl,backendName:"cpu",kernelFunc:c4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ck=$t((n,e)=>n>=e?1:0),p4=Tt(Nl,Ck,null,"bool"),f4={kernelName:Nl,backendName:"cpu",kernelFunc:p4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kk=$t((n,e)=>n<e?1:0),h4=Tt(_l,kk,null,"bool"),m4={kernelName:_l,backendName:"cpu",kernelFunc:h4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nk=$t((n,e)=>n<=e?1:0),g4=Tt(Ol,Nk,null,"bool"),y4={kernelName:Ol,backendName:"cpu",kernelFunc:g4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ik(n,e,t){const s=(e-n)/(t-1),r=Mt(t,"float32");r[0]=n;for(let o=1;o<r.length;o++)r[o]=r[o-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tk=Ls(n=>Math.log(n)),x4=Qr(Dl,Tk),v4={kernelName:Dl,backendName:"cpu",kernelFunc:x4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ek(n,e,t,s){const r=Dt(s,oe(t));for(let o=0;o<r.length;++o){const a=o*e;let l=n[a];for(let u=0;u<e;++u){const d=n[a+u];(Number.isNaN(d)||d>l)&&(l=d)}r[o]=l}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rk=$t((n,e)=>Math.max(n,e)),w4=Tt(Vl,Rk),b4={kernelName:Vl,backendName:"cpu",kernelFunc:w4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _k=$t((n,e)=>Math.min(n,e)),$4=Tt(Bl,_k),S4={kernelName:Bl,backendName:"cpu",kernelFunc:$4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W0=$t((n,e)=>n*e),C4=M0((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t})),Uf=Tt(zl,W0,C4),k4={kernelName:zl,backendName:"cpu",kernelFunc:Uf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ok(n,e,t){const s=ar(-1,t);return W0([],e,s,n,t)}function N4(n){const{inputs:e,backend:t}=n,{x:s}=e;$e(s,"neg");const r=t.data.get(s.dataId).values,[o,a]=Ok(r,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,o)}const I4={kernelName:Ip,backendName:"cpu",kernelFunc:N4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dk=$t((n,e)=>n!==e?1:0),T4=Tt(Wl,Dk,null,"bool"),E4={kernelName:Wl,backendName:"cpu",kernelFunc:T4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U0(n,e,t,s,r){const o=e.length,a=oe(e),l=Ie(e),u=Ie(r),d=Dt(t,oe(r));for(let p=0;p<a;++p){const f=Bo(p,o,l),m=new Array(f.length);for(let x=0;x<m.length;x++)m[x]=f[s[x]];const g=ms(m,o,u);d[g]=n[p]}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mn(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:o}=t;$e(r,"transpose");const a=r.shape.length,l=new Array(a);for(let f=0;f<l.length;f++)l[f]=r.shape[o[f]];const u=s.data.get(r.dataId).values,d=U0(u,r.shape,r.dtype,o,l);return{dataId:s.write(d,l,r.dtype),shape:l,dtype:r.dtype}}const R4={kernelName:ya,backendName:"cpu",kernelFunc:mn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ak(n,e,t,s){const[r,o]=Wt(n,s),a=fn(e,"int32"),l=Mt(oe(r),a),u=oe(o);for(let d=0;d<l.length;++d){const p=d*u;let f=1;for(let m=0;m<u;++m)f*=t[p+m];l[d]=f}return{outVals:l,outShape:r,outDtype:a}}function _4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s;$e(r,"prod");const l=r.shape.length,u=Me(o,r.shape),d=wt(u,l);let p=u,f=r;const m=[];d!=null&&(f=mn({inputs:{x:r},backend:t,attrs:{perm:d}}),m.push(f),p=bt(p.length,l));const g=t.data.get(f.dataId).values,{outVals:x,outShape:w,outDtype:v}=Ak(f.shape,f.dtype,g,p);let b=w;return a&&(b=It(w,u)),m.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.makeTensorInfo(b,v,x)}const O4={kernelName:Pp,backendName:"cpu",kernelFunc:_4};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D4(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const o=Bo(r,e.length,Ie(e)).join(",");throw new Error(`indices[${o}] = ${s} is not in [0, ${t})`)}})}function A4(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let o=1;o<s.length;++o)if(s[o-1]>s[o])throw new Error("Ragged splits must be sorted in ascending order")}}function F4(n,e,t,s){const r=[];let o=0;const a=e.length-1+t.length,l=new Array(a).fill(null).map(()=>[0]);A4(t,s);let u=1;for(let d=0;d<e.length-1;++d){u*=e[d];const p=e[d+1];for(let f=1;f<u+1;++f)l[d].push(f*p)}for(let d=0;d<n.length;++d){let p=n[d],f=n[d]+1;for(let m=0;m<t.length;++m){const g=t[m],x=m+e.length-1;if(x>=0){const w=l[x],v=w[w.length-1]-g[p];for(let b=p;b<f;++b)l[x].push(g[b+1]+v)}p=g[p],f=g[f]}f!==p&&(r.push([p,f]),o+=f-p)}return{outSplits:l,valueSlices:r,numValues:o}}function P4(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=xt("int32",s);e.push(r),n[t].forEach((o,a)=>r[a]=o)}return e}function _w(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function L4(n,e,t,s,r,o){const a=_w(e,2)[1],l=_w(o,2)[1];let u=0;for(const d of t)for(let p=d[0];p<d[1];++p){for(let f=0;f<s;++f)r[u*l+f]=n[p*a+f];++u}}function V4(n,e,t,s,r){const o=e.slice();o[0]=r;const a=xt(t,oe(o)),l=n.length,u=l===0?0:l/e[0];return L4(n,e,s,u,a,o),[a,o]}function Fk(n,e,t,s,r,o,a,l){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const u=e[0][0]-1;if(D4(o,a,u),s.length===0)throw new Error("params.rank must be nonzero");const d=s[0],{outSplits:p,valueSlices:f,numValues:m}=F4(o,a,n,d),g=P4(p),x=V4(t,s,r,f,m);return[g,x[0],x[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ow=2147483647;function Pk(n,e,t,s,r,o,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const l=e.length===0,u=r.length===0,d=a.length===0,p=[];l||p.push(e[0]),u||p.push(r[0]),d||p.push(a[0]);for(let v=1;v<p.length;++v)if(p[v]!==p[v-1])throw new Error("starts, limits, and deltas must have the same shape");const f=p.length===0?1:p[0],m=xt("int32",f+1);m[0]=0;for(let v=0;v<f;++v){const b=l?n[0]:n[v],C=u?s[0]:s[v],I=d?o[0]:o[v];if(I===0)throw new Error("Requires delta != 0");let N;if(I>0&&C<b||I<0&&C>b)N=0;else if(N=Math.ceil(Math.abs((C-b)/I)),N>Ow)throw new Error(`Requires ((limit - start) / delta) <= ${Ow}`);m[v+1]=m[v]+N}const g=m[f],x=xt(t,g);let w=0;for(let v=0;v<f;++v){const b=m[v+1]-m[v];let C=l?n[0]:n[v];const I=d?o[0]:o[v];for(let N=0;N<b;++N)x[w++]=C,C+=I}return[m,x]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Yn=fs;class xd{constructor(e,t,s,r,o,a,l,u,d,p){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=o,this.defaultValue=a,this.defaultValueShape=l,this.rowPartitionValues=u,this.rowPartitionValuesShapes=d,this.rowPartitionTypes=AC(p),this.raggedRank=FC(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Yn.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Yn.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Yn.VALUE_ROWIDS:return xd.getMaxWidthValueRowID(t);case Yn.ROW_SPLITS:return xd.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Yn[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const o=e[r+1]-e[r];o>s&&(s=o)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],o=0;for(let a=1;a<t;++a){const l=e[a];l!==r&&(r=l,o=Math.max(a-s,o),s=a)}return Math.max(t-s,o)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Aw(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;PC(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=DC(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let l=1;l<=this.raggedRank;++l)a[l]<0&&(a[l]=this.getMaxWidth(l));return a}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),o=[];let a=0;for(let l=0;l<r;++l,a+=t)o.push(a);for(let l=r;l<e;++l)o.push(-1);return O(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,t,s,r){const o=e.length,a=[];for(let l=0;l<o-1;++l){const u=e[l+1]-e[l];let d=Math.min(r,u),p=t[l];p===-1&&(d=0);for(let f=0;f<d;++f)a.push(p),p+=s;for(let f=0;f<u-d;++f)a.push(-1)}if(o>0&&a.length!==e[o-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,s,r){const o=e.length,a=[];if(o===0)return[];let l=0,u=e[0];if(u>=t.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${t.length}`);let d=t[u];a.push(d);for(let p=1;p<o;++p){const f=e[p];if(f===u)d>=0&&(++l,l<r?d+=s:d=-1);else{if(l=0,u=f,f>=t.length)throw new Error(`Got nextValueRowId=${f} which is not less than ${t.length}`);d=t[f]}a.push(d)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,s,r){const o=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case Yn.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,t,s,r);case Yn.ROW_SPLITS:if(o.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(o,t,s,r);default:throw new Error(`Unsupported partition type: ${Yn[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Yn.FIRST_DIM_SIZE:return e[0];case Yn.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Yn.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Yn[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let u=r.length-2;u>=0;--u)r[u]=r[u+1]*s[u+1];const o=Aw(s,!1),a=xt(this.valuesDType,oe(o));if(r[0]*s[0]>0){let u=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let d=1;d<=this.raggedRank;++d)u=this.calculateOutputIndex(d-1,u,r[d],s[d]);this.setOutput(this.raggedRank,u,a,o)}return[o,a]}setOutput(e,t,s,r){if(s.length===0)return;const o=this.values,a=s;let l=r.slice();l=l.slice(e+1);const u=oe(l),d=t.length;let p=this.defaultValue;if(p.length!==u&&p.length!==1){const x=this.defaultValueShape;Ue(()=>{const w=le(p,x);p=wa(w,l).dataSync()})}let f=0,m=0,g=0;for(let x=0;x<=d;++x){let w=x<d?t[x]:-1;if(w===g){++g;continue}if(m<g){const v=o.subarray(f*u),b=a.subarray(m*u),C=(g-m)*u;Dw(b,v,C)}if(x>=d){const v=s.length;w=Math.floor(v/u)}if(w>g)if(this.defaultValue.length===1)a.subarray(g*u,w*u).fill(this.defaultValue[0]),g=w;else for(;w>g;){const v=a.slice(g*u);Dw(v,p,u),++g}w<0?(f=x+1,m=g):(f=x,m=g,g=m+1)}}}function Dw(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function Aw(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function Lk(n,e,t,s,r,o,a,l,u,d){return new xd(n,e,t,s,r,o,a,l,u,d).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vk(n,e,t,s){const r=n===e,o=n<e&&t<0,a=e<n&&t>1;if(r||o||a)return Mt(0,s);const l=Math.abs(Math.ceil((e-n)/t)),u=Mt(l,s);e<n&&t===1&&(t=-1),u[0]=n;for(let d=1;d<u.length;d++)u[d]=u[d-1]+t;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bk=Ls(n=>1/Math.sqrt(n)),B4=Qr(Kl,Bk),M4={kernelName:Kl,backendName:"cpu",kernelFunc:B4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $o(n,e,t,s,r,o,a,l,u,d){const p=[s/r,r],f=n.values,m=e.values;if(s===0)return Ae(t,e.dtype);const g=u instanceof kt?u:Ae(p,e.dtype);typeof u=="string"||typeof u=="number"?g.values.fill(u):typeof u=="boolean"&&g.values.fill(+u);for(let x=0;x<o;x++){const w=[];let v=0;for(let b=0;b<a;b++){const C=f[x*a+b];w.push(C),v+=C*l[b]}if(v<0||v>=s/r)throw new Error(`Invalid indices: ${w} does not index into ${t}`);for(let b=0;b<r;b++)d?g.values[v*r+b]+=m[x*r+b]:g.values[v*r+b]=e.rank===0?m[0]:m[x*r+b]}return g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z4=Ls(n=>1/(1+Math.exp(-n))),Mk=Xe(Jl,n=>1/(1+Math.exp(-n))),W4={kernelName:Jl,backendName:"cpu",kernelFunc:Mk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zk(n,e,t,s,r){const o=p0(s,e,t),a=oe(t),l=Ie(s);if(o){const f=f0(e,l);return r==="string"?n.slice(f,f+a):n.subarray(f,f+a)}const u=r==="string"?rr(n):n,d=Ae(s,r,u),p=Ae(t,r);for(let f=0;f<p.size;++f){const m=p.indexToLoc(f),g=m.map((x,w)=>x+e[w]);p.set(d.get(...g),...m)}return r==="string"?nk(p.values):p.values}function Fo(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,size:a}=s;$e(r,"slice");const[l,u]=h0(r,o,a);c0(r,l,u);const d=t.data.get(r.dataId).values,p=zk(d,l,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,p)}const U4={kernelName:Yp,backendName:"cpu",kernelFunc:Fo};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wk(n,e,t,s,r,o,a){const l=e[0],u=o[0],d=new Array(u),p=new Array(l),f=e[1];if(u===0){if(l!==0)throw new Error(UC(l));const v=xt(t,0),b=xt(r,0);return[v,[0,f],b,d,p]}let m=!0,g=0;const x=new Array(u).fill(0);for(let v=0;v<l;++v){const b=n[v*f];if(b<0)throw new Error(GC(v,b));if(b>=u)throw new Error(HC(v,b,u));++x[b],m=m&&b>=g,g=b}let w=!0;for(let v=0;v<u;++v){const b=x[v]===0;d[v]=b,w=w&&!b,x[v]=Math.max(x[v],1),v>0&&(x[v]+=x[v-1])}if(w&&m){const v=n,b=s;for(let C=0;C<l;++C)p[C]=C;return[v,[l,f],b,d,p]}else{const v=x[u-1],b=xt(t,v*f),C=xt(r,v),I=new Array(u).fill(0);for(let N=0;N<l;++N){const R=n[N*f],D=I[R],F=(R===0?0:x[R-1])+D;I[R]++;for(let V=0;V<f;++V)b[F*f+V]=n[N*f+V];C[F]=s[N],p[N]=F}for(let N=0;N<u;++N)if(I[N]===0){const D=N===0?0:x[N-1];b[D*f+0]=N;for(let F=1;F<f;++F)b[D*f+F]=0;C[D]=a}return[b,[v,f],C,d,p]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uk(n,e,t,s,r){const o=oe(s),a=e[0],l=r.length,u=[];let d=1,p=-1;for(let v=0;v<l;++v){const b=r[v];if(b===-1){if(p!==-1)throw new Error(jC(p,v));p=v,u.push(1)}else{if(b<0)throw new Error(qC(v,b));d*=b,u.push(b)}}if(p!==-1){if(d<=0)throw new Error(KC());const v=Math.trunc(o/d);if(d*v!==o)throw new Error(XC(s,u));u[p]=v}if(oe(u)!==o)throw new Error(YC(s,u));const m=s.length,g=[];if(m>0){g[m-1]=1;for(let v=m-2;v>=0;--v)g[v]=g[v+1]*s[v+1]}const x=[];if(l>0){x[l-1]=1;for(let v=l-2;v>=0;--v)x[v]=x[v+1]*u[v+1]}const w=xt(t,a*l);for(let v=0;v<a;++v){let b=0;for(let C=0;C<m;++C)b+=n[v*m+C]*g[C];for(let C=0;C<l;++C)w[v*l+C]=Math.trunc(b/x[C]),b%=x[C]}return[w,[a,l],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G0(n,e,t,s,r,o=!1,a=0){const l=s.length,u=[e[0],n.length/e[0]],d=u[1],f=l>0?r[l-1]+1:0;if(f<0)throw new Error(kg());const m=e.slice();m[0]=f;const g=m.reduce((I,N)=>I*N,1),x=xt(t,g);if(l===0)return f>0&&x.fill(a),[x,m];if(f<=0)throw new Error(kg());let w=0,v=1,b=0,C=r[w];for(;;){let I=0;if(v<l){if(I=r[v],C===I){++v;continue}if(C>=I)throw new Error(QC())}if(C<0||C>=f)throw new Error(ZC(C,f));C>b&&x.fill(a,b*d,C*d);for(let N=w;N<v;++N){const R=s[N];if(R<0||R>=u[0])throw new Error(JC(N,s[N],u[0]));for(let D=0;D<d;D++)x[C*d+D]+=n[R*d+D]}if(o)for(let N=0;N<d;N++)x[C*d+N]/=v-w;if(w=v,++v,b=C+1,C=I,v>l)break}return b<f&&x.fill(a,b*d,f*d),[x,m]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G4=Ls(n=>Math.sqrt(n)),H4=Xe(tu,n=>Math.sqrt(n)),j4={kernelName:tu,backendName:"cpu",kernelFunc:H4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gk=$t((n,e)=>{const t=n-e;return t*t}),q4=Tt(nu,Gk),K4={kernelName:nu,backendName:"cpu",kernelFunc:q4};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hk=Ls((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),X4=Qr(su,Hk),Y4={kernelName:su,backendName:"cpu",kernelFunc:X4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jk(n,e,t,s){const r=Ae(n,e.dtype);for(let o=0;o<r.size;o++){const a=r.indexToLoc(o),l=new Array(a.length);for(let u=0;u<l.length;u++)l[u]=a[u]*t[u]+s[u];r.set(e.get(...l),...a)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q4{constructor(e,t,s,r,o,a){this.separator=Es(e),this.nGramWidths=t,this.leftPad=Es(s),this.rightPad=Es(r),this.padWidth=o,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,o,a){for(let l=0;l<o;++l){const u=this.getPadWidth(a),d=Math.max(0,u-l),p=Math.max(0,u-(o-(l+1))),f=a-(d+p),m=t+(d>0?0:l-u);let g=0;g+=d*this.leftPad.length;for(let C=0;C<f;++C)g+=e[m+C].length;g+=p*this.rightPad.length;const x=d+p+f-1;g+=x*this.separator.length,s[r+l]=new Uint8Array(g);const w=s[r+l];let v=0;const b=C=>C.forEach(I=>w[v++]=I);for(let C=0;C<d;++C)b(this.leftPad),b(this.separator);for(let C=0;C<f-1;++C)b(e[m+C]),b(this.separator);if(f>0){b(e[m+f-1]);for(let C=0;C<p;++C)b(this.separator),b(this.rightPad)}else{for(let C=0;C<p-1;++C)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let d=1;d<r;++d){let p=t[d]>=u;if(p=p&&t[d]<=s,!p)throw new Error(`Invalid split value ${t[d]}, must be in [${u}, ${s}]`);u=t[d]}if(u!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${u}`)}const o=r-1,a=xt("int32",r);if(s===0||r===0){const u=new Array(s);for(let d=0;d<=o;++d)a[d]=0;return[u,a]}a[0]=0;for(let u=1;u<=o;++u){const d=t[u]-t[u-1];let p=0;this.nGramWidths.forEach(f=>{p+=this.getNumNGrams(d,f)}),this.preserveShort&&d>0&&p===0&&(p=1),a[u]=a[u-1]+p}const l=new Array(a[o]);for(let u=0;u<o;++u){const d=t[u];let p=a[u];if(this.nGramWidths.forEach(f=>{const m=t[u+1]-t[u],g=this.getNumNGrams(m,f);this.createNGrams(e,d,l,p,g,f),p+=g}),this.preserveShort&&p===a[u]){const f=t[u+1]-t[u];if(f===0)continue;const m=f+2*this.padWidth;this.createNGrams(e,d,l,p,1,m)}}return[l,a]}}function qk(n,e,t,s,r,o,a,l){return new Q4(t,s,r,o,a,l).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z4(n,e,t,s){if(!n.length)return;if(e.length===0){for(let o=0;o<n.length;++o)s.push(n.subarray(o,o+1));return}if(e.length===1){const o=e[0];let a=n.indexOf(o);for(;a!==-1;){const l=n.subarray(0,a);(!t||l.length!==0)&&s.push(l),n=n.subarray(a+1),a=n.indexOf(o)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let o=0;o<n.length+1;o++)if(o===n.length||e.indexOf(n[o])!==-1){const a=n.subarray(r,o);(!t||a.length!==0)&&s.push(a),r=o+1}}function Kk(n,e,t){const s=n.length,r=[];let o=0,a=0;const l=new Array(s);for(let m=0;m<s;++m){const g=r.length;Z4(n[m],e,t,r);const x=r.length-g;l[m]=x,o+=x,a=Math.max(a,x)}const u=xt("int32",o*2),d=new Array(o),p=[s,a];let f=0;for(let m=0;m<s;++m)for(let g=0;g<l[m];++g)u[f*2]=m,u[f*2+1]=g,d[f]=r[f],++f;return[u,d,p]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xk(n,e){const t=xt("int32",n.length);for(let s=0;s<n.length;++s)t[s]=Ib(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yk=$t((n,e)=>n-e),J4=M0((n,e,t,s)=>({real:n-t,imag:e-s})),H0=Tt(ru,Yk,J4),eV={kernelName:ru,backendName:"cpu",kernelFunc:H0};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qk(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=Ae(t,n.dtype);for(let r=0;r<s.values.length;++r){const o=s.indexToLoc(r),a=new Array(n.rank);for(let u=0;u<a.length;u++)a[u]=o[u]%n.shape[u];const l=n.locToIndex(a);s.values[r]=n.values[l]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fi=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function Zk(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const l=s-t+1,u=e-t+1,d=Math.log(l),p=.5*Math.exp(2*d/3),f=.5*Math.sqrt(d*p*(l-p)/l)*Math.sign(u-l/2),m=Math.max(t,Math.floor(e-u*p/l+f)),g=Math.min(s,Math.floor(e+(l-u)*p/l+f));Zk(n,e,m,g)}const r=n[e];let o=t,a=s;for(Qs(n,t,e),Fi(n[s],r)>0&&Qs(n,t,s);o<a;){for(Qs(n,o,a),o++,a--;Fi(n[o],r)<0;)o=o+1;for(;Fi(n[a],r)>0;)a=a-1}Fi(n[t],r)===0?Qs(n,t,a):(a=a+1,Qs(n,a,s)),a<=e&&(t=a+1),e<=a&&(s=a-1)}}function Jk(n,e,t,s,r){const o=e[e.length-1],[a,l]=[n.length/o,o],u=Dt(t,a*s),d=Dt("int32",a*s);for(let f=0;f<a;f++){const m=f*l,g=n.subarray(m,m+l);let x=new Array(g.length);g.forEach((C,I)=>x[I]={value:C,index:I}),s<x.length&&(Zk(x,s),x=x.slice(0,s)),r&&x.sort(Fi);const w=f*s,v=u.subarray(w,w+s),b=d.subarray(w,w+s);for(let C=0;C<s;C++)v[C]=x[C].value,b[C]=x[C].index}const p=e.slice();return p[p.length-1]=s,[Ae(p,t,u),Ae(p,"int32",d)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eN(n,e,t,s){const r=Me(e,t)[0],o=[1,t[0],1];for(let x=0;x<r;x++)o[0]*=t[x];o[1]=t[r];for(let x=r+1;x<t.length;x++)o[2]*=t[x];const a=new Map,l=new Int32Array(t[r]),u=new kt(o,s,n),d=[],p=o[0]===1&&o[2]===1;for(let x=0;x<t[r];x++){let w;if(p)w=n[x].toString();else{const b=[];for(let C=0;C<o[0];C++)for(let I=0;I<o[2];I++)b.push(u.get(C,x,I));w=b.join(",")}const v=a.get(w);if(v!=null)l[x]=v;else{const b=a.size;a.set(w,b),l[x]=b,d.push(x)}}const f=o.slice();f[1]=a.size;const m=new kt(f,s);d.forEach((x,w)=>{for(let v=0;v<o[0];v++)for(let b=0;b<o[2];b++)m.set(u.get(v,x,b),v,w,b)});const g=t.slice();return g[r]=f[1],{outputValues:m.values,outputShape:g,indices:l}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tV=Object.freeze(Object.defineProperty({__proto__:null,addImpl:uk,bincountImpl:z0,bincountReduceImpl:ck,bitwiseAndImpl:dk,castImpl:lk,ceilImpl:pk,concatImpl:fk,equalImpl:hk,expImpl:gk,expm1Impl:xk,floorDivImpl:wk,floorImpl:vk,gatherNdImpl:bk,gatherV2Impl:$k,greaterEqualImpl:Ck,greaterImpl:Sk,lessEqualImpl:Nk,lessImpl:kk,linSpaceImpl:Ik,logImpl:Tk,maxImpl:Ek,maximumImpl:Rk,minimumImpl:_k,multiplyImpl:W0,negImpl:Ok,notEqualImpl:Dk,prodImpl:Ak,raggedGatherImpl:Fk,raggedRangeImpl:Pk,raggedTensorToTensorImpl:Lk,rangeImpl:Vk,rsqrtImpl:Bk,scatterImpl:$o,sigmoidImpl:z4,simpleAbsImpl:ik,sliceImpl:zk,sparseFillEmptyRowsImpl:Wk,sparseReshapeImpl:Uk,sparseSegmentReductionImpl:G0,sqrtImpl:G4,squaredDifferenceImpl:Gk,staticRegexReplaceImpl:Hk,stridedSliceImpl:jk,stringNGramsImpl:qk,stringSplitImpl:Kk,stringToHashBucketFastImpl:Xk,subImpl:Yk,tileImpl:Qk,topKImpl:Jk,transposeImpl:U0,uniqueImpl:eN},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */py("cpu",()=>new Wf,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tN=Xe(xl,n=>n>=0?n:Math.exp(n)-1),nV={kernelName:xl,backendName:"cpu",kernelFunc:tN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:o}=s;$e([r],"leakyRelu");const a=oe(r.shape),l=t.data.get(r.dataId).values,u=Dt("float32",a);for(let d=0;d<l.length;d++)u[d]=l[d]<0?o*l[d]:l[d];return t.makeTensorInfo(r.shape,"float32",u)}const sV={kernelName:gp,backendName:"cpu",kernelFunc:nN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rV=$t((n,e)=>n<0?e*n:n);function sN(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;$e([s,r],"prelu");const o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,[l,u]=rV(s.shape,r.shape,o,a,"float32");return t.makeTensorInfo(u,"float32",l)}const oV={kernelName:Fp,backendName:"cpu",kernelFunc:sN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rN=Xe(Hl,n=>Math.max(0,n)),aV={kernelName:Hl,backendName:"cpu",kernelFunc:rN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oN=Xe(jl,n=>Math.min(Math.max(0,n),6)),iV={kernelName:jl,backendName:"cpu",kernelFunc:oN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vd(n,e,t,s,r){if(t==="linear")return Ps({inputs:{x:e},backend:n});if(t==="relu")return rN({inputs:{x:e},backend:n});if(t==="elu")return tN({inputs:{x:e},backend:n});if(t==="relu6")return oN({inputs:{x:e},backend:n});if(t==="prelu")return sN({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return nN({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return Mk({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function it(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:o}=s,a=oe(r.shape),l=jg(o,a),u=oe(l);O(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const d=t.data.get(r.dataId);if(d.complexTensorInfos!=null){const p=d.complexTensorInfos.real,f=d.complexTensorInfos.imag;p.shape=l,f.shape=l}return{dataId:r.dataId,shape:l,dtype:r.dtype}}const lV={kernelName:Wp,backendName:"cpu",kernelFunc:it};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aN(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o}=e,{transposeA:a,transposeB:l}=s;$e([r,o],"matMul");const u=r.shape.length,d=o.shape.length,p=a?r.shape[u-2]:r.shape[u-1],f=l?o.shape[d-1]:o.shape[d-2],m=a?r.shape[u-1]:r.shape[u-2],g=l?o.shape[d-2]:o.shape[d-1],x=r.shape.slice(0,-2),w=o.shape.slice(0,-2),v=oe(x),b=oe(w),I=Le(r.shape.slice(0,-2),o.shape.slice(0,-2)).concat([m,g]);O(p===f,()=>`Error in matMul: inner shapes (${p}) and (${f}) of Tensors with shapes ${r.shape} and ${o.shape} and transposeA=${a} and transposeB=${l} must match.`);const N=a?[v,p,m]:[v,m,p],R=l?[b,g,f]:[b,f,g],D=it({inputs:{x:r},backend:t,attrs:{shape:N}}),F=it({inputs:{x:o},backend:t,attrs:{shape:R}}),V=a?D.shape[1]:D.shape[2],P=a?D.shape[2]:D.shape[1],A=l?F.shape[1]:F.shape[2],T=Math.max(v,b),W=t.data.get(D.dataId).values,j=t.data.get(F.dataId).values,Y=Ie(D.shape),Q=Ie(F.shape),[Z,ne,U]=a?[Y[0],1,Y[1]]:[Y[0],Y[1],1],[K,X,L]=l?[1,Q[1],Q[0]]:[Q[1],1,Q[0]],H=P*A,re=Ae([T,P,A],D.dtype),ae=re.values,ie=t.blockSize;for(let ue=0;ue<T;ue++){const he=ue%v,me=ue%b;for(let ye=0;ye<P;ye+=ie){const Te=Math.min(ye+ie,P);for(let De=0;De<A;De+=ie){const ze=Math.min(De+ie,A);for(let Ge=0;Ge<V;Ge+=ie){const nt=Math.min(Ge+ie,V);for(let Ke=ye;Ke<Te;Ke++)for(let He=De;He<ze;He++){let Je=0;for(let et=Ge;et<nt;et++){const On=W[he*Z+Ke*ne+et*U],dt=j[et*K+He*X+me*L];Je+=On*dt}ae[ue*H+(Ke*A+He)]+=Je}}}}}return t.disposeIntermediateTensorInfo(D),t.disposeIntermediateTensorInfo(F),t.makeTensorInfo(I,re.dtype,re.values)}const uV={kernelName:Ld,backendName:"cpu",kernelFunc:aN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cV(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o,bias:a,preluActivationWeights:l}=e,{transposeA:u,transposeB:d,activation:p,leakyreluAlpha:f}=s;let m,g,x;const w=[];m=aN({inputs:{a:r,b:o},attrs:{transposeA:u,transposeB:d},backend:t}),a&&(g=Ra({inputs:{a:m,b:a},backend:t}),w.push(m),m=g),p&&(x=vd(t,m,p,l,f),w.push(m),m=x);for(const b of w)t.disposeIntermediateTensorInfo(b);return m}const dV={kernelName:Bi,backendName:"cpu",kernelFunc:cV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pV=Xe(rl,n=>Math.acos(n)),fV={kernelName:rl,backendName:"cpu",kernelFunc:pV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hV=Xe(ol,n=>Math.acosh(n)),mV={kernelName:ol,backendName:"cpu",kernelFunc:hV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gV(n){const{inputs:e,backend:t}=n,s=e;$e(e,"addN");const r=s.map(l=>t.data.get(l.dataId).values),o=Ae(s[0].shape,s[0].dtype),a=o.values;for(let l=0;l<s.length;l++){const u=r[l];for(let d=0;d<a.length;d++)a[d]+=u[d]}return t.makeTensorInfo(o.shape,o.dtype,o.values)}const yV={kernelName:Rd,backendName:"cpu",kernelFunc:gV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s;$e(r,"all");const l=Me(o,r.shape);let u=l;const d=wt(u,r.shape.length);let p=r;d!=null&&(p=mn({inputs:{x:r},backend:t,attrs:{perm:d}}),u=bt(u.length,r.shape.length)),Ut("all",u,p.shape.length);const[f,m]=Wt(p.shape,u),g=oe(m),x=Mt(oe(f),p.dtype),w=t.data.get(p.dataId).values;for(let b=0;b<x.length;++b){const C=b*g;let I=w[C];for(let N=0;N<g;++N){const R=w[C+N];I=I&&R}x[b]=I}d!=null&&t.disposeIntermediateTensorInfo(p);const v=t.makeTensorInfo(f,p.dtype,x);if(a){const b=It(f,l),C=it({inputs:{x:v},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(v),C}return v}const vV={kernelName:_d,backendName:"cpu",kernelFunc:xV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s;$e(r,"any");const l=Me(o,r.shape);let u=l;const d=wt(u,r.shape.length);let p=r;d!=null&&(p=mn({inputs:{x:r},backend:t,attrs:{perm:d}}),u=bt(u.length,r.shape.length)),Ut("any",u,p.shape.length);const[f,m]=Wt(p.shape,u),g=oe(m),x=Mt(oe(f),p.dtype),w=t.data.get(p.dataId).values;for(let b=0;b<x.length;++b){const C=b*g;let I=w[C];for(let N=0;N<g;++N){const R=w[C+N];I=I||R}x[b]=I}d!=null&&t.disposeIntermediateTensorInfo(p);const v=t.makeTensorInfo(f,p.dtype,x);if(a){const b=It(f,l),C=it({inputs:{x:v},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(v),C}return v}const bV={kernelName:Od,backendName:"cpu",kernelFunc:wV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $V(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;$e(r,"argMax");let a=Me(o,r.shape);const l=wt(a,r.shape.length);let u=r;const d=[];l!=null&&(u=mn({inputs:{x:r},backend:t,attrs:{perm:l}}),d.push(u),a=bt(a.length,u.shape.length)),a=[a[0]],Ut("argMax",a,u.shape.length);const[p,f]=Wt(u.shape,a),m=oe(p),g=Mt(m,"int32"),x=oe(f),w=t.data.get(u.dataId).values;for(let v=0;v<g.length;++v){const b=v*x;let C=w[b],I=0;for(let N=0;N<x;++N){const R=w[b+N];R>C&&(C=R,I=N)}g[v]=I}return d.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(p,"int32",g)}const SV={kernelName:Dd,backendName:"cpu",kernelFunc:$V};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;$e(r,"argMin");let a=Me(o,r.shape);const l=wt(a,r.shape.length);let u=r;const d=[];l!=null&&(u=mn({inputs:{x:r},backend:t,attrs:{perm:l}}),d.push(u),a=bt(a.length,u.shape.length)),a=[a[0]],Ut("argMin",a,u.shape.length);const[p,f]=Wt(u.shape,a),m=oe(p),g=Mt(m,"int32"),x=oe(f),w=t.data.get(u.dataId).values;for(let v=0;v<g.length;++v){const b=v*x;let C=w[b],I=0;for(let N=0;N<x;++N){const R=w[b+N];R<C&&(C=R,I=N)}g[v]=I}return d.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(p,"int32",g)}const kV={kernelName:Ad,backendName:"cpu",kernelFunc:CV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NV=Xe(al,n=>Math.asin(n)),IV={kernelName:al,backendName:"cpu",kernelFunc:NV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TV=Xe(il,n=>Math.asinh(n)),EV={kernelName:il,backendName:"cpu",kernelFunc:TV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RV=Xe(ll,n=>Math.atan(n)),_V={kernelName:ll,backendName:"cpu",kernelFunc:RV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OV=$t((n,e)=>Math.atan2(n,e)),DV=Tt(cl,OV),AV={kernelName:cl,backendName:"cpu",kernelFunc:DV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FV=Xe(ul,n=>Math.atanh(n)),PV={kernelName:ul,backendName:"cpu",kernelFunc:FV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j0(n,e,t,s,r,o){const a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,d=r.dilationWidth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.top,g=r.padInfo.left,x=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=Ae(r.outShape,t),v=w.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],C=r.outShape[2]*r.outShape[3],I=r.outShape[3];for(let N=0;N<r.batchSize;++N){const R=N*b,D=N*s[0];for(let F=0;F<r.inChannels;++F)for(let V=0;V<r.outHeight;++V){const P=V*a-m,A=Math.max(0,P),T=Math.min(r.inHeight,p+P),W=R+V*C;for(let j=0;j<r.outWidth;++j){const Y=j*l-g,Q=Math.max(0,Y),Z=Math.min(r.inWidth,f+Y);let ne=x,U=0,K=0;for(let L=A;L<T;L+=u){const H=D+L*s[1];for(let re=Q;re<Z;re+=d){const ae=H+re*s[2],ie=n[ae+F];o==="max"&&ie>ne?ne=ie:o==="avg"&&(U+=ie,K++)}if(isNaN(ne))break}const X=W+j*I+F;v[X]=o==="avg"?U/K:ne}}}return w}function iN(n,e,t,s,r=!1,o=!1){const a=Ae(s.outShape,"int32"),l=s.strideHeight,u=s.strideWidth,d=s.dilationHeight,p=s.dilationWidth,f=s.effectiveFilterHeight,m=s.effectiveFilterWidth,g=s.padInfo.top,x=s.padInfo.left,w=Ae(e,t,n);for(let v=0;v<s.batchSize;++v)for(let b=0;b<s.inChannels;++b)for(let C=0;C<s.outHeight;++C){const I=C*l-g;let N=I;for(;N<0;)N+=d;const R=Math.min(s.inHeight,f+I);for(let D=0;D<s.outWidth;++D){const F=D*u-x;let V=F;for(;V<0;)V+=p;const P=Math.min(s.inWidth,m+F);let A=Number.NEGATIVE_INFINITY,T=-1;for(let W=N;W<R;W+=d){const j=W-I;for(let Y=V;Y<P;Y+=p){const Q=Y-F,Z=w.get(v,W,Y,b);Z>A&&(A=Z,r?T=o?((v*s.inHeight+W)*s.inWidth+Y)*s.inChannels+b:(W*s.inWidth+Y)*s.inChannels+b:T=j*m+Q)}}a.set(T,v,C,D,b)}}return a}function lN(n,e,t,s,r,o){const a=r.strideDepth,l=r.strideHeight,u=r.strideWidth,d=r.dilationDepth,p=r.dilationHeight,f=r.dilationWidth,m=r.effectiveFilterDepth,g=r.effectiveFilterHeight,x=r.effectiveFilterWidth,w=r.padInfo.front,v=r.padInfo.top,b=r.padInfo.left,C=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,I=Ae(r.outShape,t),N=I.values,R=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],D=r.outShape[2]*r.outShape[3]*r.outShape[4],F=r.outShape[3]*r.outShape[4],V=r.outShape[4];for(let P=0;P<r.batchSize;++P){const A=P*R,T=P*s[0];for(let W=0;W<r.inChannels;++W)for(let j=0;j<r.outDepth;++j){const Y=j*a-w;let Q=Y;for(;Q<0;)Q+=d;const Z=Math.min(r.inDepth,m+Y),ne=A+j*D;for(let U=0;U<r.outHeight;++U){const K=U*l-v;let X=K;for(;X<0;)X+=p;const L=Math.min(r.inHeight,g+K),H=ne+U*F;for(let re=0;re<r.outWidth;++re){const ae=re*u-b;let ie=ae;for(;ie<0;)ie+=f;const ue=Math.min(r.inWidth,x+ae),he=H+re*V;let me=C,ye=0,Te=0;for(let ze=Q;ze<Z;ze+=d){const Ge=T+ze*s[1];for(let nt=X;nt<L;nt+=p){const Ke=Ge+nt*s[2];for(let He=ie;He<ue;He+=f){const Je=Ke+He*s[3],et=n[Je+W];if(o==="max"&&et>me?me=et:o==="avg"&&(ye+=et,Te++),isNaN(me))break}if(isNaN(me))break}if(isNaN(me))break}const De=he+W;N[De]=o==="avg"?ye/Math.max(Te,1):me}}}}return I}function LV(n,e){const t=Ae(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,o=e.strideWidth,a=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,x=e.padInfo.left;for(let w=0;w<e.batchSize;++w)for(let v=0;v<e.inChannels;++v)for(let b=0;b<e.outDepth;++b){const C=b*s-m;let I=C;for(;I<0;)I+=a;const N=Math.min(e.inDepth,d+C);for(let R=0;R<e.outHeight;++R){const D=R*r-g;let F=D;for(;F<0;)F+=l;const V=Math.min(e.inHeight,p+D);for(let P=0;P<e.outWidth;++P){const A=P*o-x;let T=A;for(;T<0;)T+=u;const W=Math.min(e.inWidth,f+A);let j=Number.NEGATIVE_INFINITY,Y=-1;for(let Q=I;Q<N;Q+=a){const Z=Q-C;for(let ne=F;ne<V;ne+=l){const U=ne-D;for(let K=T;K<W;K+=u){const X=K-A,L=n.get(w,Q,ne,K,v);L>=j&&(j=L,Y=Z*p*f+U*p+X)}}}t.set(Y,w,b,R,P,v)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;$e(r,"avgPool");const{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=s,d=1;O(Yt(a,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const p=es(r.shape,o,a,d,l,u);let f;if(p.filterWidth===1&&p.filterHeight===1&&Qe(p.inShape,p.outShape))f=Ps({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,g=Ie(r.shape),x=j0(m,r.shape,r.dtype,g,p,"avg");f=t.makeTensorInfo(p.outShape,r.dtype,x.values)}return f}const BV={kernelName:Fd,backendName:"cpu",kernelFunc:VV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u,dataFormat:d}=s;$e(r,"avgPool3d");const p=ir(r.shape,o,a,1,l,u,d),f=t.data.get(r.dataId).values,m=lN(f,r.shape,r.dtype,Ie(r.shape),p,"avg");return t.makeTensorInfo(m.shape,"float32",m.values)}const zV={kernelName:Pd,backendName:"cpu",kernelFunc:MV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WV(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,{filterSize:a,strides:l,pad:u,dimRoundingMode:d}=s;$e([r,o],"avgPool3DGrad");const p=ir(o.shape,a,l,1,u,d),f=p.strideDepth,m=p.strideHeight,g=p.strideWidth,x=p.filterDepth,w=p.filterHeight,v=p.filterWidth,b=p.dilationDepth,C=p.dilationHeight,I=p.dilationWidth,N=p.effectiveFilterDepth,R=p.effectiveFilterHeight,D=p.effectiveFilterWidth,F=N-1-p.padInfo.front,V=D-1-p.padInfo.left,P=R-1-p.padInfo.top,A=Ae(o.shape,"float32"),T=1/(x*w*v),W=t.bufferSync(r);for(let j=0;j<p.batchSize;++j)for(let Y=0;Y<p.inChannels;++Y)for(let Q=0;Q<p.inDepth;++Q)for(let Z=0;Z<p.inHeight;++Z)for(let ne=0;ne<p.inWidth;++ne){const U=Q-F,K=Z-P,X=ne-V;let L=0;for(let H=0;H<N;H+=b){const re=(U+H)/f;if(!(re<0||re>=p.outDepth||Math.floor(re)!==re))for(let ae=0;ae<R;ae+=C){const ie=(K+ae)/m;if(!(ie<0||ie>=p.outHeight||Math.floor(ie)!==ie))for(let ue=0;ue<D;ue+=I){const he=(X+ue)/g;if(he<0||he>=p.outWidth||Math.floor(he)!==he)continue;const me=W.get(j,re,ie,he,Y);L+=me}}}A.set(L*T,j,Q,Z,ne,Y)}return t.makeTensorInfo(A.shape,A.dtype,A.values)}const UV={kernelName:Zg,backendName:"cpu",kernelFunc:WV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GV(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,a=o;$e([r,o],"avgPoolGrad");const{filterSize:l,strides:u,pad:d}=s,p=es(a.shape,l,u,1,d),f=p.strideHeight,m=p.strideWidth,g=p.filterHeight,x=p.filterWidth,w=p.dilationHeight,v=p.dilationWidth,b=p.effectiveFilterHeight,C=p.effectiveFilterWidth,I=C-1-p.padInfo.left,N=b-1-p.padInfo.top,R=Ae(a.shape,"float32"),D=1/(g*x),F=t.data.get(r.dataId).values,V=Ae(r.shape,"float32",F);for(let P=0;P<p.batchSize;++P)for(let A=0;A<p.inChannels;++A)for(let T=0;T<p.inHeight;++T)for(let W=0;W<p.inWidth;++W){const j=T-N,Y=W-I;let Q=0;for(let Z=0;Z<b;Z+=w){const ne=(j+Z)/f;if(!(ne<0||ne>=p.outHeight||Math.floor(ne)!==ne))for(let U=0;U<C;U+=v){const K=(Y+U)/m;if(K<0||K>=p.outWidth||Math.floor(K)!==K)continue;const X=V.get(P,ne,K,A);Q+=X}}R.set(Q*D,P,T,W,A)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}const HV={kernelName:Qg,backendName:"cpu",kernelFunc:GV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:o,offset:a,mean:l,variance:u}=e;O(l.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(a==null||l.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(o==null||l.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),$e([r,l,u,o,a],"batchNorm");let{varianceEpsilon:d}=s;d==null&&(d=.001);const p=t.data.get(r.dataId).values,f=t.data.get(l.dataId).values,m=t.data.get(u.dataId).values,g=o?t.data.get(o.dataId).values:new Float32Array([1]),x=a?t.data.get(a.dataId).values:new Float32Array([0]),w=new Float32Array(p.length),v=x.length,b=g.length,C=m.length,I=f.length;let N=0,R=0,D=0,F=0;for(let V=0;V<p.length;++V)w[V]=x[N++]+(p[V]-f[R++])*g[D++]/Math.sqrt(m[F++]+d),N>=v&&(N=0),R>=I&&(R=0),D>=b&&(D=0),F>=C&&(F=0);return t.makeTensorInfo(r.shape,r.dtype,w)}const qV={kernelName:dp,backendName:"cpu",kernelFunc:jV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,crops:a}=s;$e([r],"batchToSpaceND");const l=o.reduce((b,C)=>b*C),u=vu(r.shape,o,l),d=wu(u.length,o.length),p=bu(r.shape,o,l),f=v0(a,o.length),m=w0(p,a,o.length),g=it({inputs:{x:r},backend:t,attrs:{shape:u}}),x=mn({inputs:{x:g},backend:t,attrs:{perm:d}}),w=it({inputs:{x},backend:t,attrs:{shape:p}}),v=Fo({inputs:{x:w},backend:t,attrs:{begin:f,size:m}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),v}const XV={kernelName:Vd,backendName:"cpu",kernelFunc:KV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:a}=s,l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,d=z0(l,u,o.dtype,o.shape,a);return t.makeTensorInfo([a],o.dtype,d)}const QV={kernelName:Bd,backendName:"cpu",kernelFunc:YV};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZV(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=Le(Array.from(o),Array.from(a));return t.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const JV={kernelName:Md,backendName:"cpu",kernelFunc:ZV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eB=Xe(hl,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),tB={kernelName:hl,backendName:"cpu",kernelFunc:eB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nB=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(oe(e.shape)),r=t.data.get(e.dataId),o=r.complexTensorInfos.real,a=r.complexTensorInfos.imag,l=t.data.get(o.dataId).values,u=t.data.get(a.dataId).values;for(let d=0;d<l.length;d++){const p=l[d],f=u[d];s[d]=Math.hypot(p,f)}return t.makeOutput(s,e.shape,"float32")},sB={kernelName:Wd,backendName:"cpu",kernelFunc:nB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _a(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,o=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,o)}const rB={kernelName:mp,backendName:"cpu",kernelFunc:_a};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oa(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,o=Me(r,e[0].shape)[0],a=e.map(w=>w.shape);g0(a,o);let l=Rs(e.map(w=>w.shape),o);if(oe(l)===0)return t.makeTensorInfo(l,e[0].dtype,[]);const u=e.filter(w=>oe(w.shape)>0);if(u.length===1)return Ps({inputs:{x:u[0]},backend:t});if(u[0].dtype==="complex64"){const w=u.map(N=>Ao({inputs:{input:N},backend:t})),v=u.map(N=>_a({inputs:{input:N},backend:t})),b=Oa({inputs:w,backend:t,attrs:{axis:o}}),C=Oa({inputs:v,backend:t,attrs:{axis:o}}),I=Tn({inputs:{real:b,imag:C},backend:t});return w.forEach(N=>t.disposeIntermediateTensorInfo(N)),v.forEach(N=>t.disposeIntermediateTensorInfo(N)),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(C),I}const d=u.map(w=>{const b=[-1,oe(w.shape.slice(o))];return it({inputs:{x:w},backend:t,attrs:{shape:b}})}),p=d.map(w=>({vals:t.data.get(w.dataId).values,shape:w.shape}));l=Rs(d.map(w=>w.shape),1);const f=d[0].shape[0]===1,m=fk(p,l,e[0].dtype,f),g=Rs(u.map(w=>w.shape),o),x=t.makeTensorInfo(g,e[0].dtype,m);return d.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const oB={kernelName:Ud,backendName:"cpu",kernelFunc:Oa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:l,dataFormat:u,dilations:d,dimRoundingMode:p}=s;$e([r,o],"conv2d");const f=lr(u),m=At(r.shape,o.shape,a,d,l,p,!1,f),g=m.filterHeight,x=m.filterWidth,w=m.dilationHeight,v=m.dilationWidth,b=m.padInfo.left,C=m.padInfo.top,I=m.dataFormat==="channelsLast",N=new kt(m.outShape,r.dtype),R=Ie(r.shape),D=Ie(o.shape),F=R[0],V=I?R[1]:R[2],P=I?R[2]:1,A=I?1:R[1],T=N.strides[0],W=I?N.strides[1]:N.strides[2],j=I?N.strides[2]:1,Y=I?1:N.strides[1],Q=t.data.get(r.dataId).values,Z=t.data.get(o.dataId).values,ne=N.values;for(let U=0;U<m.batchSize;++U){const K=U*F,X=U*T;for(let L=0;L<m.outHeight;++L){const H=X+L*W,re=L*m.strideHeight-C;for(let ae=0;ae<g;++ae){const ie=re+ae*w;if(ie<0||ie>=m.inHeight)continue;const ue=ae*D[0],he=K+ie*V;for(let me=0;me<m.outWidth;++me){const ye=H+me*j,Te=me*m.strideWidth-b;for(let De=0;De<x;++De){const ze=Te+De*v;if(ze<0||ze>=m.inWidth)continue;const Ge=ue+De*D[1],nt=he+ze*P;let Ke=Ge;for(let He=0;He<m.inChannels;++He){const Je=Q[nt+He*A];for(let et=0;et<m.outChannels;++et)ne[ye+et*Y]+=Je*Z[Ke+et];Ke+=m.outChannels}}}}}}return t.makeTensorInfo(N.shape,N.dtype,ne)}const aB={kernelName:Gd,backendName:"cpu",kernelFunc:uN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,pad:l,dataFormat:u,dimRoundingMode:d,filterShape:p}=s;$e([r,o],"conv2dBackpropFilter");const f=lr(u),m=At(r.shape,p,a,1,l,d,!1,f),{strideHeight:g,strideWidth:x,filterHeight:w,filterWidth:v}=m,b=m.dataFormat==="channelsLast",C=new kt(m.filterShape,"float32"),I=m.padInfo.left,N=m.padInfo.top,R=t.data.get(r.dataId).values,D=t.data.get(o.dataId).values,F=new kt(r.shape,r.dtype,R),V=new kt(o.shape,o.dtype,D);for(let P=0;P<w;++P){const A=Math.max(0,Math.ceil((N-P)/g)),T=Math.min(m.outHeight,(m.inHeight+N-P)/g);for(let W=0;W<v;++W){const j=Math.max(0,Math.ceil((I-W)/x)),Y=Math.min(m.outWidth,(m.inWidth+I-W)/x);for(let Q=0;Q<m.inChannels;++Q)for(let Z=0;Z<m.outChannels;++Z){let ne=0;for(let U=0;U<m.batchSize;++U)for(let K=A;K<T;++K){const X=P+K*g-N;for(let L=j;L<Y;++L){const H=W+L*x-I;b?ne+=F.get(U,X,H,Q)*V.get(U,K,L,Z):ne+=F.get(U,Q,X,H)*V.get(U,Z,K,L)}}C.set(ne,P,W,Q,Z)}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const lB={kernelName:Hd,backendName:"cpu",kernelFunc:iB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uB(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{inputShape:a,strides:l,pad:u,dataFormat:d,dimRoundingMode:p}=s;$e([r,o],"conv2dBackpropInput");const f=Ie(o.shape),m=Ie(r.shape);let g=lr(d);const x=At(a,o.shape,l,1,u,p,!1,g),w=new kt(x.inShape,"float32"),v=w.values,b=t.data.get(r.dataId).values,C=t.data.get(o.dataId).values,[I,N,R]=f,{batchSize:D,filterHeight:F,filterWidth:V,inChannels:P,inHeight:A,inWidth:T,outChannels:W,outHeight:j,outWidth:Y,strideHeight:Q,strideWidth:Z}=x;g=x.dataFormat;const ne=F-1-x.padInfo.top,U=V-1-x.padInfo.left,K=g==="channelsLast",X=w.strides[0],L=K?w.strides[1]:w.strides[2],H=K?w.strides[2]:1,re=K?1:w.strides[1],ae=m[0],ie=K?m[1]:m[2],ue=K?m[2]:1,he=K?1:m[1];for(let me=0;me<D;++me)for(let ye=0;ye<P;++ye)for(let Te=0;Te<A;++Te){const De=Te-ne,ze=Math.max(0,Math.ceil(De/Q)),Ge=Math.min(j,(F+De)/Q);for(let nt=0;nt<T;++nt){const Ke=nt-U,He=Math.max(0,Math.ceil(Ke/Z)),Je=Math.min(Y,(V+Ke)/Z);let et=0;for(let dt=ze;dt<Ge;++dt){const cn=dt*Q-De;for(let jt=He;jt<Je;++jt){const ws=jt*Z-Ke,gn=ae*me+ie*dt+ue*jt,Wn=I*(F-1-cn)+N*(V-1-ws)+R*ye;for(let ss=0;ss<W;++ss){const Un=b[gn+he*ss],Dn=C[Wn+ss];et+=Un*Dn}}}const On=X*me+L*Te+H*nt+re*ye;v[On]=et}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const cB={kernelName:jd,backendName:"cpu",kernelFunc:uB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:l,dilations:u}=s;$e([r,o],"conv3d");const d=qr(r.shape,o.shape,a,u,l),{filterDepth:p,filterHeight:f,filterWidth:m,dilationDepth:g,dilationHeight:x,dilationWidth:w,padInfo:v}=d,b=v.front,C=v.left,I=v.top,N=new kt(d.outShape,r.dtype),R=t.data.get(r.dataId).values,D=t.data.get(o.dataId).values,F=N.values,V=Ie(r.shape),P=Ie(o.shape);for(let A=0;A<d.batchSize;++A){const T=A*V[0],W=A*N.strides[0];for(let j=0;j<d.outDepth;++j){const Y=W+j*N.strides[1],Q=j*d.strideDepth-b;for(let Z=0;Z<p;++Z){const ne=Q+Z*g;if(ne<0||ne>=d.inDepth)continue;const U=Z*P[0],K=T+ne*V[1];for(let X=0;X<d.outHeight;++X){const L=Y+X*N.strides[2],H=X*d.strideHeight-I;for(let re=0;re<f;++re){const ae=H+re*x;if(ae<0||ae>=d.inHeight)continue;const ie=U+re*P[1],ue=K+ae*V[2];for(let he=0;he<d.outWidth;++he){const me=L+he*d.outChannels,ye=he*d.strideWidth-C;for(let Te=0;Te<m;++Te){const De=ye+Te*w;if(De<0||De>=d.inWidth)continue;const ze=ie+Te*P[2],Ge=ue+De*d.inChannels;let nt=ze;for(let Ke=0;Ke<d.inChannels;++Ke){const He=R[Ge+Ke];for(let Je=0;Je<d.outChannels;++Je)F[me+Je]+=He*D[nt+Je];nt+=d.outChannels}}}}}}}}return t.makeTensorInfo(N.shape,N.dtype,N.values)}const pB={kernelName:qd,backendName:"cpu",kernelFunc:dB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,pad:l,filterShape:u}=s;$e([r,o],"conv3dBackpropFilterV2");const d=Ie(r.shape),p=Ie(o.shape),f=qr(r.shape,u,a,1,l),m=f.strideDepth,g=f.strideHeight,x=f.strideWidth,w=f.filterDepth,v=f.filterHeight,b=f.filterWidth,C=new kt(f.filterShape,"float32"),I=C.values,[N,R,D,F]=C.strides,V=t.data.get(o.dataId).values,[P,A,T,W]=p,j=t.data.get(r.dataId).values,[Y,Q,Z,ne]=d,U=f.padInfo.front,K=f.padInfo.left,X=f.padInfo.top;for(let L=0;L<w;++L){const H=Math.max(0,Math.ceil((U-L)/m)),re=Math.min(f.outDepth,(f.inDepth+U-L)/m),ae=L*N;for(let ie=0;ie<v;++ie){const ue=Math.max(0,Math.ceil((X-ie)/g)),he=Math.min(f.outHeight,(f.inHeight+X-ie)/g),me=ie*R+ae;for(let ye=0;ye<b;++ye){const Te=Math.max(0,Math.ceil((K-ye)/x)),De=Math.min(f.outWidth,(f.inWidth+K-ye)/x),ze=ye*D+me;for(let Ge=0;Ge<f.inChannels;++Ge){const nt=Ge*F+ze;for(let Ke=0;Ke<f.outChannels;++Ke){let He=0;for(let Je=0;Je<f.batchSize;++Je){const et=Je*Y,On=Je*P;for(let dt=H;dt<re;++dt){const jt=(L+dt*m-U)*Q+et,ws=dt*A+On;for(let gn=ue;gn<he;++gn){const ss=(ie+gn*g-X)*Z+jt,Un=gn*T+ws;for(let Dn=Te;Dn<De;++Dn){const Vs=(ye+Dn*x-K)*ne+ss,Bs=Dn*W+Un;He+=j[Vs+Ge]*V[Bs+Ke]}}}}I[nt+Ke]=He}}}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const hB={kernelName:Jg,backendName:"cpu",kernelFunc:fB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mB(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{pad:a,strides:l,inputShape:u}=s;$e([r],"conv3dBackpropInputV2");const d=Ie(r.shape),p=Ie(o.shape),f=qr(u,o.shape,l,1,a),m=new kt(f.inShape,"float32"),g=m.values,[x,w,v,b]=m.strides,C=t.data.get(r.dataId).values,[I,N,R,D]=d,F=t.data.get(o.dataId).values,[V,P,A,T]=p,{batchSize:W,filterDepth:j,filterHeight:Y,filterWidth:Q,inChannels:Z,inDepth:ne,inHeight:U,inWidth:K,outChannels:X,outDepth:L,outHeight:H,outWidth:re,strideDepth:ae,strideHeight:ie,strideWidth:ue}=f,he=j-1-f.padInfo.front,me=Y-1-f.padInfo.top,ye=Q-1-f.padInfo.left;for(let Te=0;Te<W;++Te)for(let De=0;De<Z;++De)for(let ze=0;ze<ne;++ze){const Ge=ze-he,nt=Math.max(0,Math.ceil(Ge/ae)),Ke=Math.min(L,(j+Ge)/ae);for(let He=0;He<U;++He){const Je=He-me,et=Math.max(0,Math.ceil(Je/ie)),On=Math.min(H,(Y+Je)/ie);for(let dt=0;dt<K;++dt){const cn=dt-ye,jt=Math.max(0,Math.ceil(cn/ue)),ws=Math.min(re,(Q+cn)/ue);let gn=0;for(let Wn=nt;Wn<Ke;++Wn){const ss=Wn*ae-Ge;for(let Un=et;Un<On;++Un){const Dn=Un*ie-Je;for(let dr=jt;dr<ws;++dr){const Vs=dr*ue-cn,Bs=I*Te+N*Wn+R*Un+D*dr,Xf=V*(j-1-ss)+P*(Y-1-Dn)+A*(Q-1-Vs)+T*De;for(let Jr=0;Jr<X;++Jr){const Tu=C[Bs+Jr],Yf=F[Xf+Jr];gn+=Tu*Yf}}}}g[x*Te+w*ze+v*He+b*dt+De]=gn}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const gB={kernelName:Kd,backendName:"cpu",kernelFunc:mB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yB=Xe(ml,n=>Math.cos(n)),xB={kernelName:ml,backendName:"cpu",kernelFunc:yB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vB=Xe(gl,n=>Math.cosh(n)),wB={kernelName:gl,backendName:"cpu",kernelFunc:vB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bB(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:o,boxInd:a}=e,{cropSize:l,method:u,extrapolationValue:d}=s,[p,f,m,g]=r.shape,x=o.shape[0],[w,v]=l,b=Ae([x,w,v,g],"float32"),C=t.data.get(o.dataId).values,I=t.data.get(a.dataId).values,N=t.data.get(r.dataId).values,R=Ie(r.shape),D=Ie(b.shape);for(let F=0;F<x;F++){const V=F*4,P=C[V],A=C[V+1],T=C[V+2],W=C[V+3],j=I[F];if(j>=p)continue;const Y=w>1?(T-P)*(f-1)/(w-1):0,Q=v>1?(W-A)*(m-1)/(v-1):0;for(let Z=0;Z<w;Z++){const ne=w>1?P*(f-1)+Z*Y:.5*(P+T)*(f-1);if(ne<0||ne>f-1){for(let U=0;U<v;U++)for(let K=0;K<g;K++){const X=K+U*D[2]+Z*D[1]+F*D[0];b.values[X]=d}continue}if(u==="bilinear"){const U=Math.floor(ne),K=Math.ceil(ne),X=ne-U;for(let L=0;L<v;L++){const H=v>1?A*(m-1)+L*Q:.5*(A+W)*(m-1);if(H<0||H>m-1){for(let ue=0;ue<g;ue++){const he=ue+L*D[2]+Z*D[1]+F*D[0];b.values[he]=d}continue}const re=Math.floor(H),ae=Math.ceil(H),ie=H-re;for(let ue=0;ue<g;ue++){let he=ue+re*R[2]+U*R[1]+j*R[0];const me=N[he];he=ue+ae*R[2]+U*R[1]+j*R[0];const ye=N[he];he=ue+re*R[2]+K*R[1]+j*R[0];const Te=N[he];he=ue+ae*R[2]+K*R[1]+j*R[0];const De=N[he],ze=me+(ye-me)*ie,Ge=Te+(De-Te)*ie;he=ue+L*D[2]+Z*D[1]+F*D[0],b.values[he]=ze+(Ge-ze)*X}}}else for(let U=0;U<v;++U){const K=v>1?A*(m-1)+U*Q:.5*(A+W)*(m-1);if(K<0||K>m-1){for(let H=0;H<g;H++){const re=H+U*D[2]+Z*D[1]+F*D[0];b.values[re]=d}continue}const X=Math.round(K),L=Math.round(ne);for(let H=0;H<g;H++){const re=H+X*R[2]+L*R[1]+j*R[0],ae=H+U*D[2]+Z*D[1]+F*D[0];b.values[ae]=N[re]}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const $B={kernelName:Qd,backendName:"cpu",kernelFunc:bB};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:a,reverse:l}=s;$e(r,"cumprod");const u=wt([o],r.shape.length);let d=r;u!=null&&(d=mn({inputs:{x:r},backend:t,attrs:{perm:u}}));const p=bt(1,r.shape.length)[0];if(p!==d.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${p}`);const f=fn(d.dtype,"int32"),m=Td(oe(d.shape),f),g=t.data.get(d.dataId).values,x=d.shape[d.shape.length-1],w=l?(b,C)=>b+x-C-1:(b,C)=>b+C;for(let b=0;b<g.length;b+=x)for(let C=0;C<x;C++){const I=w(b,C);if(C===0)m[I]=a?1:g[I];else{const N=w(b,C-1);m[I]=a?g[N]*m[N]:g[I]*m[N]}}const v=t.makeTensorInfo(d.shape,f,m);if(u!=null){const b=hu(u),C=mn({inputs:{x:v},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(d),C}return v}const CB={kernelName:Xd,backendName:"cpu",kernelFunc:SB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:a,reverse:l}=s;$e(r,"cumsum");const u=wt([o],r.shape.length);let d=r;u!=null&&(d=mn({inputs:{x:r},backend:t,attrs:{perm:u}}));const p=bt(1,r.shape.length)[0];if(p!==d.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${p}`);const f=fn(d.dtype,"int32"),m=Mt(oe(d.shape),f),g=t.data.get(d.dataId).values,x=d.shape[d.shape.length-1],w=l?(b,C)=>b+x-C-1:(b,C)=>b+C;for(let b=0;b<g.length;b+=x)for(let C=0;C<x;C++){const I=w(b,C);if(C===0)m[I]=a?0:g[I];else{const N=w(b,C-1);m[I]=a?g[N]+m[N]:g[I]+m[N]}}const v=t.makeTensorInfo(d.shape,f,m);if(u!=null){const b=hu(u),C=mn({inputs:{x:v},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(d),C}return v}const NB={kernelName:Yd,backendName:"cpu",kernelFunc:kB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:a,binaryOutput:l}=s;if(r.shape.length===1){const u=t.data.get(r.dataId).values,d=t.data.get(o.dataId).values,p=z0(u,d,o.dtype,o.shape,a);return t.makeTensorInfo([a],o.dtype,p)}else if(r.shape.length===2){const u=t.bufferSync(r),d=t.bufferSync(o),p=ck(u,d,a,l);return t.makeTensorInfo(p.shape,o.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const TB={kernelName:Zd,backendName:"cpu",kernelFunc:IB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:o,dataFormat:a}=s;O(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const l=r.shape[0],u=r.shape[1],d=r.shape[2],p=r.shape[3],f=u*o,m=d*o,g=p/(o*o),x=t.data.get(r.dataId).values,w=new Float32Array(l*f*m*g);let v=0;for(let b=0;b<l;++b)for(let C=0;C<f;++C){const I=Math.floor(C/o),N=C%o;for(let R=0;R<m;++R){const D=Math.floor(R/o),F=R%o,V=(N*o+F)*g;for(let P=0;P<g;++P){const T=P+V+p*(D+d*(I+u*b));w[v++]=x[T]}}}return t.makeTensorInfo([l,f,m,g],r.dtype,w)}const RB={kernelName:Jd,backendName:"cpu",kernelFunc:EB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:l,dilations:u,dimRoundingMode:d}=s;$e([r,o],"depthwiseConv2DNative");const p=Ie(r.shape),f=Ie(o.shape);let m=u;m==null&&(m=[1,1]),O(Yt(a,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${m}'`);const g=At(r.shape,o.shape,a,m,l,d,!0),{filterHeight:x,filterWidth:w,dilationHeight:v,dilationWidth:b,padInfo:C}=g,I=C.left,N=C.top,R=g.outChannels/g.inChannels,D=new kt(g.outShape,r.dtype),F=t.data.get(r.dataId).values,V=t.data.get(o.dataId).values,P=D.values;for(let A=0;A<g.batchSize;++A){const T=A*p[0],W=A*D.strides[0];for(let j=0;j<g.outHeight;++j){const Y=W+j*D.strides[1],Q=j*g.strideHeight-N;for(let Z=0;Z<x;++Z){const ne=Q+Z*v;if(ne<0||ne>=g.inHeight)continue;const U=Z*f[0],K=T+ne*p[1];for(let X=0;X<g.outWidth;++X){const L=Y+X*D.strides[2],H=X*g.strideWidth-I;for(let re=0;re<w;++re){const ae=H+re*b;if(ae<0||ae>=g.inWidth)continue;const ie=U+re*f[1],ue=K+ae*g.inChannels;let he=L,me=ie;for(let ye=0;ye<g.inChannels;++ye){const Te=F[ue+ye];for(let De=0;De<R;++De)P[he+De]+=Te*V[me+De];he+=R,me+=R}}}}}}return t.makeTensorInfo(D.shape,D.dtype,D.values)}const _B={kernelName:ep,backendName:"cpu",kernelFunc:cN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,dilations:l,pad:u,dimRoundingMode:d,filterShape:p}=s;$e([r,o],"depthwiseConv2dNativeBackpropFilter");const f=At(r.shape,p,a,l,u,d,!0),{strideHeight:m,strideWidth:g,filterHeight:x,filterWidth:w}=f,v=new kt(f.filterShape,"float32"),b=f.padInfo.left,C=f.padInfo.top,I=f.outChannels/f.inChannels,N=t.data.get(r.dataId).values,R=new kt(r.shape,r.dtype,N),D=t.data.get(o.dataId).values,F=new kt(o.shape,o.dtype,D);for(let V=0;V<x;++V){const P=Math.max(0,Math.ceil((C-V)/m)),A=Math.min(f.outHeight,(f.inHeight+C-V)/m);for(let T=0;T<w;++T){const W=Math.max(0,Math.ceil((b-T)/g)),j=Math.min(f.outWidth,(f.inWidth+b-T)/g);for(let Y=0;Y<f.outChannels;++Y){const Q=Math.trunc(Y/I),Z=Y%I;let ne=0;for(let U=0;U<f.batchSize;++U)for(let K=P;K<A;++K){const X=V+K*m-C;for(let L=W;L<j;++L){const H=T+L*g-b;ne+=R.get(U,X,H,Q)*F.get(U,K,L,Y)}}v.set(ne,V,T,Q,Z)}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const DB={kernelName:tp,backendName:"cpu",kernelFunc:OB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AB(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{strides:a,dilations:l,pad:u,dimRoundingMode:d,inputShape:p}=s;$e([r,o],"depthwiseConv2DNativeBackpropInput");const f=Ie(r.shape),m=Ie(o.shape),g=At(p,o.shape,a,l,u,d,!0),x=new kt(g.inShape,"float32"),w=x.values,[v,b,C]=x.strides,I=t.data.get(r.dataId).values,[N,R,D]=f,F=t.data.get(o.dataId).values,[V,P,A]=m,{batchSize:T,filterHeight:W,filterWidth:j,inChannels:Y,inHeight:Q,inWidth:Z,outChannels:ne,outHeight:U,outWidth:K,strideHeight:X,strideWidth:L}=g,H=W-1-g.padInfo.top,re=j-1-g.padInfo.left,ae=ne/Y;for(let ie=0;ie<T;++ie)for(let ue=0;ue<Y;++ue)for(let he=0;he<Q;++he){const me=he-H,ye=Math.max(0,Math.ceil(me/X)),Te=Math.min(U,(W+me)/X);for(let De=0;De<Z;++De){const ze=De-re,Ge=Math.max(0,Math.ceil(ze/L)),nt=Math.min(K,(j+ze)/L);let Ke=0;for(let He=ye;He<Te;++He){const Je=He*X-me;for(let et=Ge;et<nt;++et){const On=et*L-ze,dt=N*ie+R*He+D*et,cn=V*(W-1-Je)+P*(j-1-On)+A*ue;for(let jt=0;jt<ae;++jt){const ws=ue*ae+jt,gn=I[dt+ws],Wn=F[cn+jt];Ke+=gn*Wn}}}w[v*ie+b*he+C*De+ue]=Ke}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const FB={kernelName:np,backendName:"cpu",kernelFunc:AB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PB(n){const{inputs:e,backend:t}=n,{x:s}=e,r=oe(s.shape),o=t.data.get(s.dataId).values,a=Ae([r,r],s.dtype),l=a.values;for(let d=0;d<o.length;d++)l[d*r+d]=o[d];const u=[...s.shape,...s.shape];return t.makeTensorInfo(u,a.dtype,a.values)}const LB={kernelName:sp,backendName:"cpu",kernelFunc:PB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VB={kernelName:rp,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:o,pad:a,dilations:l}=t,u=e,d=u.data.get(s.dataId).values,p=s.shape.length,f=u.data.get(r.dataId).values,m=r.shape.length,{batchSize:g,inHeight:x,inWidth:w,inChannels:v,outHeight:b,outWidth:C,padInfo:I,strideHeight:N,strideWidth:R,filterHeight:D,filterWidth:F,dilationHeight:V,dilationWidth:P,outShape:A}=du(s.shape,r.shape,o,a,"NHWC",l),T=oe(A),W=A.length,j=xt(s.dtype,T);for(let Q=0;Q<g;++Q)for(let Z=0;Z<b;++Z){const ne=Z*N-I.top;for(let U=0;U<C;++U){const K=U*R-I.left;for(let X=0;X<v;++X){let L=Number.MIN_SAFE_INTEGER;for(let re=0;re<D;++re){const ae=ne+re*V;if(ae>=0&&ae<x)for(let ie=0;ie<F;++ie){const ue=K+ie*P;if(ue>=0&&ue<w){const he=ms([Q,ae,ue,X],p,Ie(s.shape)),me=ms([re,ie,X],m,Ie(r.shape)),ye=d[he]+f[me];ye>L&&(L=ye)}}}const H=ms([Q,Z,U,X],W,Ie(A));j[H]=L}}}return{dataId:u.write(Hr(j,s.dtype),A,s.dtype),shape:A,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BB={kernelName:lg,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:o}=n,{strides:a,pad:l,dilations:u}=t,d=e,p=zn(s.shape,d.data.get(s.dataId).values),f=zn(r.shape,d.data.get(r.dataId).values),{batchSize:m,inHeight:g,inWidth:x,inChannels:w,outHeight:v,outWidth:b,padInfo:C,strideHeight:I,strideWidth:N,filterHeight:R,filterWidth:D,dilationHeight:F,dilationWidth:V,outShape:P}=du(s.shape,r.shape,a,l,"NHWC",u);O(o.rank===P.length,()=>`Error in ${lg}, dy must have the same rank as output ${P.length}, but got ${o.rank}`);const A=zn(P,d.data.get(o.dataId).values),T=Kg(r.shape,r.dtype);for(let j=0;j<m;++j)for(let Y=0;Y<v;++Y){const Q=Y*I-C.top;for(let Z=0;Z<b;++Z){const ne=Z*N-C.left;for(let U=0;U<w;++U){let K=Number.MIN_SAFE_INTEGER,X=0,L=0;for(let H=0;H<R;++H){const re=Q+H*F;if(re>=0&&re<g)for(let ae=0;ae<D;++ae){const ie=ne+ae*V;if(ie>=0&&ie<x){const ue=p[j][re][ie][U]+f[H][ae][U];ue>K&&(K=ue,X=H,L=ae)}}}T[X][L][U]+=A[j][Y][Z][U]}}}return{dataId:d.write(Hr(T,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MB={kernelName:ig,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:o}=n,{strides:a,pad:l,dilations:u}=t,d=e,p=zn(s.shape,d.data.get(s.dataId).values),f=zn(r.shape,d.data.get(r.dataId).values),{batchSize:m,inHeight:g,inWidth:x,inChannels:w,outHeight:v,outWidth:b,padInfo:C,strideHeight:I,strideWidth:N,filterHeight:R,filterWidth:D,dilationHeight:F,dilationWidth:V,outShape:P}=du(s.shape,r.shape,a,l,"NHWC",u);O(o.rank===P.length,()=>`Error in ${ig}, dy must have the same rank as output ${P.length}, but got ${o.rank}`);const A=zn(P,d.data.get(o.dataId).values),T=Kg(s.shape,s.dtype);for(let j=0;j<m;++j)for(let Y=0;Y<v;++Y){const Q=Y*I-C.top;for(let Z=0;Z<b;++Z){const ne=Z*N-C.left;for(let U=0;U<w;++U){let K=Number.MIN_SAFE_INTEGER,X=Q<0?0:Q,L=ne<0?0:ne;for(let H=0;H<R;++H){const re=Q+H*F;if(re>=0&&re<g)for(let ae=0;ae<D;++ae){const ie=ne+ae*V;if(ie>=0&&ie<x){const ue=p[j][re][ie][U]+f[H][ae][U];ue>K&&(K=ue,X=re,L=ie)}}}T[j][X][L][U]+=A[j][Y][Z][U]}}}return{dataId:d.write(Hr(T,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zB(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:o,options:a}=s,{contextOptions:l,imageOptions:u}=a||{},d=(u==null?void 0:u.alpha)||1,p=(l==null?void 0:l.contextType)||"2d";if(p!=="2d")throw new Error(`Context type ${l.contextType} is not supported by the CPU backend.`);const f=o.getContext(p,(l==null?void 0:l.contextAttributes)||{});if(f==null)throw new Error(`Could not get the context with ${p} type.`);const[m,g]=r.shape.slice(0,2),x=r.shape.length===2?1:r.shape[2],w=t.data.get(r.dataId).values,v=r.dtype==="float32"?255:1,b=new Uint8ClampedArray(g*m*4);for(let I=0;I<m*g;++I){const N=[0,0,0,255*d];for(let D=0;D<x;D++){const F=w[I*x+D];if(r.dtype==="float32"){if(F<0||F>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${F}.`)}else if(r.dtype==="int32"&&(F<0||F>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${F}.`);x===1?(N[0]=F*v,N[1]=F*v,N[2]=F*v):N[D]=F*v}const R=I*4;b[R+0]=Math.round(N[0]),b[R+1]=Math.round(N[1]),b[R+2]=Math.round(N[2]),b[R+3]=Math.round(N[3])}o.width=g,o.height=m;const C=new ImageData(b,g,m);return f.putImageData(C,0,0),r}const WB={kernelName:op,backendName:"cpu",kernelFunc:zB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $u(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s;$e(r,"sum");let l;r.dtype==="bool"?l=Gr({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):l=Ps({inputs:{x:r},backend:t});const u=l.shape.length,d=Me(o,l.shape),p=wt(d,u);let f=d,m=l;p!=null&&(m=mn({inputs:{x:l},backend:t,attrs:{perm:p}}),f=bt(f.length,u)),Ut("sum",f,m.shape.length);const[g,x]=Wt(m.shape,f),w=fn(m.dtype,"int32");let v=yd(t,g,w);const b=oe(x),C=t.data.get(v.dataId).values,I=t.data.get(m.dataId).values;for(let N=0;N<C.length;++N){const R=N*b;let D=0;for(let F=0;F<b;++F)D+=I[R+F];C[N]=D}if(a){const N=It(v.shape,d),R=v;v=it({inputs:{x:v},backend:t,attrs:{shape:N}}),t.disposeIntermediateTensorInfo(R)}return t.disposeIntermediateTensorInfo(l),p!=null&&t.disposeIntermediateTensorInfo(m),v}const UB={kernelName:Qp,backendName:"cpu",kernelFunc:$u};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GB(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,o=e,{allDims:a,summedDims:l,idDims:u}=R0(r,o.length);O0(a.length,u,o);const{path:d,steps:p}=D0(l,u),f=p.length;let m=null,g=a.length;const x=[];for(let w=0;w<f;++w){for(const v of p[w]){const{permutationIndices:b,expandDims:C}=_0(g,u[v]);let I;A0(b)?I=o[v]:(I=mn({inputs:{x:o[v]},backend:t,attrs:{perm:b}}),x.push(I));const N=I.shape.slice();for(let R=0;R<C.length;++R)N.splice(C[R],0,1);Qe(I.shape,N)||(I=it({inputs:{x:I},backend:t,attrs:{shape:N}}),x.push(I)),m===null?m=I:(m=Uf({inputs:{a:I,b:m},backend:t}),x.push(m))}w<f-1&&(d[w]>=0&&(m=$u({inputs:{x:m},backend:t,attrs:{axis:d[w]-(a.length-g),keepDims:!1}}),x.push(m)),g--)}for(const w of x)w!==m&&t.disposeIntermediateTensorInfo(w);return m}const HB={kernelName:ap,backendName:"cpu",kernelFunc:GB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jB(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;$e([s,r],"eluGrad");const o=new Float32Array(oe(r.shape)),a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values;for(let u=0;u<a.length;++u){const d=a[u];d>=0?o[u]=l[u]:o[u]=l[u]*(d+1)}return t.makeTensorInfo(r.shape,"float32",o)}const qB={kernelName:ey,backendName:"cpu",kernelFunc:jB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KB=S0,XB=C0,YB=k0,QB=N0,ZB=I0,JB=T0,eM=Xe(vl,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+KB*t);return e*(1-((((JB*s+ZB)*s+QB)*s+YB)*s+XB)*s*Math.exp(-t*t))}),tM={kernelName:vl,backendName:"cpu",kernelFunc:eM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wd(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:o}=s,a=r.shape.length,l=r.shape.slice();let u=o;return o<0&&(O(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+o+1),l.splice(u,0,1),it({inputs:{x:r},backend:t,attrs:{shape:l}})}const nM={kernelName:ip,backendName:"cpu",kernelFunc:wd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sM=$t((n,e)=>n/e),q0=Tt(yl,sM),Lg={kernelName:yl,backendName:"cpu",kernelFunc:q0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dN(n,e,t){const s=n.shape,r=s[0],o=s[1],a=t.data.get(n.dataId),l=a.complexTensorInfos.real,u=a.complexTensorInfos.imag,d=[r,o],p=oe(d),f=Dt("float32",p),m=Dt("float32",p);for(let v=0;v<r;v++){const b=Fo({inputs:{x:l},backend:t,attrs:{begin:[v,0],size:[1,o]}}),C=Fo({inputs:{x:u},backend:t,attrs:{begin:[v,0],size:[1,o]}}),I=Tn({inputs:{real:b,imag:C},backend:t}),{real:N,imag:R}=rM(I,e,t),D=sr(N,R);for(let F=0;F<o;F++){const V=E0(D,F);f[v*o+F]=V.real,m[v*o+F]=V.imag}t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(C),t.disposeIntermediateTensorInfo(I)}const g=t.makeTensorInfo(d,"float32",f),x=t.makeTensorInfo(d,"float32",m),w=Tn({inputs:{real:g,imag:x},backend:t});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),w}function rM(n,e,t){const s=oe(n.shape),r=t.data.get(n.dataId),o=t.data.get(r.complexTensorInfos.real.dataId).values,a=t.data.get(r.complexTensorInfos.imag.dataId).values;if(oM(s)){const l=Vg(o,a,s,e,t),u=[n.shape[0],n.shape[1]];if(e){const d=t.makeTensorInfo(u,"float32",l.real),p=t.makeTensorInfo(u,"float32",l.imag),f=t.makeTensorInfo([],"float32",ar(s,"float32")),m=Ps({inputs:{x:f},backend:t}),g=Lg.kernelFunc({inputs:{a:d,b:f},backend:t}),x=Lg.kernelFunc({inputs:{a:p,b:m},backend:t}),w=t.data.get(g.dataId).values,v=t.data.get(x.dataId).values;return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),{real:w,imag:v}}return l}else{const l=sr(o,a),u=aM(l,s,e);return LC(u)}}function oM(n){return(n&n-1)===0}function Vg(n,e,t,s,r){if(t===1)return{real:n,imag:e};const o=sr(n,e),a=t/2,l=VC(o),u=l.real,d=l.imag,p=[u.length],f=r.makeTensorInfo(p,"float32",u),m=r.makeTensorInfo(p,"float32",d),g=Tn({inputs:{real:f,imag:m},backend:r}),x=BC(o),w=x.real,v=x.imag,b=[w.length],C=r.makeTensorInfo(b,"float32",w),I=r.makeTensorInfo(b,"float32",v),N=Tn({inputs:{real:C,imag:I},backend:r}),R=Vg(u,d,a,s,r),D=R.real,F=R.imag,V=[D.length],P=r.makeTensorInfo(V,"float32",D),A=r.makeTensorInfo(V,"float32",F),T=Tn({inputs:{real:P,imag:A},backend:r}),W=Vg(w,v,a,s,r),j=W.real,Y=W.imag,Q=[j.length],Z=r.makeTensorInfo(Q,"float32",j),ne=r.makeTensorInfo(Q,"float32",Y),U=Tn({inputs:{real:Z,imag:ne},backend:r}),K=zC(t,s),X=[K.real.length],L=r.makeTensorInfo(X,"float32",K.real),H=r.makeTensorInfo(X,"float32",K.imag),re=Tn({inputs:{real:L,imag:H},backend:r}),ae=Uf({inputs:{a:re,b:U},backend:r}),ie=Ra({inputs:{a:T,b:ae},backend:r}),ue=H0({inputs:{a:T,b:ae},backend:r}),he=Ao({inputs:{input:ie},backend:r}),me=Ao({inputs:{input:ue},backend:r}),ye=_a({inputs:{input:ie},backend:r}),Te=_a({inputs:{input:ue},backend:r}),De=Oa({inputs:[he,me],backend:r,attrs:{axis:0}}),ze=Oa({inputs:[ye,Te],backend:r,attrs:{axis:0}}),Ge=r.data.get(De.dataId).values,nt=r.data.get(ze.dataId).values;return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(Z),r.disposeIntermediateTensorInfo(ne),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(re),r.disposeIntermediateTensorInfo(ae),r.disposeIntermediateTensorInfo(ie),r.disposeIntermediateTensorInfo(ue),r.disposeIntermediateTensorInfo(he),r.disposeIntermediateTensorInfo(ye),r.disposeIntermediateTensorInfo(me),r.disposeIntermediateTensorInfo(Te),r.disposeIntermediateTensorInfo(De),r.disposeIntermediateTensorInfo(ze),{real:Ge,imag:nt}}function aM(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let o=0,a=0;for(let l=0;l<e;l++){const u=WC(r*l,e,t),d=E0(n,l);o+=d.real*u.real-d.imag*u.imag,a+=d.real*u.imag+d.imag*u.real}t&&(o/=e,a/=e),MC(s,o,a,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iM(n){const{inputs:e,backend:t}=n,{input:s}=e,r=oe(s.shape),o=s.shape[s.shape.length-1],a=r/o,l=it({inputs:{x:s},backend:t,attrs:{shape:[a,o]}}),u=dN(l,!1,t),d=it({inputs:{x:u},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(u),d}const lM={kernelName:lp,backendName:"cpu",kernelFunc:iM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K0(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:o}=t,a=o||Vo(r),l=xt(a,oe(s));return cM(l,r,a),e.makeTensorInfo(s,a,l)}const uM={kernelName:up,backendName:"cpu",kernelFunc:K0};function cM(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dM={kernelName:cp,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,o=Dt(s.dtype,oe(s.shape)),[a,l,u,d]=s.shape,p=r.data.get(s.dataId).values;for(let m=0;m<a;m++){const g=m*u*l*d;for(let x=0;x<l;x++){const w=x*(u*d);for(let v=0;v<u;v++){const b=v*d;for(let C=0;C<d;C++){const I=Math.round(u-v-1),N=g+w+b+C;let R=p[N];if(I>=0&&I<u){const D=I*d,F=g+w+D+C;R=p[F]}o[N]=R}}}}return{dataId:r.write(o,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pM(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:l}=e,{strides:u,pad:d,dataFormat:p,dilations:f,dimRoundingMode:m,activation:g,leakyreluAlpha:x}=s;let w=uN({inputs:{x:r,filter:o},backend:t,attrs:{strides:u,pad:d,dataFormat:p,dilations:f,dimRoundingMode:m}});if(a){const v=w;if(p==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){const b=it({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});w=Ra({inputs:{a:w,b},backend:t}),t.disposeIntermediateTensorInfo(b)}else w=Ra({inputs:{a:w,b:a},backend:t});t.disposeIntermediateTensorInfo(v)}if(g){const v=w;if(p==="NCHW"&&g==="prelu"&&l.shape.length===1&&l.shape[0]!==1){const b=it({inputs:{x:l},backend:t,attrs:{shape:[l.shape[0],1,1]}});w=vd(t,w,g,b,x),t.disposeIntermediateTensorInfo(b)}else w=vd(t,w,g,l,x);t.disposeIntermediateTensorInfo(v)}return w}const fM={kernelName:Mi,backendName:"cpu",kernelFunc:pM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hM(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:l}=e,{strides:u,pad:d,dataFormat:p,dilations:f,dimRoundingMode:m,activation:g,leakyreluAlpha:x}=s;let w=cN({inputs:{x:r,filter:o},backend:t,attrs:{strides:u,pad:d,dataFormat:p,dilations:f,dimRoundingMode:m}});if(a){const v=w;w=Ra({inputs:{a:w,b:a},backend:t}),t.disposeIntermediateTensorInfo(v)}if(g){const v=w;w=vd(t,w,g,l,x),t.disposeIntermediateTensorInfo(v)}return w}const mM={kernelName:zi,backendName:"cpu",kernelFunc:hM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gM(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,o=oe(s.shape),a=r.shape,l=a[a.length-1],[u,d,p,f]=Mf(s,r);if(d===0)return t.makeTensorInfo(u,s.dtype,[]);const m=t.data.get(r.dataId).values,g=t.bufferSync(s),x=bk(m,g,s.dtype,d,l,p,f,s.shape,o);return t.makeTensorInfo(u,s.dtype,x.values)}const yM={kernelName:fp,backendName:"cpu",kernelFunc:gM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xM(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:o}=e,{axis:a,batchDims:l}=s;$e([r,o],"gatherV2");const u=Me(a,r.shape)[0],d=t.data.get(o.dataId).values,p=r.shape[u];for(let N=0;N<d.length;++N){const R=d[N];O(R<=p-1&&R>=0,()=>`GatherV2: the index value ${R} is not in [0, ${p-1}]`)}let f=l;l==null&&(f=0);const m=oe(o.shape),g=P0(r,o,u,f),x=it({inputs:{x:r},backend:t,attrs:{shape:[g.batchSize,g.outerSize,g.dimSize,g.sliceSize]}}),w=it({inputs:{x:o},backend:t,attrs:{shape:[g.batchSize,m/g.batchSize]}}),v=[g.batchSize,g.outerSize,m/g.batchSize,g.sliceSize],b=t.bufferSync(w),C=t.bufferSync(x),I=$k(C,b,v);return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),t.makeTensorInfo(g.outputShape,I.dtype,I.values)}const vM={kernelName:pp,backendName:"cpu",kernelFunc:xM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wM(n){const{inputs:e,backend:t}=n,{input:s}=e,r=oe(s.shape),o=s.shape[s.shape.length-1],a=r/o,l=it({inputs:{x:s},backend:t,attrs:{shape:[a,o]}}),u=dN(l,!0,t),d=it({inputs:{x:u},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(u),d}const bM={kernelName:hp,backendName:"cpu",kernelFunc:wM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $M=Xe(Tl,n=>Number.isFinite(n)?1:0,"bool"),SM={kernelName:Tl,backendName:"cpu",kernelFunc:$M};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CM=Xe(El,n=>Math.abs(n)===1/0?1:0,"bool"),kM={kernelName:El,backendName:"cpu",kernelFunc:CM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NM=Xe(Rl,n=>Number.isNaN(n)?1:0,"bool"),IM={kernelName:Rl,backendName:"cpu",kernelFunc:NM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TM(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:o}=t,a=Ik(s,r,o);return e.makeTensorInfo([a.length],"float32",a)}const EM={kernelName:yp,backendName:"cpu",kernelFunc:TM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RM=Xe(Al,n=>Math.log1p(n)),_M={kernelName:Al,backendName:"cpu",kernelFunc:RM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OM=$t((n,e)=>n&&e),DM=Tt(Fl,OM,null,"bool"),AM={kernelName:Fl,backendName:"cpu",kernelFunc:DM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FM=Xe(Pl,n=>n?0:1,"bool"),PM={kernelName:Pl,backendName:"cpu",kernelFunc:FM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LM=$t((n,e)=>n||e),VM=Tt(Ll,LM,null,"bool"),BM={kernelName:Ll,backendName:"cpu",kernelFunc:VM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MM(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:o,bias:a,alpha:l,beta:u}=s;$e(r,"LRN");const d=r.shape[3],p=d-1,f=t.data.get(r.dataId).values,m=oe(r.shape),g=new Float32Array(m);function x(w){const v=w%d;let b=w-v+Math.max(0,v-o);const C=w-v+Math.min(v+o,p);let I=0;for(;b<=C;b++){const N=f[b];I+=N*N}return I}for(let w=0;w<m;w++){const v=x(w),b=f[w]*Math.pow(a+l*v,-u);g[w]=b}return t.makeTensorInfo(r.shape,r.dtype,g)}const zM={kernelName:xp,backendName:"cpu",kernelFunc:MM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WM(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:o,dy:a}=e,{depthRadius:l,bias:u,alpha:d,beta:p}=s;$e(a,"LRNGrad");const f=oe(a.shape),m=a.shape[3],g=t.data.get(a.dataId).values,x=t.data.get(r.dataId).values,w=t.data.get(o.dataId).values,v=new Float32Array(f),b=f;for(let C=0;C<b;C++){const I=C%m,N=C-I+Math.max(0,I-l),R=C-I+Math.min(m,I+l+1);let D=0;for(let F=N;F<R;F++)D+=Math.pow(x[F],2);D=d*D+u;for(let F=N;F<R;F++){let V=-2*d*p*x[F]*w[C]/D;C===F&&(V+=Math.pow(D,-p)),V*=g[C],v[F]+=V}}return t.makeTensorInfo(a.shape,r.dtype,v)}const UM={kernelName:ty,backendName:"cpu",kernelFunc:WM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:o,keepDims:a}=s,l=t;let u=r.shape;const d=u.length,p=Me(o,u);let f=p;const m=wt(f,d);let g=l.data.get(r.dataId).values;if(m!=null){const N=new Array(d);for(let R=0;R<N.length;R++)N[R]=u[m[R]];g=U0(g,u,r.dtype,m,N),f=bt(f.length,d),u=N}$e(r,"max"),Ut("max",f,d);const[x,w]=Wt(u,f),v=oe(w),b=Ek(g,v,x,r.dtype),C=l.write(b,x,r.dtype);let I=x;return a&&(I=It(x,p)),{dataId:C,shape:I,dtype:r.dtype}}const GM={kernelName:vp,backendName:"cpu",kernelFunc:pN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HM(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;$e(r,"maxPool");const{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=s,d=1;O(Yt(a,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const p=es(r.shape,o,a,d,l,u);let f;if(p.filterWidth===1&&p.filterHeight===1&&Qe(p.inShape,p.outShape))f=Ps({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,g=Ie(r.shape),x=j0(m,r.shape,r.dtype,g,p,"max");f=t.makeTensorInfo(p.outShape,r.dtype,x.values)}return f}const jM={kernelName:wp,backendName:"cpu",kernelFunc:HM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qM(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u,dataFormat:d}=s;$e(r,"maxPool3d");const p=ir(r.shape,o,a,1,l,u,d),f=t.data.get(r.dataId).values,m=lN(f,r.shape,r.dtype,Ie(r.shape),p,"max");return t.makeTensorInfo(m.shape,"float32",m.values)}const KM={kernelName:bp,backendName:"cpu",kernelFunc:qM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XM(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,{filterSize:a,strides:l,pad:u,dimRoundingMode:d}=s;$e([r,o],"maxPool3DGrad");const p=ir(o.shape,a,l,1,u,d),f=t.bufferSync(o),m=LV(f,p),g=p.strideDepth,x=p.strideHeight,w=p.strideWidth,v=p.dilationDepth,b=p.dilationHeight,C=p.dilationWidth,I=p.effectiveFilterDepth,N=p.effectiveFilterHeight,R=p.effectiveFilterWidth,D=I-1-p.padInfo.front,F=R-1-p.padInfo.left,V=N-1-p.padInfo.top,P=Ae(o.shape,"float32"),A=t.bufferSync(r);for(let T=0;T<p.batchSize;++T)for(let W=0;W<p.inChannels;++W)for(let j=0;j<p.inDepth;++j)for(let Y=0;Y<p.inHeight;++Y)for(let Q=0;Q<p.inWidth;++Q){const Z=j-D,ne=Y-V,U=Q-F;let K=0;for(let X=0;X<I;X+=v){const L=(Z+X)/g;if(!(L<0||L>=p.outDepth||Math.floor(L)!==L))for(let H=0;H<N;H+=b){const re=(ne+H)/x;if(!(re<0||re>=p.outHeight||Math.floor(re)!==re))for(let ae=0;ae<R;ae+=C){const ie=(U+ae)/w;if(ie<0||ie>=p.outWidth||Math.floor(ie)!==ie)continue;const ue=I*N*R-1-m.get(T,L,re,ie,W),he=X*N*R+H*R+ae,me=ue===he?1:0;if(me===0)continue;const ye=A.get(T,L,re,ie,W);K+=ye*me}}}P.set(K,T,j,Y,Q,W)}return t.makeTensorInfo(P.shape,P.dtype,P.values)}const YM={kernelName:sy,backendName:"cpu",kernelFunc:XM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QM(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o,output:a}=e,l=o;$e([o,a],"maxPoolGrad");const{filterSize:u,strides:d,pad:p,dimRoundingMode:f}=s,m=es(l.shape,u,d,1,p,f),g=t.data.get(l.dataId).values,x=Ae(m.outShape,l.dtype,iN(g,l.shape,l.dtype,m).values),w=m.strideHeight,v=m.strideWidth,b=m.dilationHeight,C=m.dilationWidth,I=m.effectiveFilterHeight,N=m.effectiveFilterWidth,R=N-1-m.padInfo.left,D=I-1-m.padInfo.top,F=Ae(l.shape,"float32"),V=t.data.get(r.dataId).values,P=Ae(r.shape,"float32",V);for(let A=0;A<m.batchSize;++A)for(let T=0;T<m.inChannels;++T)for(let W=0;W<m.inHeight;++W)for(let j=0;j<m.inWidth;++j){const Y=W-D,Q=j-R;let Z=0;for(let ne=0;ne<I;ne+=b){const U=(Y+ne)/w;if(!(U<0||U>=m.outHeight||Math.floor(U)!==U))for(let K=0;K<N;K+=C){const X=(Q+K)/v;if(X<0||X>=m.outWidth||Math.floor(X)!==X)continue;const L=I*N-1-x.get(A,U,X,T),H=ne*N+K,re=L===H?1:0;if(re===0)continue;const ae=P.get(A,U,X,T);Z+=ae*re}}F.set(Z,A,W,j,T)}return t.makeTensorInfo(F.shape,F.dtype,F.values)}const ZM={kernelName:ny,backendName:"cpu",kernelFunc:QM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JM(n,e,t,s,r){const o=Ie(e),a=j0(n,e,t,o,r,"max"),l=iN(n,e,t,r,!0,s);return[a.values,l.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ez={kernelName:$p,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:o,pad:a,includeBatchInIndex:l}=e,u=t;$e(s,"MaxPoolWithArgmax");const d=u.data.get(s.dataId).values,p=es(s.shape,r,o,[1,1],a),[f,m]=JM(d,s.shape,s.dtype,l,p),g=u.write(f,p.outShape,s.dtype),x=u.write(m,p.outShape,s.dtype);return[{dataId:g,shape:p.outShape,dtype:s.dtype},{dataId:x,shape:p.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,l=Me(o,r.shape),d=Wt(r.shape,l)[1],p=oe(d),f=[],m=t.makeTensorInfo([],"float32",new Float32Array([p]));f.push(m);const g=Gr({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});f.push(g);const x=q0({inputs:{a:g,b:m},backend:t});f.push(x);const w=$u({inputs:{x},backend:t,attrs:{axis:o,keepDims:a}});return f.forEach(v=>t.disposeIntermediateTensorInfo(v)),w}const nz={kernelName:Sp,backendName:"cpu",kernelFunc:tz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s;$e(r,"min");const l=Me(o,r.shape);let u=l;const d=wt(u,r.shape.length);let p=r;d!=null&&(p=mn({inputs:{x:r},backend:t,attrs:{perm:d}}),u=bt(u.length,r.shape.length)),Ut("min",u,p.shape.length);const[f,m]=Wt(p.shape,u),g=oe(m),x=Mt(oe(f),p.dtype),w=t.data.get(p.dataId).values;for(let b=0;b<x.length;++b){const C=b*g;let I=w[C];for(let N=0;N<g;++N){const R=w[C+N];(Number.isNaN(R)||R<I)&&(I=R)}x[b]=I}d!=null&&t.disposeIntermediateTensorInfo(p);const v=t.makeTensorInfo(f,p.dtype,x);if(a){const b=It(f,l),C=it({inputs:{x:v},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(v),C}return v}const rz={kernelName:Cp,backendName:"cpu",kernelFunc:sz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,mode:a}=s;$e(r,"mirrorPad");const l=o.map((I,N)=>I[0]+r.shape[N]+I[1]),u=o.map(I=>I[0]),d=o.map((I,N)=>I[0]+r.shape[N]),p=a==="reflect"?0:1,f=t.data.get(r.dataId).values,m=r.shape.length,g=Ie(r.shape),x=oe(l),w=l.length,v=Ie(l),b=Dt(r.dtype,x);for(let I=0;I<x;I++){let N=Bo(I,w,v);for(let D=0;D<w;D++)N[D]<u[D]?N[D]=u[D]*2-N[D]-p:N[D]>=d[D]&&(N[D]=(d[D]-1)*2-N[D]+p);N=N.map((D,F)=>D-u[F]);const R=ms(N,m,g);b[I]=f[R]}return{dataId:t.write(b,l,r.dtype),shape:l,dtype:r.dtype}}const az={kernelName:kp,backendName:"cpu",kernelFunc:oz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iz=$t((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),lz=Tt(Ml,iz),uz={kernelName:Ml,backendName:"cpu",kernelFunc:lz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fN(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:o}=s,a=r.shape.length;let l=o;if(l===-1&&(l=a-1),l!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${l}`);const u=Me([l],r.shape),d=pN({inputs:{x:r},backend:t,attrs:{reductionIndices:u,keepDims:!1}}),p=It(d.shape,u),f=it({inputs:{x:d},backend:t,attrs:{shape:p}}),m=H0({inputs:{a:r,b:f},backend:t}),g=yk({inputs:{x:m},backend:t}),x=$u({inputs:{x:g},backend:t,attrs:{axis:u,keepDims:!1}}),w=it({inputs:{x},backend:t,attrs:{shape:p}}),v=q0({inputs:{a:g,b:w},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),v}const cz={kernelName:ef,backendName:"cpu",kernelFunc:fN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dz(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:o,seed:a,normalized:l}=s;$e(r,"multinomial");const u=l?r:fN({inputs:{logits:r},backend:t,attrs:{dim:-1}}),d=u.shape[0],p=u.shape[1],f=t.data.get(u.dataId).values,m=[d,o],g=Mt(oe(m),"int32");for(let x=0;x<d;++x){const w=x*p,v=new Float32Array(p-1);v[0]=f[w];for(let I=1;I<v.length;++I)v[I]=v[I-1]+f[w+I];const b=Cf.alea(a.toString()),C=x*o;for(let I=0;I<o;++I){const N=b();g[C+I]=v.length;for(let R=0;R<v.length;R++)if(N<v[R]){g[C+I]=R;break}}}return l||t.disposeIntermediateTensorInfo(u),t.makeTensorInfo(m,"int32",g)}const pz={kernelName:Np,backendName:"cpu",kernelFunc:dz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fz=Pf;function hz(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=s;$e(r,"NonMaxSuppression");const d=t.data.get(r.dataId).values,p=t.data.get(o.dataId).values,{selectedIndices:f}=fz(d,p,a,l,u);return t.makeTensorInfo([f.length],"int32",new Int32Array(f))}const mz={kernelName:Tp,backendName:"cpu",kernelFunc:hz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gz=Lf;function yz(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:l,scoreThreshold:u,padToMaxOutputSize:d}=s;$e(r,"NonMaxSuppressionPadded");const p=t.data.get(r.dataId).values,f=t.data.get(o.dataId).values,{selectedIndices:m,validOutputs:g}=gz(p,f,a,l,u,d);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([g]))]}const xz={kernelName:Ep,backendName:"cpu",kernelFunc:yz};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vz=Vf;function wz(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:l,scoreThreshold:u,softNmsSigma:d}=s;$e(r,"NonMaxSuppressionWithScore");const p=t.data.get(r.dataId).values,f=t.data.get(o.dataId).values,m=a,g=l,x=u,w=d,{selectedIndices:v,selectedScores:b}=vz(p,f,m,g,x,w);return[t.makeTensorInfo([v.length],"int32",new Int32Array(v)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const bz={kernelName:Rp,backendName:"cpu",kernelFunc:wz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $z(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:o,depth:a,onValue:l,offValue:u}=s;$e(r,"oneHot");const d=oe(r.shape),p=new Float32Array(d*a);p.fill(u);const f=t.data.get(r.dataId).values;for(let m=0;m<d;++m)f[m]>=0&&f[m]<a&&(p[m*a+f[m]]=l);return t.makeTensorInfo([...r.shape,a],o,p)}const Sz={kernelName:Op,backendName:"cpu",kernelFunc:$z};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bd(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Ao({inputs:{input:s},backend:t}),o=bd({inputs:{x:r},backend:t}),a=_a({inputs:{input:s},backend:t}),l=bd({inputs:{x:a},backend:t}),u=Tn({inputs:{real:o,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}else return K0({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const Cz={kernelName:gf,backendName:"cpu",kernelFunc:bd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hN(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Ao({inputs:{input:s},backend:t}),o=hN({inputs:{x:r},backend:t}),a=_a({inputs:{input:s},backend:t}),l=bd({inputs:{x:a},backend:t}),u=Tn({inputs:{real:o,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}else return K0({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const kz={kernelName:_p,backendName:"cpu",kernelFunc:hN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mN(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return wd({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const o=e[0].shape,a=e[0].dtype;e.forEach(p=>{zt(o,p.shape,"All tensors passed to stack must have matching shapes"),O(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],u=e.map(p=>{const f=wd({inputs:{input:p},backend:t,attrs:{dim:r}});return l.push(f),f}),d=Oa({inputs:u,backend:t,attrs:{axis:r}});return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const Nz={kernelName:Dp,backendName:"cpu",kernelFunc:mN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,constantValue:a}=s;$e(r,"pad");const l=o.map((C,I)=>C[0]+r.shape[I]+C[1]),u=o.map(C=>C[0]),d=t.data.get(r.dataId).values,p=oe(r.shape),f=r.shape.length,m=Ie(r.shape),g=oe(l),x=l.length,w=Ie(l),v=Dt(r.dtype,g);a!==0&&v.fill(a);for(let C=0;C<p;C++){const N=Bo(C,f,m).map((D,F)=>D+u[F]),R=ms(N,x,w);v[R]=d[C]}return{dataId:t.write(v,l,r.dtype),shape:l,dtype:r.dtype}}const gN={kernelName:Ap,backendName:"cpu",kernelFunc:Iz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tz=$t((n,e)=>Math.pow(n,e)),Ez=Tt(Ul,Tz),Rz={kernelName:Ul,backendName:"cpu",kernelFunc:Ez};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _z(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:o,indices:a}=e,l=r.map(v=>t.data.get(v.dataId).values),u=r.map(v=>v.shape),d=t.data.get(o.dataId).values,p=t.data.get(a.dataId).values,[f,m,g]=Fk(l,u,d,o.shape,o.dtype,p,a.shape),x=f.map(v=>t.makeTensorInfo([v.length],"int32",v)),w=t.makeTensorInfo(g,o.dtype,m);return x.concat([w])}const Oz={kernelName:Lp,backendName:"cpu",kernelFunc:_z};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dz(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:o}=e,a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,[d,p]=Pk(a,s.shape,s.dtype,l,r.shape,u,o.shape),f=t.makeTensorInfo([d.length],"int32",d),m=t.makeTensorInfo([p.length],s.dtype,p);return[f,m]}const Az={kernelName:Vp,backendName:"cpu",kernelFunc:Dz};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fz(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:o,defaultValue:a,rowPartitionTensors:l}=e,{rowPartitionTypes:u}=s,d=t.data.get(r.dataId).values,p=t.data.get(o.dataId).values,f=t.data.get(a.dataId).values,m=l.map(v=>t.data.get(v.dataId).values),g=l.map(v=>v.shape),[x,w]=Lk(d,r.shape,p,o.shape,o.dtype,f,a.shape,m,g,u);return t.makeTensorInfo(x,o.dtype,w)}const Pz={kernelName:Bp,backendName:"cpu",kernelFunc:Fz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lz(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:o,step:a}=t,l=Vk(s,r,a,o);return e.makeTensorInfo([l.length],o,l)}const Vz={kernelName:Mp,backendName:"cpu",kernelFunc:Lz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bz=Xe(Gl,n=>1/n),Mz={kernelName:Gl,backendName:"cpu",kernelFunc:Bz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zz(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:l}=s;$e(r,"resizeBilinear");const u=Ie(r.shape),[d,p]=l,[f,m,g,x]=r.shape,w=t.data.get(r.dataId).values,v=new Float32Array(oe([f,d,p,x])),b=[o&&d>1?m-1:m,o&&p>1?g-1:g],C=[o&&d>1?d-1:d,o&&p>1?p-1:p];let I=0;const N=b[0]/C[0],R=b[1]/C[1];for(let D=0;D<f;D++)for(let F=0;F<d;F++){let V;a?V=N*(F+.5)-.5:V=N*F;const P=Math.max(0,Math.floor(V)),A=V-P,T=Math.min(m-1,Math.ceil(V)),W=D*u[0]+P*u[1],j=D*u[0]+T*u[1];for(let Y=0;Y<p;Y++){let Q;a?Q=R*(Y+.5)-.5:Q=R*Y;const Z=Math.max(0,Math.floor(Q)),ne=Q-Z,U=Math.min(g-1,Math.ceil(Q)),K=W+Z*u[2],X=j+Z*u[2],L=W+U*u[2],H=j+U*u[2];for(let re=0;re<x;re++){const ae=w[K+re],ie=w[X+re],ue=w[L+re],he=w[H+re],me=ae+(ue-ae)*ne,ye=ie+(he-ie)*ne,Te=me+(ye-me)*A;v[I++]=Te}}}return t.makeTensorInfo([f,d,p,x],"float32",v)}const Wz={kernelName:Gp,backendName:"cpu",kernelFunc:zz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uz(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:a}=s;$e([o,r],"resizeBilinearGrad");const l=Ie(r.shape),[u,d,p,f]=r.shape,[,m,g]=o.shape,x=new Float32Array(u*d*p*f),w=[a&&m>1?d-1:d,a&&g>1?p-1:p],v=[a&&m>1?m-1:m,a&&g>1?g-1:g],b=w[0]/v[0],C=w[1]/v[1],I=t.data.get(o.dataId).values;let N=0;for(let R=0;R<u;R++){const D=R*l[0];for(let F=0;F<m;F++){const V=F*b,P=Math.floor(V),A=Math.min(Math.ceil(V),d-1),T=D+P*l[1],W=D+A*l[1],j=V-P,Y=1-j;for(let Q=0;Q<g;Q++){const Z=Q*C,ne=Math.floor(Z),U=Math.min(Math.ceil(Z),p-1),K=Z-ne,X=1-K,L=T+ne*l[2],H=T+U*l[2],re=W+ne*l[2],ae=W+U*l[2],ie=Y*X,ue=Y*K,he=j*X,me=j*K;for(let ye=0;ye<f;ye++){const Te=I[N++];x[L+ye]+=Te*ie,x[H+ye]+=Te*ue,x[re+ye]+=Te*he,x[ae+ye]+=Te*me}}}}return t.makeTensorInfo([u,p,d,f],"float32",x)}const Gz={kernelName:oy,backendName:"cpu",kernelFunc:Uz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hz(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:l}=s;$e(r,"resizeNearestNeighbor");const u=Ie(r.shape),[d,p]=l,[f,m,g,x]=r.shape,w=t.data.get(r.dataId).values,v=new Float32Array(f*d*p*x),b=[o&&d>1?m-1:m,o&&p>1?g-1:g],C=[o&&d>1?d-1:d,o&&p>1?p-1:p],I=b[0]/C[0],N=b[1]/C[1];let R=0;for(let D=0;D<f;D++){const F=D*u[0];for(let V=0;V<d;V++){const P=a?I*(V+.5):I*V;let A=Math.min(m-1,o?Math.round(P):Math.floor(P));a&&(A=Math.max(0,A));const T=F+A*u[1];for(let W=0;W<p;W++){const j=a?N*(W+.5):N*W;let Y=Math.min(g-1,o?Math.round(j):Math.floor(j));a&&(Y=Math.max(0,Y));const Q=T+Y*u[2];for(let Z=0;Z<x;Z++){const ne=w[Q+Z];v[R++]=ne}}}}return t.makeTensorInfo([f,d,p,x],r.dtype,v)}const jz={kernelName:Up,backendName:"cpu",kernelFunc:Hz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qz(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:a}=s;$e([o,r],"resizeNearestNeighborGrad");const l=Ie(r.shape),u=Ie(o.shape),[d,p,f,m]=r.shape,[,g,x]=o.shape,w=new Float32Array(d*p*f*m),v=t.data.get(o.dataId).values,b=[a&&g>1?p-1:p,a&&x>1?f-1:f],C=[a&&g>1?g-1:g,a&&x>1?x-1:x],I=b[0]/C[0],N=b[1]/C[1],R=1/I,D=1/N,F=Math.ceil(R)*2+2,V=Math.ceil(D)*2+2;for(let P=0;P<d;P++){const A=P*l[0];for(let T=0;T<p;T++){const W=A+T*l[1],j=Math.floor(T*R),Y=Math.floor(j-F/2);for(let Q=0;Q<f;Q++){const Z=W+Q*l[2],ne=Math.floor(Q*D),U=Math.floor(ne-V/2);for(let K=0;K<m;K++){let X=0;for(let L=0;L<F;L++){const H=L+Y;if(H<0||H>=g)continue;const re=A+H*u[1],ae=H*I,ie=Math.min(p-1,a?Math.round(ae):Math.floor(ae));if(T===ie)for(let ue=0;ue<V;ue++){const he=ue+U;if(he<0||he>=x)continue;const me=re+he*u[2],ye=he*N,Te=Math.min(f-1,a?Math.round(ye):Math.floor(ye));Q===Te&&(X+=v[me+K])}}w[Z+K]=X}}}}return t.makeTensorInfo(r.shape,r.dtype,w)}const Kz={kernelName:ry,backendName:"cpu",kernelFunc:qz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:o}=s;$e(r,"reverse");const a=r.shape.length,l=Me(o,r.shape);if(a===0)return Ps({inputs:{x:r},backend:t});const u=new kt(r.shape,r.dtype),d=t.bufferSync(r);for(let p=0;p<u.size;p++){const f=u.indexToLoc(p),m=f.slice();l.forEach(g=>m[g]=r.shape[g]-1-m[g]),u.set(d.get(...m),...f)}return t.makeTensorInfo(u.shape,u.dtype,u.values)}const Yz={kernelName:Hp,backendName:"cpu",kernelFunc:Xz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qz={kernelName:yf,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:o,center:a}=e,l=t,u=Dt(s.dtype,oe(s.shape)),[d,p,f,m]=s.shape,[g,x]=x0(a,p,f),w=255,v=Math.sin(r),b=Math.cos(r),C=l.data.get(s.dataId).values;for(let N=0;N<d;N++){const R=N*f*p*m;for(let D=0;D<p;D++){const F=D*(f*m);for(let V=0;V<f;V++){const P=V*m;for(let A=0;A<m;A++){const T=[d,D,V,A],W=T[2],j=T[1];let Y=(W-g)*b-(j-x)*v,Q=(W-g)*v+(j-x)*b;Y=Math.round(Y+g),Q=Math.round(Q+x);let Z=o;if(typeof o!="number"&&(A===3?Z=w:Z=o[A]),Y>=0&&Y<f&&Q>=0&&Q<p){const U=Q*(f*m),K=Y*m,X=R+U+K+A;Z=C[X]}const ne=R+F+P+A;u[ne]=Z}}}}return{dataId:l.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zz=Xe(ql,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),Jz={kernelName:ql,backendName:"cpu",kernelFunc:Zz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eW(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:o}=e,{shape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:d,strides:p,outputSize:f}=Kr(o,r,a),m=!0,g=t.bufferSync(r),x=t.bufferSync(o),w=$o(g,x,a,f,d,u,l,p,0,m);return t.makeTensorInfo(a,w.dtype,w.values)}const tW={kernelName:jp,backendName:"cpu",kernelFunc:eW};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nW(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function sW(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function rW(n,e,t,s,r,o){const a=xt("int32",t*r);for(let l=0;l<t;++l){const u=n.slice(l*s,(l+1)*s),d=l*r;for(let p=0;p<r;++p)a[d+p]=o==="left"?nW(u,e[p+d]):sW(u,e[p+d])}return a}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oW(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:o}=e,{side:a}=s,l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,d=rW(l,u,r.shape[0],r.shape[1],o.shape[1],a);return t.makeTensorInfo(o.shape,"int32",d)}const aW={kernelName:Kp,backendName:"cpu",kernelFunc:oW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iW(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:o}=e;$e([s,r,o],"select");const a=s.shape.length,l=t.data.get(s.dataId).values,u=t.data.get(r.dataId).values,d=t.data.get(o.dataId).values,p=fn(r.dtype,o.dtype),f=Mt(oe(r.shape),p);let m=0;const g=a===0||a>1||r.shape.length===1?1:oe(r.shape.slice(1));for(let x=0;x<l.length;x++)for(let w=0;w<g;w++)l[x]===1?f[m++]=u[x]:f[m++]=d[x];return t.makeTensorInfo(r.shape,p,f)}const lW={kernelName:Xp,backendName:"cpu",kernelFunc:iW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uW=b0,cW=$0,dW=Xe(Xl,n=>n>=0?cW*n:uW*(Math.exp(n)-1)),pW={kernelName:Xl,backendName:"cpu",kernelFunc:dW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fW=Xe(Zl,n=>n<0?-1:n>0?1:0),hW={kernelName:Zl,backendName:"cpu",kernelFunc:fW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mW=Xe(Yl,n=>Math.sin(n)),gW={kernelName:Yl,backendName:"cpu",kernelFunc:mW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yW=Xe(Ql,n=>Math.sinh(n)),xW={kernelName:Ql,backendName:"cpu",kernelFunc:yW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vW=11920928955078125e-23,Fw=Math.log(vW)+2,wW=Xe(eu,n=>{const e=n>-Fw,t=n<Fw,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),bW={kernelName:eu,backendName:"cpu",kernelFunc:wW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $W(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,paddings:a}=s;$e([r],"spaceToBatchND");const l=oe(o),u=[[0,0]];u.push(...a);for(let D=1+o.length;D<r.shape.length;++D)u.push([0,0]);const d=gN.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),p=vu(d.shape,o,l,!1),f=wu(p.length,o.length,!1),m=bu(d.shape,o,l,!1),w=it({inputs:{x:d},backend:t,attrs:{shape:p}}),C=mn({inputs:{x:w},backend:t,attrs:{perm:f}}),R=it({inputs:{x:C},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(C),R}const SW={kernelName:Zp,backendName:"cpu",kernelFunc:$W};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CW(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:o,defaultValue:a}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const l=t.data.get(s.dataId).values,u=t.data.get(r.dataId).values,d=t.data.get(o.dataId).values,p=t.data.get(a.dataId).values[0],[f,m,g,x,w]=Wk(l,s.shape,s.dtype,u,r.dtype,d,p);return[t.makeTensorInfo(m,s.dtype,f),t.makeTensorInfo([m[0]],r.dtype,g),t.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(v=>Number(v)))),t.makeTensorInfo([w.length],s.dtype,new Int32Array(w))]}const kW={kernelName:tf,backendName:"cpu",kernelFunc:CW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NW(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const a=Array.from(t.data.get(r.dataId).values),l=t.data.get(s.dataId).values,u=Array.from(t.data.get(o.dataId).values),[d,p,f]=Uk(l,s.shape,s.dtype,a,u);return[t.makeTensorInfo(p,s.dtype,d),t.makeTensorInfo([f.length],o.dtype,new Int32Array(f))]}const IW={kernelName:nf,backendName:"cpu",kernelFunc:NW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TW(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,[d,p]=G0(a,s.shape,s.dtype,l,u,!0);return t.makeTensorInfo(p,s.dtype,d)}const EW={kernelName:sf,backendName:"cpu",kernelFunc:TW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RW(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,[d,p]=G0(a,s.shape,s.dtype,l,u);return t.makeTensorInfo(p,s.dtype,d)}const _W={kernelName:rf,backendName:"cpu",kernelFunc:RW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OW(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:o,defaultValue:a}=e,{outputShape:l}=s,{sliceRank:u,numUpdates:d,sliceSize:p,strides:f,outputSize:m}=Kr(o,r,l),g=!1,x=t.bufferSync(r);let w;switch(o.dtype){case"bool":{const v=t.bufferSync(o),b=!!t.data.get(a.dataId).values[0];w=$o(x,v,l,m,p,d,u,f,b,g);break}case"float32":{const v=t.bufferSync(o),b=t.data.get(a.dataId).values[0];w=$o(x,v,l,m,p,d,u,f,b,g);break}case"int32":{const v=t.bufferSync(o),b=t.data.get(a.dataId).values[0];w=$o(x,v,l,m,p,d,u,f,b,g);break}case"string":{const v=t.bufferSync(o),b=tr(t.data.get(a.dataId).values[0]);w=$o(x,v,l,m,p,d,u,f,b,g);break}default:throw new Error(`Unsupported type ${o.dtype}`)}return t.makeTensorInfo(l,w.dtype,w.values)}const DW={kernelName:of,backendName:"cpu",kernelFunc:OW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:o,axis:a}=s,l=Me(a,r.shape)[0],u=F0(r,o,l),d=new Array(r.shape.length).fill(0),p=r.shape.slice();return u.map(f=>{const m=[...p];m[l]=f;const g=Fo({inputs:{x:r},backend:t,attrs:{begin:d,size:m}});return d[l]+=f,g})}const FW={kernelName:Jp,backendName:"cpu",kernelFunc:AW};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PW={kernelName:ay,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;$e(t,"square");const r=s.data.get(t.dataId).values,o=new Float32Array(r.length);for(let l=0;l<r.length;++l){const u=r[l];o[l]=u*u}return{dataId:s.write(o,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LW=Xe(lu,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),VW={kernelName:lu,backendName:"cpu",kernelFunc:LW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,end:a,strides:l,beginMask:u,endMask:d,ellipsisMask:p,newAxisMask:f,shrinkAxisMask:m}=s;$e(r,"stridedSlice");const{finalShapeSparse:g,finalShape:x,isIdentity:w,sliceDim0:v,isSimpleSlice:b,begin:C,end:I,strides:N}=m0(r.shape,o,a,l,u,d,p,f,m);let R;if(w)R=it({inputs:{x:r},backend:t,attrs:{shape:x}});else if(v||b){O(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const D=d0(C,I,N),F=Fo({inputs:{x:r},backend:t,attrs:{begin:C,size:D}});R=it({inputs:{x:F},backend:t,attrs:{shape:x}}),t.disposeIntermediateTensorInfo(F)}else{const D=t.bufferSync(r),F=jk(g,D,N,C);R=t.makeTensorInfo(x,F.dtype,F.values)}return R}const MW={kernelName:af,backendName:"cpu",kernelFunc:BW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zW(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:o,leftPad:a,rightPad:l,padWidth:u,preserveShortSequences:d}=s,{data:p,dataSplits:f}=e,m=t.data.get(p.dataId).values,g=t.data.get(f.dataId).values,[x,w]=qk(m,g,r,o,a,l,u,d);return[t.makeTensorInfo([x.length],"string",x),t.makeTensorInfo(f.shape,"int32",w)]}const WW={kernelName:lf,backendName:"cpu",kernelFunc:zW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UW(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:o,delimiter:a}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const l=t.data.get(o.dataId).values,u=t.data.get(a.dataId).values[0],[d,p,f]=Kk(l,u,r),m=p.length;return[t.makeTensorInfo([m,2],"int32",d),t.makeTensorInfo([m],"string",p),t.makeTensorInfo([2],"int32",new Int32Array(f))]}const GW={kernelName:uf,backendName:"cpu",kernelFunc:UW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HW(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.data.get(o.dataId).values,l=Xk(a,r);return t.makeTensorInfo(o.shape,"int32",l)}const jW={kernelName:cf,backendName:"cpu",kernelFunc:HW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qW=Xe(ou,n=>Math.tan(n)),KW={kernelName:ou,backendName:"cpu",kernelFunc:qW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XW=Xe(au,n=>Math.tanh(n)),YW={kernelName:au,backendName:"cpu",kernelFunc:XW};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QW(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:u,strides:d,outputSize:p}=Kr(o,r,s.shape),f=!1,m=t.bufferSync(r),g=t.bufferSync(o),x=t.bufferSync(s),w=$o(m,g,s.shape,p,u,l,a,d,x,f);return t.makeTensorInfo(s.shape,w.dtype,w.values)}const ZW={kernelName:qp,backendName:"cpu",kernelFunc:QW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:o}=s;$e(r,"tile");const a=Qk(t.bufferSync(r),o);return t.makeTensorInfo(a.shape,a.dtype,a.values)}const eU={kernelName:iu,backendName:"cpu",kernelFunc:JW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:o,sorted:a}=s;$e(r,"topk");const l=t.data.get(r.dataId).values,[u,d]=Jk(l,r.shape,r.dtype,o,a);return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(d.shape,d.dtype,d.values)]}const nU={kernelName:df,backendName:"cpu",kernelFunc:tU};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sU(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:o}=e,{interpolation:a,fillMode:l,fillValue:u,outputShape:d}=t,[p,f,m,g]=r.shape,[x,w]=d??[f,m],v=[p,x,w,g],b=Ie(r.shape),C=b[0],I=b[1],N=b[2],R=Ie(v),D=R[0],F=R[1],V=R[2],P=Dt(r.dtype,oe(v));P.fill(u);const A=s.data.get(r.dataId).values,T=s.data.get(o.dataId).values;for(let j=0;j<p;++j){const Y=o.shape[0]===1?T:T.subarray(j*8,j*8+8);for(let Q=0;Q<x;++Q)for(let Z=0;Z<w;++Z)for(let ne=0;ne<g;++ne){let U;const K=Y[6]*Z+Y[7]*Q+1;if(K===0)continue;const X=(Y[0]*Z+Y[1]*Q+Y[2])/K,L=(Y[3]*Z+Y[4]*Q+Y[5])/K,H=Pw(X,m,l),re=Pw(L,f,l);switch(a){case"nearest":U=uU(A,f,m,C,I,N,j,re,H,ne,u);break;case"bilinear":U=cU(A,f,m,C,I,N,j,re,H,ne,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}const ae=j*D+Q*F+Z*V+ne;P[ae]=U}return s.makeTensorInfo(v,r.dtype,P)}return{dataId:s.write(P,v,r.dtype),shape:r.shape,dtype:r.dtype}}const rU={kernelName:pf,backendName:"cpu",kernelFunc:sU};function Pw(n,e,t){switch(t){case"reflect":return oU(n,e);case"wrap":return aU(n,e);case"nearest":return lU(n,e);case"constant":default:return iU(n)}}function oU(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return Lr(0,t,e-1)}function aU(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return Lr(0,t,e-1)}function iU(n,e){return n}function lU(n,e){return Lr(0,n,e-1)}function Pi(n,e,t,s,r,o,a,l,u,d,p){const f=a*s+l*r+u*o+d;return 0<=l&&l<e&&0<=u&&u<t?n[f]:p}function uU(n,e,t,s,r,o,a,l,u,d,p){const f=Math.round(l),m=Math.round(u);return Pi(n,e,t,s,r,o,a,f,m,d,p)}function cU(n,e,t,s,r,o,a,l,u,d,p){const f=Math.floor(l),m=Math.floor(u),g=f+1,x=m+1,w=(x-u)*Pi(n,e,t,s,r,o,a,f,m,d,p)+(u-m)*Pi(n,e,t,s,r,o,a,f,x,d,p),v=(x-u)*Pi(n,e,t,s,r,o,a,g,m,d,p)+(u-m)*Pi(n,e,t,s,r,o,a,g,x,d,p);return(g-l)*w+(l-f)*v}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dU(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:o}=e;$e(o,"unique");const a=s.data.get(o.dataId).values,{outputValues:l,outputShape:u,indices:d}=eN(a,r,o.shape,o.dtype);return[s.makeTensorInfo(u,o.dtype,l),s.makeTensorInfo([d.length],"int32",d)]}const pU={kernelName:ff,backendName:"cpu",kernelFunc:dU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fU(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const a=r.shape.length,l=r.shape[o],u=new Array(a-1);let d=0;for(let g=0;g<a;g++)g!==o&&(u[d++]=r.shape[g]);const p=new Array(a).fill(0),f=r.shape.slice();f[o]=1;const m=new Array(l);for(let g=0;g<m.length;g++){p[o]=g;const x=Fo({inputs:{x:r},backend:t,attrs:{begin:p,size:f}});m[g]=it({inputs:{x},backend:t,attrs:{shape:u}}),t.disposeIntermediateTensorInfo(x)}return m}const hU={kernelName:hf,backendName:"cpu",kernelFunc:fU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:o}=e,{numSegments:a}=s;$e(r,"unsortedSegmentSum");const l=r.shape.length,u=o.shape.length,d=[],p=[],f=l-u;let m=o;for(let x=0;x<f;++x){const w=wd({inputs:{input:m},backend:t,attrs:{dim:x+1}});m=w,p.push(w)}for(let x=0;x<a;++x){const w=ar(x,"int32"),v=t.makeTensorInfo([],"int32",w),b=mk({inputs:{a:v,b:m},backend:t}),C=Gr({inputs:{x:b},backend:t,attrs:{dtype:"float32"}}),I=Uf({inputs:{a:C,b:r},backend:t}),N=$u({inputs:{x:I},backend:t,attrs:{axis:0,keepDims:!1}});d.push(N),p.push(v),p.push(b),p.push(C),p.push(I),p.push(N)}const g=mN({inputs:d,backend:t,attrs:{axis:0}});return p.forEach(x=>t.disposeIntermediateTensorInfo(x)),g}const gU={kernelName:mf,backendName:"cpu",kernelFunc:mU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yU=[dV,HL,fV,mV,QL,yV,vV,bV,SV,kV,IV,EV,_V,AV,PV,BV,zV,UV,HV,uV,qV,XV,QV,JL,JV,XL,t4,tB,jL,sB,oB,aB,lB,cB,pB,hB,gB,xB,wB,$B,CB,NB,TB,RB,_B,DB,FB,LB,VB,BB,MB,WB,HB,nV,qB,n4,tM,s4,nM,o4,lM,uM,dM,i4,u4,fM,mM,yM,vM,d4,f4,qL,bM,rB,SM,kM,IM,sV,m4,y4,EM,v4,_M,AM,PM,BM,zM,UM,GM,b4,jM,KM,YM,ZM,ez,nz,rz,S4,az,uz,pz,k4,I4,mz,xz,bz,E4,Sz,kz,Nz,gN,Rz,oV,O4,Oz,Az,Pz,Vz,KL,Lg,Mz,aV,iV,lV,Wz,Gz,jz,Kz,Yz,Qz,Jz,M4,tW,aW,lW,pW,W4,hW,gW,xW,U4,cz,bW,SW,kW,IW,EW,_W,DW,FW,j4,PW,K4,Y4,VW,MW,WW,GW,jW,eV,UB,KW,YW,ZW,eU,nU,rU,R4,pU,hU,gU,Cz];for(const n of yU)xf(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wo={},Mc={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function xU(n,e){wo[n]=e}function xs(n,e){if(!(n in wo)||e!=null){const s=wU(n,e);if(s!==null)wo[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=wo[n];return t==null||t.isContextLost()?(delete wo[n],xs(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),wo[n])}function vU(n){if(!J().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function wU(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??vU(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete wo[n]},!1),J().getBool("SOFTWARE_WEBGL_ENABLED")&&(Mc.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Mc)||t.getContext("experimental-webgl",Mc):t.getContext("webgl2",Mc)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var el;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(el||(el={}));var Mn;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Mn||(Mn={}));var Bt;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Bt||(Bt={}));function Su(n,e){return[e,n]}function bU(n,e){return n*e}function zc(n){const e=oe(n),t=Math.ceil(e/4);return od(t)}function Ba(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function $U(n,e){const[t,s]=Ba(n,e);return t*s*4}function X0(n,e){const t=n;let s,r,o,a,l,u,d,p,f,m;return J().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,o=t.RGBA16F,a=t.RGBA32F,l=t.RED,d=4,p=1,f=t.HALF_FLOAT,m=t.FLOAT,u=t.RGBA8):(s=n.RGBA,r=n.RGBA,o=n.RGBA,a=t.RGBA,l=n.RGBA,d=4,p=4,f=e!=null?e.HALF_FLOAT_OES:null,m=n.FLOAT,u=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:a,textureFormatFloat:l,downloadTextureFormat:u,downloadUnpackNumChannels:d,defaultNumChannels:p,textureTypeHalfFloat:f,textureTypeFloat:m}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ve(n,e){const t=e();return J().getBool("DEBUG")&&SU(n),t}function SU(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+IU(n,e))}const CU=596e-10,kU=65504;function NU(n){return!!(J().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||CU<Math.abs(n)&&Math.abs(n)<kU)}function IU(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Wc(n,e){return cr(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function TU(n,e){const t=cr(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ve(n,()=>n.shaderSource(t,e)),ve(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function EU(n,e){const t=cr(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ve(n,()=>n.shaderSource(t,e)),ve(n,()=>n.compileShader(t)),J().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw yN(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const RU=/ERROR: [0-9]+:([0-9]+):/g;function yN(n,e){const t=RU.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),o=r.length.toString().length+2,a=r.map((f,m)=>So((m+1).toString(),o)+f);let l=0;for(let f=0;f<a.length;f++)l=Math.max(a[f].length,l);const u=a.slice(0,s-1),d=a.slice(s-1,s),p=a.slice(s);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${So(d[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join(`
`))}function _U(n){return cr(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function OU(n,e){if(ve(n,()=>n.linkProgram(e)),!J().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Jm(n,e){if(ve(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function DU(n,e){const t=cr(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ve(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),ve(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function AU(n,e){const t=cr(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ve(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),ve(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function FU(n){return cr(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function PU(n,e){const t=J().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function LU(n){return cr(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Lw(n,e,t,s,r,o,a){const l=n.getAttribLocation(e,t);return l===-1?!1:(ve(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),ve(n,()=>n.vertexAttribPointer(l,r,n.FLOAT,!1,o,a)),ve(n,()=>n.enableVertexAttribArray(l)),!0)}function VU(n,e,t){UU(n,t),ve(n,()=>n.activeTexture(n.TEXTURE0+t)),ve(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function BU(n,e,t){return cr(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function MU(n,e,t){return n.getUniformLocation(e,t)}function zU(n,e,t,s){ve(n,()=>VU(n,e,s)),ve(n,()=>n.uniform1i(t,s))}function eg(n,e,t){ve(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ve(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function Vw(n,e){ve(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ve(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Uc(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+WU(n,e))}function WU(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function cr(n,e,t){const s=ve(n,()=>e());if(s==null)throw new Error(t);return s}function UU(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Da(n,e=2){return oe(n.slice(0,n.length-e))}function Aa(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Gc(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Da(n),...Aa(n)]),e}function GU(n,e=!1){let t=J().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=J().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&J().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((l,u)=>u>=n.length-2?Id(n[u]):n[u]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=or(n).newShape);let r=oe(n),o=null;n.length<=1&&r<=t?o=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?o=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?o=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?o=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?o=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(o=[n[0],n[1]*n[2]*n[3]]);const a=o!=null&&Math.max(...o)>s&&Math.min(...o)<=(e?2:1)&&Math.min(...o)>0;if(o==null||a)if(e){const l=Da(n);let u=2,d=2;n.length&&([u,d]=Aa(n)),r=l*(u/2)*(d/2),o=od(r).map(p=>p*2)}else o=od(r);return o}function Hc(n){return n%2===0}function $d(n,e){if(n=n.slice(-2),e=e.slice(-2),Qe(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||Hc(t)&&Hc(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Hc(n[0])&&Hc(e[0])}let tg,ng;function HU(n){if(tg==null){const e=xs(n);tg=e.getParameter(e.MAX_TEXTURE_SIZE)}return tg}function jU(n){if(ng==null){const e=xs(n);ng=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,ng)}function qU(n){if(n===0)return 0;let e;const t=xs(n);return Zn(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:Zn(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Zn(n,e){return n.getExtension(e)!=null}function Bw(n){try{if(xs(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function KU(n){if(n===0)return!1;const e=xs(n);if(n===1){if(!Zn(e,"OES_texture_float"))return!1}else if(!Zn(e,"EXT_color_buffer_float"))return!1;return Bg(e)}function XU(n){if(n===0)return!1;const e=xs(n);if(n===1){if(!Zn(e,"OES_texture_float")||!Zn(e,"WEBGL_color_buffer_float"))return!1}else{if(Zn(e,"EXT_color_buffer_float"))return Bg(e);const s="EXT_color_buffer_half_float";if(Zn(e,s)){const r=e.getExtension(s);return YU(e,r)}return!1}return Bg(e)}function Bg(n){const e=X0(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(o),a}function YU(n,e){const t=X0(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const l=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(a),l}function QU(n){return n!==2?!1:xs(n).fenceSync!=null}function Cu(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&O(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ce=J();Ce.registerFlag("HAS_WEBGL",()=>Ce.getNumber("WEBGL_VERSION")>0);Ce.registerFlag("WEBGL_VERSION",()=>Bw(2)?2:Bw(1)?1:0);Ce.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ce.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ce.get("WEBGL_VERSION")===2);Ce.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ce.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ce.registerFlag("WEBGL_PACK",()=>Ce.getBool("HAS_WEBGL"));Ce.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_CLIP",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_REDUCE",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_CONV_IM2COL",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>HU(Ce.getNumber("WEBGL_VERSION")));Ce.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>jU(Ce.getNumber("WEBGL_VERSION")));Ce.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Ce.getNumber("WEBGL_VERSION");return n===0?0:qU(n)});Ce.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ce.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!uy());Ce.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>KU(Ce.getNumber("WEBGL_VERSION")));Ce.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ce.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ce.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ce.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>XU(Ce.getNumber("WEBGL_VERSION")));Ce.registerFlag("WEBGL_FENCE_API_ENABLED",()=>QU(Ce.getNumber("WEBGL_VERSION")));Ce.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ce.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ce.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Ce.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>uy()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Ce.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ce.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ce.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ce.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Ce.registerFlag("WEBGL_EXP_CONV",()=>!1);Ce.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ce.getBool("IS_TEST"));Ce.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Ce.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Ce.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Ce.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function un(){let n,e,t,s,r,o,a,l,u,d;return J().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",o="outputColor",a="out vec4 outputColor;",l=J().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",d=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",o="gl_FragColor",a="",l=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,d=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:o,defineOutput:a,defineSpecialNaN:l,defineSpecialInf:u,defineRound:d}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mo(n,e,t="index"){const s=Ie(e);return s.map((r,o)=>{const a=`int ${n[o]} = ${t} / ${r}`,l=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r}`:`index -= ${n[o]} * ${r}`;return`${a}; ${l};`}).join("")}function Gf(n,e,t="index"){const s=Ie(e);return s.map((r,o)=>{const a=`int ${n[o]} = ${t} / outShapeStrides[${o}]`,l=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`;return`${a}; ${l};`}).join("")}function ZU(n,e){const t=n.length,s=n.map(o=>`${e}[${o}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let o=t-3;o>=0;--o)r[o]=`(${r[o+1]} * ${s[o+1]})`;return r}function JU(n,e,t="index"){const s=n.map((o,a)=>a),r=ZU(s,e);return r.map((o,a)=>{const l=`int ${n[a]} = ${t} / ${r[a]}`,u=a===r.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${r[a]}`:`index -= ${n[a]} * ${r[a]}`;return`${l}; ${u};`}).join("")}function Y0(n){const e=Ie(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Q0(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const xN=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:vN}=sk;function eG(n,e,t){const s=[];if(n.forEach(g=>{const x=oe(g.shapeInfo.logicalShape);if(g.shapeInfo.isUniform?s.push(`uniform float ${g.name}${x>1?`[${x}]`:""};`):(s.push(`uniform sampler2D ${g.name};`),s.push(`uniform int offset${g.name};`)),t.enableShapeUniforms){const{uniformShape:w}=Z0(t.packedInputs,g.shapeInfo.logicalShape,g.shapeInfo.texShape);switch(w.length){case 1:s.push(`uniform int ${g.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${g.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${g.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${g.name}Shape;`);break}s.push(`uniform ivec2 ${g.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(g=>{s.push(`uniform ${g.type} ${g.name}${g.arrayIndex?`[${g.arrayIndex}]`:""};`)});const r=s.join(`
`),o=n.map(g=>tG(g,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,l=un(),u=rG(l);let d,p,f=iG(l);return e.isPacked?(d=nG(e.logicalShape,a,t.enableShapeUniforms),p=aG(l)):(d=sG(e.logicalShape,a,t.enableShapeUniforms),p=oG(l)),t.packedInputs&&(f+=dG),[f,u,p,r,d,o,t.userCode].join(`
`)}function Ma(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return SG(n,e);case 1:return kG(n,e);case 2:return IG(n,e);case 3:return EG(n,e);case 4:return _G(n,e);case 5:return OG(n);case 6:return DG(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function wN(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return $G(n);case 1:return CG(n,e);case 2:return NG(n,e);case 3:return TG(n,e);default:return RG(n,e)}}function tG(n,e,t=!1,s){let r="";t?r+=wN(n,s):r+=Ma(n,s);const o=n.shapeInfo.logicalShape,a=e.logicalShape;return o.length<=a.length&&(t?r+=AG(n,e):r+=FG(n,e)),r}function nG(n,e,t){switch(n.length){case 0:return bN();case 1:return pG(n,e,t);case 2:return wG(n,e,t);case 3:return hG(n,e,t);default:return gG(n,e,t)}}function sG(n,e,t){switch(n.length){case 0:return bN();case 1:return fG(n,e,t);case 2:return bG(n,e,t);case 3:return mG(n,e,t);case 4:return yG(n,e,t);case 5:return xG(n,e);case 6:return vG(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function rG(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function oG(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function aG(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function iG(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${lG}
    ${uG}
    ${cG}
  `}const lG=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,uG=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,cG=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,dG=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function bN(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function pG(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function fG(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function hG(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),o=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function mG(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Gf(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=Mo(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function gG(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),o=r*Math.ceil(n[n.length-2]/2);let a=o,l="",u="b, r, c";for(let d=2;d<n.length-1;d++)a*=n[n.length-d-1],l=`
      int b${d} = index / ${a};
      index -= b${d} * ${a};
    `+l,u=`b${d}, `+u;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${l}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${u});
    }
  `}function yG(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Gf(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Mo(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function xG(n,e){const t=Mo(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function vG(n,e){const t=Mo(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function wG(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Qe(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function bG(n,e,t){return Qe(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function zo(n){return`offset${n}`}function $G(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=un();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function SG(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,o]=n.shapeInfo.texShape;if(r===1&&o===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=zo(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;const[l,u]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${l}, ${u}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function CG(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,o=un();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${t}, uv);
    }
  `;const a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${o.texture2D}(${t}, uv);
    }
  `}function kG(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${za(n)}
      }
    `;const r=n.shapeInfo.texShape,o=r[0],a=r[1];if(a===1&&o===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const l=zo(t);return a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / ${o}.0);
        return sampleTexture(${t}, uv);
      }
    `:o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${l});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${o}, ${a}, index + ${l});
      return sampleTexture(${t}, uv);
    }
  `}function NG(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape,a=o[0],l=o[1],u=un();if(o!=null&&Qe(t,o))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${u.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${a}.0);

        return ${u.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;const d=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],p=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p}, ${d[0]}, ${d[1]}, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `}function IG(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape;if(o!=null&&Qe(t,o)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const m=o[0],g=o[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${m}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:a,keptDims:l}=or(t),u=a;if(u.length<t.length){const m=Wa(n,u),g=["row","col"];return`
      ${Ma(m,e)}
      float ${r}(int row, int col) {
        return ${r}(${Ua(g,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${za(n)}
      }
    `;const d=o[0],p=o[1],f=zo(s);return p===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `:d===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${f};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${f};
    vec2 uv = uvFromFlat(${d}, ${p}, index);
    return sampleTexture(${s}, uv);
  }
`}function TG(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(t[0]===1){const m=t.slice(1),g=[1,2],x=Wa(n,m),w=["b","row","col"];return`
        ${wN(x,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${Ua(w,g)});
        }
      `}const l=un();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const u=a[0],d=a[1],p=Math.ceil(t[2]/2),f=p*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${d}, ${f}, ${p}, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function EG(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t[1]*t[2],a=t[2],{newShape:l,keptDims:u}=or(t),d=l;if(d.length<t.length){const w=Wa(n,d),v=["row","col","depth"];return`
        ${Ma(w,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${Ua(v,u)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${a}, 1)));
        ${za(n)}
      }
    `;const p=n.shapeInfo.texShape,f=p[0],m=p[1],g=n.shapeInfo.flatOffset;if(m===o&&g==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${f}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(m===a&&g==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${f}.0);
      return sampleTexture(${s}, uv);
    }
  `;const x=zo(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${x};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${a} + depth + ${x};
        vec2 uv = uvFromFlat(${f}, ${m}, index);
        return sampleTexture(${s}, uv);
      }
  `}function RG(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=un();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const o=n.shapeInfo.logicalShape,a=o.length,l=n.shapeInfo.texShape,u=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)],d=u[0],p=u[1],f=Math.ceil(o[a-1]/2);let m=f*Math.ceil(o[a-2]/2),g="int b, int row, int col",x=`b * ${m} + (row / 2) * ${f} + (col / 2)`;for(let w=2;w<a-1;w++)g=`int b${w}, `+g,m*=o[a-w-1],x=`b${w} * ${m} + `+x;return`
    vec4 ${s}(${g}) {
      int index = ${x};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${d});
      return ${r.texture2D}(${t}, uv);
    }
  `}function _G(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t[3],a=t[2]*o,l=t[1]*a,{newShape:u,keptDims:d}=or(t);if(u.length<t.length){const C=Wa(n,u),I=["row","col","depth","depth2"];return`
      ${Ma(C,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${Ua(I,d)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${l}, ${a}, ${o}, 1)));
        ${za(n)}
      }
    `;const p=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,m=f[0],g=f[1],x=`int stride2 = ${s}Shape[3];`,w=`int stride1 = ${s}Shape[2] * stride2;`,v=`int stride0 = ${s}Shape[1] * stride1;`;if(g===l&&p==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${x}
        ${w}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(g===o&&p==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;const b=zo(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${x}
      ${w}
      ${v}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${b});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${a} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${m}, ${g}, index + ${b});
      return sampleTexture(${s}, uv);
    }
  `}function OG(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],o=e[3]*r,a=e[2]*o,l=e[1]*a,{newShape:u,keptDims:d}=or(e);if(u.length<e.length){const w=Wa(n,u),v=["row","col","depth","depth2","depth3"];return`
      ${Ma(w)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Ua(v,d)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${a}, ${o}, ${r})) +
          depth3;
        ${za(n)}
      }
    `;const p=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,m=f[0],g=f[1];if(g===l&&p==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(g===r&&p==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;const x=zo(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${a} + depth * ${o} +
          depth2 * ${r} + depth3 + ${x};
      vec2 uv = uvFromFlat(${m}, ${g}, index);
      return sampleTexture(${t}, uv);
    }
  `}function DG(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:o}=or(e);if(r.length<e.length){const v=Wa(n,r),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${Ma(v)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Ua(b,o)});
      }
    `}const a=e[5],l=e[4]*a,u=e[3]*l,d=e[2]*u,p=e[1]*d;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${p}, ${d}, ${u}, ${l})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${za(n)}
      }
    `;const f=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,g=m[0],x=m[1];if(x===p&&f==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${d}, ${u}, ${l}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${x}.0, ${g}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(x===a&&f==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${x}.0, ${g}.0);
        return sampleTexture(${t}, uv);
      }
    `;const w=zo(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${p} + col * ${d} + depth * ${u} +
          depth2 * ${l} + depth3 * ${a} + depth4 + ${w};
      vec2 uv = uvFromFlat(${g}, ${x}, index);
      return sampleTexture(${t}, uv);
    }
  `}function za(n){const e=n.name,t=oe(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function AG(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",o=n.shapeInfo.logicalShape.length,a=e.logicalShape.length,l=vN(n.shapeInfo.logicalShape,e.logicalShape),u=Ze(a),d=a-o;let p;const f=["x","y","z","w","u","v"];o===0?p="":a<2&&l.length>=1?p="coords = 0;":p=l.map(C=>`coords.${f[C+d]} = 0;`).join(`
`);let m="";a<2&&o>0?m="coords":m=n.shapeInfo.logicalShape.map((C,I)=>`coords.${f[I+d]}`).join(", ");let g="return outputValue;";const w=oe(n.shapeInfo.logicalShape)===1,b=oe(e.logicalShape)===1;if(o===1&&!w&&!b)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(w&&!b)a===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(l.length){const C=o-2,I=o-1;l.indexOf(C)>-1&&l.indexOf(I)>-1?g="return vec4(outputValue.x);":l.indexOf(C)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(I)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${p}
      vec4 outputValue = get${s}(${m});
      ${g}
    }
  `}function FG(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",o=e.texShape,a=n.shapeInfo.texShape,l=n.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!n.shapeInfo.isUniform&&l===u&&n.shapeInfo.flatOffset==null&&Qe(a,o))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const d=Ze(u),p=vN(n.shapeInfo.logicalShape,e.logicalShape),f=u-l;let m;const g=["x","y","z","w","u","v"];l===0?m="":u<2&&p.length>=1?m="coords = 0;":m=p.map(w=>`coords.${g[w+f]} = 0;`).join(`
`);let x="";return u<2&&l>0?x="coords":x=n.shapeInfo.logicalShape.map((w,v)=>`coords.${g[v+f]}`).join(", "),`
    float ${r}() {
      ${d} coords = getOutputCoords();
      ${m}
      return get${s}(${x});
    }
  `}function Ze(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Z0(n,e,t){const{newShape:s,keptDims:r}=or(e),o=e.length,a=n&&o===3&&e[0]===1,l=a?e.slice(1):s,u=!n&&o>1&&!Qe(e,t)&&s.length<o||a;return{useSqueezeShape:u,uniformShape:u?l:e,keptDims:r}}function Wa(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Ua(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PG(n,e,t,s){const r=t.map((p,f)=>{const m={logicalShape:p.shape,texShape:p.isUniform?null:p.texData.texShape,isUniform:p.isUniform,isPacked:p.isUniform?!1:p.texData.isPacked,flatOffset:null};return p.texData!=null&&p.texData.slice!=null&&p.texData.slice.flatOffset>0&&(m.flatOffset=p.texData.slice.flatOffset),{name:e.variableNames[f],shapeInfo:m}}),o=r.map(p=>p.shapeInfo),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},l=eG(r,a,e),u=EU(n.gl,l),d=n.createProgram(u);return J().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:l,webGLProgram:d,inShapeInfos:o,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(d),Object.assign({program:e,fragmentShader:u,source:l,webGLProgram:d,inShapeInfos:o,outShapeInfo:a},$N(n,e,d)))}function $N(n,e,t){const s=[],r=[];let o,a,l,u=null,d=null;d=n.getUniformLocation(t,"NAN",!1),J().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(t,"INFINITY",!1));const p=!1;for(const f of e.variableNames){const m={name:f,uniform:n.getUniformLocation(t,f,p),offset:n.getUniformLocation(t,`offset${f}`,p)};e.enableShapeUniforms&&(m.shape=n.getUniformLocation(t,`${f}Shape`,p),m.texShape=n.getUniformLocation(t,`${f}TexShape`,p)),s.push(m)}if(e.enableShapeUniforms&&(o=n.getUniformLocation(t,"outShape",p),l=n.getUniformLocation(t,"outShapeStrides",p),a=n.getUniformLocation(t,"outTexShape",p)),e.customUniforms)for(const f of e.customUniforms)r.push(n.getUniformLocation(t,f.name,p));return{variablesLocations:s,customUniformLocations:r,infLoc:u,nanLoc:d,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:a}}function Mw(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,o=e[s],a=o.shape;if(!Qe(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(t.isUniform&&o.isUniform)return;const l=t.texShape,u=o.isUniform?null:o.texData.texShape;if(!Qe(l,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${l} and ${u} must match`)})}function LG(n,e,t,s,r){e.program.enableShapeUniforms||(Mw(e.inShapeInfos,t),Mw([e.outShapeInfo],[s]));const o=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,a[0],a[1]):n.setOutputMatrixTexture(o.texture,a[0],a[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),J().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let u=0;u<t.length;++u){const d=t[u],{uniform:p,offset:f,shape:m,texShape:g}=e.variablesLocations[u];if(m){const{uniformShape:x}=Z0(e.program.packedInputs,d.shape,d.texData.texShape);switch(x.length){case 1:n.gl.uniform1iv(m,new Int32Array(x));break;case 2:n.gl.uniform2iv(m,new Int32Array(x));break;case 3:n.gl.uniform3iv(m,new Int32Array(x));break;case 4:n.gl.uniform4iv(m,new Int32Array(x));break}}if(g&&n.gl.uniform2i(g,d.texData.texShape[0],d.texData.texShape[1]),p!=null){if(d.isUniform){if(oe(d.shape)<2)n.gl.uniform1f(p,d.uniformValues[0]);else{let x=d.uniformValues;x instanceof Float32Array||(x=new Float32Array(x)),n.gl.uniform1fv(p,x)}continue}d.texData.slice!=null&&f!=null&&n.gl.uniform1i(f,d.texData.slice.flatOffset),n.setInputMatrixTexture(d.texData.texture.texture,p,u)}}const l=e.outShapeLocation;if(l)switch(s.shape.length){case 1:n.gl.uniform1iv(l,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(l,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(l,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(l,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const u=Ie(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let u=0;u<e.program.customUniforms.length;++u){const d=e.program.customUniforms[u],p=e.customUniformLocations[u],f=r[u];if(d.type==="float")n.gl.uniform1fv(p,f);else if(d.type==="vec2")n.gl.uniform2fv(p,f);else if(d.type==="vec3")n.gl.uniform3fv(p,f);else if(d.type==="vec4")n.gl.uniform4fv(p,f);else if(d.type==="int")n.gl.uniform1iv(p,f);else if(d.type==="ivec2")n.gl.uniform2iv(p,f);else if(d.type==="ivec3")n.gl.uniform3iv(p,f);else if(d.type==="ivec4")n.gl.uniform4iv(p,f);else throw Error(`uniform type ${d.type} is not supported yet.`)}n.executeProgram()}function VG(n,e,t){let s="";e.concat(t).forEach(a=>{const l=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const u=a.texData.texShape,{useSqueezeShape:d,uniformShape:p,keptDims:f}=Z0(n.packedInputs,a.shape,u);let m="",g="",x="";if(p.length===1&&n.packedInputs){const R=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${R[0]>1}_${R[1]>1}`}else if(p.length===2&&!n.packedInputs)g=`${p[0]>1}_${p[1]>1}`;else if(p.length>2&&!n.packedInputs){const R=Ie(p);x=`${R[0]===u[1]}_${R[R.length-1]===u[1]}`}const w=a.shape.length,v=p.length===2&&Qe(a.shape,u),b=oe(a.shape)===1,C=_o(a.shape,t.shape),I=!n.packedInputs&&w===t.shape.length&&Qe(u,t.texData.texShape),N=n.packedInputs||p.length>2?"":`${u[0]>1}_${u[1]>1}`;s+=`${w}_${I}_${d?f:""}_${p.length}_${b}_${C}_${v}_${m}_${g}_${x}_${N}_${l}`}else{const u=a.isUniform?"uniform":a.texData.texShape;s+=`${a.shape}_${u}_${l}`}});const r=n.userCode;let o=n.constructor.name;return o+="_"+s+"_"+r+`${J().getNumber("WEBGL_VERSION")}`,o}function Qt(n){return J().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BG{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=el.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=un();this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Gf(["r","c","d"],e):Mo(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MG{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=el.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=un();this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Gf(["r","c","d"],e):Mo(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zG{constructor(e){this.variableNames=["A"],this.outTexUsage=Mn.DOWNLOAD;const t=un();this.outputShape=e,this.userCode=`
      ${xN}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WG{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Mn.DOWNLOAD;const t=un();this.outputShape=e,this.userCode=`
      ${xN}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UG={R:0,G:1,B:2,A:3};class zw{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=un();this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length);let o="result";t&&(o="floor(result * 255. + 0.5)");let a="";for(let l=0;l<s.length;l++){const u=s[l];a+=`
          if(offset == ${l}) {
            result = values[${UG[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Q0():Y0(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${o}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GG{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=un();this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length);let r="",o="result";t&&(o="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let l=0;l<=1;l++){const u=a*2+l;r+=`
          localCoords = coords;
          if(localCoords[2] + ${l} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${l};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Q0():Y0(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HG(n){const e=un(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return TU(n,t)}function jG(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return DU(n,e)}function qG(n){const e=new Uint16Array([0,1,2,2,1,3]);return AU(n,e)}function ku(n,e,t,s,r,o){PU(e,t);const a=FU(n),l=n.TEXTURE_2D;return ve(n,()=>n.bindTexture(l,a)),ve(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ve(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ve(n,()=>n.texParameteri(l,n.TEXTURE_MIN_FILTER,n.NEAREST)),ve(n,()=>n.texParameteri(l,n.TEXTURE_MAG_FILTER,n.NEAREST)),J().getNumber("WEBGL_VERSION")===1?ve(n,()=>n.texImage2D(l,0,s,e,t,0,r,o,null)):ve(n,()=>n.texStorage2D(l,1,s,e,t)),ve(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function SN(n){return n.internalFormatFloat}function KG(n,e,t,s){const[r,o]=Su(e,t);return ku(n,r,o,SN(s),s.textureFormatFloat,n.FLOAT)}function CN(n){return n.internalFormatHalfFloat}function XG(n,e,t,s){const[r,o]=Su(e,t);return ku(n,r,o,CN(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function kN(n){return n.downloadTextureFormat}function YG(n,e,t,s){const[r,o]=Su(e,t);return ku(n,r,o,kN(s),n.RGBA,n.UNSIGNED_BYTE)}function NN(n){return n.internalFormatPackedFloat}function QG(n,e,t,s){const[r,o]=Ba(e,t);return ku(n,r,o,NN(s),n.RGBA,n.FLOAT)}function IN(n){return n.internalFormatPackedHalfFloat}function ZG(n,e,t,s){const[r,o]=Ba(e,t);return ku(n,r,o,IN(s),n.RGBA,s.textureTypeHalfFloat)}function JG(n,e,t){return ve(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Lw(n,e,"clipSpacePos",t,3,20,0)&&Lw(n,e,"uv",t,2,20,12)}function eH(n,e,t,s,r,o){ve(n,()=>n.bindTexture(n.TEXTURE_2D,e));let a,l,u;r instanceof Uint8Array?(a=new Uint8Array(t*s*4),l=n.UNSIGNED_BYTE,u=n.RGBA):(a=new Float32Array(t*s*4),l=n.FLOAT,u=o.internalFormatPackedFloat),a.set(r),J().getNumber("WEBGL_VERSION")===2?ve(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,l,a)):ve(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,t,s,0,n.RGBA,l,a)),ve(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function tH(n,e,t){ve(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?J().getNumber("WEBGL_VERSION")===2?ve(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):ve(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):J().getNumber("WEBGL_VERSION")===2?ve(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):ve(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),ve(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function nH(n,e,t,s){const r=n.createBuffer();ve(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const l=4*4*e*t;return ve(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,l,n.STREAM_READ)),ve(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),ve(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function sH(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function rH(n,e,t,s){const[r,o]=Su(e,t),a=4,l=new Uint8Array(bU(e*t,a));return ve(n,()=>n.readPixels(0,0,r,o,s.downloadTextureFormat,n.UNSIGNED_BYTE,l)),new Float32Array(l.buffer)}function oH(n,e,t,s,r,o,a,l){const u=n,d=new Float32Array($U(o,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,d),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),d}function aH(n,e,t){const s=new Float32Array(e*t*4);return ve(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sg{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=J().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,xU(t,e)):this.gl=xs(t),e=this.gl,J().getNumber("WEBGL_VERSION")===2){const o=e;this.createVertexArray=()=>ve(o,()=>o.createVertexArray()),this.bindVertexArray=a=>ve(o,()=>o.bindVertexArray(a)),this.deleteVertexArray=a=>ve(o,()=>o.deleteVertexArray(a)),this.getVertexArray=()=>ve(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(e!=null){const o=e.getExtension("OES_vertex_array_object");if(o==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ve(e,()=>o.createVertexArrayOES()),this.bindVertexArray=a=>ve(e,()=>o.bindVertexArrayOES(a)),this.deleteVertexArray=a=>ve(e,()=>o.deleteVertexArrayOES(a)),this.getVertexArray=()=>ve(e,()=>e.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),J().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=Wc(this.gl,o),Zn(this.gl,a))this.textureHalfFloatExtension=Wc(this.gl,a);else if(J().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),Zn(this.gl,r))this.colorBufferHalfFloatExtension=Wc(this.gl,r);else if(J().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",Zn(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(Zn(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=jG(this.gl),this.indexBuffer=qG(this.gl),this.framebuffer=LU(this.gl),this.textureConfig=X0(this.gl,this.textureHalfFloatExtension)}get debug(){return J().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;ve(e,()=>e.finish()),ve(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ve(e,()=>e.deleteFramebuffer(this.framebuffer)),ve(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ve(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ve(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),KG(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),XG(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),YG(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),tH(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),eH(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),ZG(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),QG(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Vw(this.gl,this.framebuffer),this.outputTexture=null),ve(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>rH(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,o,a){return oH(this.gl,e,t,s,r,o,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return sH(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=nH(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(J().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const a=r.clientWaitSync(o,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=o}else J().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,J().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>aH(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=HG(t));const s=_U(t);ve(t,()=>t.attachShader(s,this.vertexShader)),ve(t,()=>t.attachShader(s,e)),OU(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Jm(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;ve(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),JG(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(ve(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Jm(this.gl,this.program),ve(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?BU(this.gl,e,t):MU(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),ve(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),zU(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,o]=Ba(t,s);this.setOutputMatrixTextureDriver(e,r,o)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Jm(this.gl,this.program),Uc(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ve(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ve(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Wc(this.gl,J().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(J().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(J().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await ag(()=>this.disposed||this.isQueryAvailable(e,J().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,J().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=iH(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in J().platform&&(s=J().platform.setTimeoutCustom.bind(J().platform)),ag(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),eg(this.gl,e,this.framebuffer),this.debug&&Uc(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(eg(this.gl,this.outputTexture,this.framebuffer),this.debug&&Uc(this.gl)):Vw(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;eg(r,e,this.framebuffer),this.debug&&Uc(r),this.outputTexture=e,ve(r,()=>r.viewport(0,0,t,s)),ve(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),ve(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function iH(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:lH,bincountImpl:TN,bincountReduceImpl:uH,bitwiseAndImpl:cH,castImpl:dH,ceilImpl:pH,concatImpl:fH,equalImpl:hH,expImpl:mH,expm1Impl:gH,floorImpl:yH,gatherNdImpl:xH,gatherV2Impl:vH,greaterImpl:wH,greaterEqualImpl:bH,lessImpl:$H,lessEqualImpl:SH,linSpaceImpl:CH,logImpl:kH,maxImpl:NH,maximumImpl:IH,minimumImpl:TH,multiplyImpl:EH,negImpl:RH,notEqualImpl:_H,prodImpl:OH,raggedGatherImpl:DH,raggedRangeImpl:AH,raggedTensorToTensorImpl:FH,rangeImpl:PH,rsqrtImpl:LH,scatterImpl:VH,sigmoidImpl:BH,simpleAbsImpl:EN,sliceImpl:MH,sparseFillEmptyRowsImpl:zH,sparseReshapeImpl:WH,sparseSegmentReductionImpl:RN,sqrtImpl:UH,staticRegexReplaceImpl:GH,stridedSliceImpl:HH,stringNGramsImpl:jH,stringSplitImpl:qH,stringToHashBucketFastImpl:KH,subImpl:XH,tileImpl:YH,topKImpl:QH,transposeImpl:J0,uniqueImpl:ZH}=tV;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _N(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function on(n,e){return e===1?[n]:_N(n,e)}function JH(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e6{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Qt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=on("rc",this.rank),s=Ze(this.rank),r=this.getOutOfBoundsCondition(t),o=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let o=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)o=`${e[e.length-1-a]},`+o;t.push(o)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ON{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length);let s="";for(let r=0;r<4;r++){let o="thisRC = rc;";r%2===1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),s+=`
        ${o}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${t6(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Q0():Y0(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function t6(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?JU(["r","c","d"],"inputShape"):Mo(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n6{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=Uw(t,s),o=Gw(e,r,s);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const a=Ww(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const u=this.freeTextures[o].pop();return this.usedTextures[o].push(u),u}let l;return r===Bt.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Bt.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Bt.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Bt.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Bt.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(l),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),l}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const o=Uw(s,r),a=Gw(t,o,r);a in this.freeTextures||(this.freeTextures[a]=[]);const l=Ww(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=J().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=l):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=l),this.numUsedTextures--;const d=this.usedTextures[a],p=d&&d.indexOf(e);if(p==null||p<0)throw new Error("Cannot release a texture that was never provided by this texture manager");d[p]=d[d.length-1],d.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function s6(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function Ww(n,e,t,s,r){const o=r6(e,s);let a;if(r){const[u,d]=Ba(n[0],n[1]);a=u*d}else{const[u,d]=Su(n[0],n[1]);a=u*d}const l=s6(t,o);return a*l}function r6(n,e){switch(n){case Bt.PACKED_2X2_FLOAT32:return NN(e);case Bt.PACKED_2X2_FLOAT16:return IN(e);case Bt.UNPACKED_FLOAT32:return SN(e);case Bt.UNPACKED_FLOAT16:return CN(e);case Bt.PACKED_4X1_UNSIGNED_BYTE:return kN(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function o6(n){return J().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Bt.PACKED_2X2_FLOAT32:Bt.UNPACKED_FLOAT32:n?Bt.PACKED_2X2_FLOAT16:Bt.UNPACKED_FLOAT16}function Uw(n,e){if(n===Mn.UPLOAD)return Bt.PACKED_2X2_FLOAT32;if(n===Mn.RENDER||n==null)return o6(e);if(n===Mn.DOWNLOAD||n===Mn.PIXELS)return Bt.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function Gw(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ts{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const ns="if (isnan(x)) return x;",a6="return x;",Hw="return abs(x);",i6="return (x >= 0.0) ? x : (exp(x) - 1.0);",l6=ns+`
  return (x < 0.0) ? 0.0 : x;
`,u6=ns+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,_r="return x;",c6="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d6="return x;",p6=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,f6=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,h6=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,m6="return 1.0 / (1.0 + exp(-1.0 * x));";class Fr{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g6{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length);const t=e.length,s=on("rc",t),r=Ze(t),o=JH(t,s),a=s.slice(-2),l=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${l}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y6=Rf,x6=1e-7,v6=1e-4,jc={};function w6(n){return n in jc||(jc[n]={}),jc[n]}const b6=J().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),$6=600;function S6(){return J().global.screen==null?1024:J().global.screen.height*J().global.screen.width*window.devicePixelRatio*$6/1024/1024}class Hf extends Nd{nextDataId(){return Hf.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!J().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof sg)t=e;else{const s=xs(J().getNumber("WEBGL_VERSION"),e);t=new sg(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=xs(J().getNumber("WEBGL_VERSION"));t=new sg(s),this.binaryCache=w6(J().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new n6(this.gpgpu),this.numMBBeforeWarning=S6(),this.texData=new Hg(this,ds())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,o,a){const l=this.makeTensorInfo(t,s),u=this.texData.get(l.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[r,o]},u.texShape=[r,o];const d=Gc(t),p=new zw(d,!1,a),f=this.runWebGLProgram(p,[l],s,[[r,o]]);return f.shape=t,u.texture=null,this.disposeIntermediateTensorInfo(l),f.dataId}write(e,t,s){if((J().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||J().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:Mn.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,o){if(J().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:Mn.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:o,slice:a,shape:l,isPacked:u}=t;if(a!=null){let m;u?m=new Fr(l,_r):m=new Ts(l,_r);const g=this.runWebGLProgram(m,[{dataId:e,shape:l,dtype:r}],r),x=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),x}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const d=this.activeTimers!=null;let p;d&&(p=In());let f;if(r==="complex64"){const m=this.readSync(o.real.dataId),g=this.readSync(o.imag.dataId);f=sr(m,g)}else f=this.getValuesFromTexture(e);return d&&(this.downloadWaitMs+=In()-p),this.convertAndCacheOnCPU(e,f)}async read(e){if(this.pendingRead.has(e)){const x=this.pendingRead.get(e);return new Promise(w=>x.push(w))}const t=this.texData.get(e),{values:s,shape:r,slice:o,dtype:a,complexTensorInfos:l,isPacked:u}=t;if(o!=null){let x;u?x=new Fr(r,_r):x=new Ts(r,_r);const w=this.runWebGLProgram(x,[{dataId:e,shape:r,dtype:a}],a),v=this.read(w.dataId);return this.disposeIntermediateTensorInfo(w),v}if(s!=null)return this.convertAndCacheOnCPU(e);if(J().getBool("DEBUG")&&!J().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&J().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let d=null,p;if(a!=="complex64"&&J().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(e);const x=this.texData.get(p.dataId);d=this.gpgpu.createBufferFromTexture(x.texture.texture,...zc(r))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let f;if(a==="complex64"){const x=await Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),w=x[0],v=x[1];f=sr(w,v)}else if(d==null)f=this.getValuesFromTexture(e);else{const x=oe(r);f=this.gpgpu.downloadFloat32MatrixFromBuffer(d,x)}if(p!=null&&this.disposeIntermediateTensorInfo(p),d!=null){const x=this.gpgpu.gl;ve(x,()=>x.deleteBuffer(d))}const m=this.convertAndCacheOnCPU(e,f),g=this.pendingRead.get(e);return this.pendingRead.delete(e),g.forEach(x=>x(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ds().removeDataId(e,this),this.pendingDeletes--),m}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:o,slice:a,dtype:l,isPacked:u,texture:d}=s;if(l==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let g;u?g=new Fr(o,_r):g=new Ts(o,_r);const x=this.runWebGLProgram(g,[{dataId:e,shape:o,dtype:l}],l),w=this.readToGPU(x,t);return this.disposeIntermediateTensorInfo(x),w}if(d==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const p=this.decode(e,t.customTexShape),f=ds().makeTensorFromTensorInfo(p),m=this.texData.get(p.dataId);return Object.assign({tensorRef:f},m.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>tr(r));return Ae(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ae(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!NU(s))throw J().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),o=oe(t);if(J().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(e),g=this.texData.get(m.dataId),x=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...zc(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(m),x}const a=J().getBool("WEBGL_PACK")&&r===!0,l=a?Gc(t):t,u=a?new WG(l):new zG(l),d=this.runWebGLProgram(u,[{shape:l,dtype:s,dataId:e}],"float32"),p=this.texData.get(d.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(d),f}timerAvailable(){return J().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const o=_s(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=_s(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(J().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(o);l.kernelMs=db(u),l.getExtraProfileInfo=()=>u.map((d,p)=>({name:a[p],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else l.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,l})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return J().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:In(),endMs:null}}endTimer(e){return J().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=In(),e)}async getQueryTime(e){if(J().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:o,isPacked:a,slice:l}=this.texData.get(e),u=l&&l.origDataId||e,d=this.dataRefCount.get(u);d>1?this.dataRefCount.set(u,d-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,o,a)));const p=this.texData.get(e);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=b6){return J().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&oe(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Vn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return y6(e.shape,t)}packedUnaryOp(e,t,s){const r=new Fr(e.shape,t),o=this.compileAndRun(r,[e],s);return ds().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=EN(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(J().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Hw,e.dtype);const t=new Ts(e.shape,Hw),s=this.compileAndRun(t,[e]);return ds().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Is(s[0])){const o=s.map(a=>Es(a));r=this.write(o,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return ds().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new g6(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new e6(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[Da(e.shape),...Aa(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},o=[Da(t),...Aa(t)],a=new ON(o,s),l=!0,u=[s],d=this.runWebGLProgram(a,[r],e.dtype,u,l);return{dataId:d.dataId,shape:t,dtype:d.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:o,dtype:a}=s;if(t!=null){const m=oe(o),g=t[0]*t[1]*4;O(m<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const l=Gc(o);let u;r?u=new MG(l):u=new BG(l);const d=!0,p=[t??zc(l)],f=this.runWebGLProgram(u,[{shape:l,dtype:a,dataId:e}],a,p,d,t);return{dtype:a,shape:o,dataId:f.dataId}}runWebGLProgram(e,t,s,r,o=!1,a){const l=this.makeTensorInfo(e.outputShape,s),u=this.texData.get(l.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===el.DENSE){const b=a??zc(e.outputShape);u.texShape=b.map(C=>C*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),oe(l.shape)===0)return u.values=Dt(l.dtype,0),l;const d=[],p=t.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let C=this.texData.get(b.dataId);if(C.texture==null){if(!e.packedInputs&&oe(b.shape)<=J().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:C.values};e.packedInputs&&(C.isPacked=!0,C.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!C.isPacked!=!!e.packedInputs)b=C.isPacked?this.unpackTensor(b):this.packTensor(b),d.push(b),C=this.texData.get(b.dataId);else if(C.isPacked&&!$d(C.shape,b.shape)){const I=b,N=b.shape;b.shape=C.shape,b=this.packedReshape(b,N),d.push(b),C=this.texData.get(b.dataId),I.shape=N}return{shape:b.shape,texData:C,isUniform:!1}});this.uploadToGPU(l.dataId);const f={shape:l.shape,texData:u,isUniform:!1},m=VG(e,p,f),g=this.getAndSaveBinary(m,()=>PG(this.gpgpu,e,p,f)),x=this.activeTimers!=null;let w;x&&(w=this.startTimer()),J().get("ENGINE_COMPILE_ONLY")||LG(this.gpgpu,g,p,f,r),d.forEach(b=>this.disposeIntermediateTensorInfo(b)),x&&(w=this.endTimer(w),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(w)}));const v=J().getNumber("WEBGL_FLUSH_THRESHOLD");if(v>0){const b=In();b-this.lastGlFlushTime>v&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!J().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&o===!1){const b=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),b}return l}compileAndRun(e,t,s,r,o=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,o)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(J().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Ue(()=>{if(!J().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=J().getBool("DEBUG");J().set("DEBUG",!1);const t=this.abs(Ve(1e-8)).dataSync()[0];if(J().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?x6:v6}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:o,texture:a,usage:l,isPacked:u}=t;if(a!=null)return;const d=this.activeTimers!=null;let p;d&&(p=In());let f=t.texShape;if(f==null&&(f=GU(s,u),t.texShape=f),o!=null){const m=Gc(s);let g,x=f[1],w=f[0];const v=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(u||!v)&&([x,w]=Ba(f[0],f[1])),u?g=new GG(m,v):g=new zw(m,v);const b=v?[w,x]:f,C=this.makeTensorInfo(b,r),I=this.texData.get(C.dataId);v?I.usage=Mn.PIXELS:I.usage=Mn.UPLOAD,I.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(C.dataId),x,w,o);const N=[[w,x]],D=this.runWebGLProgram(g,[C],r,N,!0),F=this.texData.get(D.dataId);t.texShape=F.texShape,t.isPacked=F.isPacked,t.usage=F.usage,J().get("ENGINE_COMPILE_ONLY")?this.disposeData(D.dataId):(t.texture=F.texture,t.values=null,this.texData.delete(D.dataId)),this.disposeIntermediateTensorInfo(C),d&&(this.uploadWaitMs+=In()-p)}else{const m=this.acquireTexture(f,l,r,u);t.texture=m}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=C6(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Vi(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(o){throw o}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await OC(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(yN(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:o,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:u}=$N(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=o,e.outShapeLocation=a,e.outShapeStridesLocation=l,e.outTexShapeLocation=u}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:o,width:a,channels:l}=e,u=ds().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const d=u.writeTexture(r,t,s,o,a,l);return ds().makeTensorFromDataId(d,t,s,u)}}Hf.nextDataId=0;function C6(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */cy()&&py("webgl",()=>new Hf,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ex=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Po{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=Le(t,s),this.enableShapeUniforms=Qt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wo=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Ga{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Le(t,s);const o=this.outputShape.length;this.enableShapeUniforms=Qt(o);let a="";if(r)if(o===0||oe(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Ze(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=on("coords",o);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rn(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const k6={kernelName:Il,backendName:"webgl",kernelFunc:Rn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zr(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,o=t.makeTensorInfo(s.shape,"complex64"),a=t.texData.get(o.dataId),l=Rn({inputs:{x:s},backend:t}),u=Rn({inputs:{x:r},backend:t});return a.complexTensorInfos={real:l,imag:u},o}const N6={kernelName:zd,backendName:"webgl",kernelFunc:Zr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DN="return (a < 0.) ? b * a : a;",AN=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function I6(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:o}=s,a=t.makeTensorInfo([],"float32",ar(o,"float32")),l=J().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ga(AN,r.shape,a.shape):new Po(DN,r.shape,a.shape),u=t.runWebGLProgram(l,[r,a],"float32");return t.disposeIntermediateTensorInfo(a),u}const T6={kernelName:gp,backendName:"webgl",kernelFunc:I6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FN="return (a < 0.) ? b * a : a;",PN=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function E6(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,o=J().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ga(PN,s.shape,r.shape):new Po(FN,s.shape,r.shape);return t.runWebGLProgram(o,[s,r],"float32")}const R6={kernelName:Fp,backendName:"webgl",kernelFunc:E6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ha="if (isnan(x)) return x;";function Be({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:o})=>{const{x:a}=r,l=o,u=s||a.dtype;if(l.shouldExecuteOnCPU([a])&&t!=null){const f=l.texData.get(a.dataId),m=t(f.values,u);return l.makeTensorInfo(a.shape,u,m)}const d=J().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let p;return d?p=new Fr(a.shape,e):p=new Ts(a.shape,n),l.runWebGLProgram(p,[a],u)}}function Ht({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:o}){return({inputs:a,backend:l})=>{const{a:u,b:d}=a,p=l;if(s&&u.dtype==="complex64"){const x=p.texData.get(u.dataId),w=p.texData.get(d.dataId),[v,b]=[[x.complexTensorInfos.real,w.complexTensorInfos.real],[x.complexTensorInfos.imag,w.complexTensorInfos.imag]].map(I=>{const[N,R]=I,D={dataId:N.dataId,dtype:N.dtype,shape:u.shape},F={dataId:R.dataId,dtype:R.dtype,shape:d.shape},V=new Po(n,u.shape,d.shape);return p.runWebGLProgram(V,[D,F],fn(N.dtype,R.dtype))}),C=Zr({inputs:{real:v,imag:b},backend:p});return p.disposeIntermediateTensorInfo(v),p.disposeIntermediateTensorInfo(b),C}const f=o||fn(u.dtype,d.dtype);if((u.dtype==="string"||d.dtype==="string"||p.shouldExecuteOnCPU([u,d]))&&r!=null){const x=p.texData.get(u.dataId).values,w=p.texData.get(d.dataId).values,v=u.dtype==="string"?rr(x):x,b=u.dtype==="string"?rr(w):w,[C,I]=r(u.shape,d.shape,v,b,f),N=p.makeTensorInfo(I,f),R=p.texData.get(N.dataId);return R.values=C,N}const m=J().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let g;return m?g=new Ga(e,u.shape,d.shape,t):g=new Po(n,u.shape,d.shape),p.runWebGLProgram(g,[u,d],f)}}function tl(n,e=!1){if(n==="linear")return e?d6:a6;if(n==="relu")return e?f6:l6;if(n==="elu")return e?p6:i6;if(n==="relu6")return e?h6:u6;if(n==="prelu")return e?PN:FN;if(n==="leakyrelu")return e?AN:DN;if(n==="sigmoid")return e?m6:c6;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LN{constructor(e,t,s,r=!1,o=!1,a=!1,l=null,u=!1,d=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Qt(this.outputShape.length);const p=r?e[1]:e[2],f=Math.ceil(p/2),m=r?"i * 2, rc.y":"rc.y, i * 2",g=o?"rc.z, i * 2":"i * 2, rc.z",x=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],w=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let v="",b="";l&&(u?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${l}
        }`:d?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${l}
        }`:v=`vec4 activation(vec4 x) {
          ${l}
        }`,b="result = activation(result);");const C=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),d&&this.variableNames.push("leakyreluAlpha");let I="rc.x",N="rc.x";e[0]<t[0]?I=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(N=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${v}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${f}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${I};
        int batchB = ${N};
        for (int i = 0; i < ${f}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${g});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${x[0]} * ${w[0]});
          result += (${x[1]} * ${w[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${C}

        ${b}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jw={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class qw{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Le(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kw="return a * b;";function tx(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,o=fn(s.dtype,r.dtype);if(s.dtype==="complex64"){const l=t.texData.get(s.dataId),u=t.texData.get(r.dataId),d=new qw(jw.REAL,s.shape,r.shape),p=new qw(jw.IMAG,s.shape,r.shape),f=[{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],m=t.runWebGLProgram(d,f,"float32"),g=t.runWebGLProgram(p,f,"float32"),x=Zr({inputs:{real:m,imag:g},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),x}if(t.shouldExecuteOnCPU([s,r])){const l=t.texData.get(s.dataId),u=t.texData.get(r.dataId),[d,p]=EH(s.shape,r.shape,l.values,u.values,o),f=t.makeTensorInfo(p,o),m=t.texData.get(f.dataId);return m.values=d,f}let a;return J().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Ga(Kw,s.shape,r.shape):a=new Po(Kw,s.shape,r.shape),t.runWebGLProgram(a,[s,r],o)}const _6={kernelName:zl,backendName:"webgl",kernelFunc:tx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O6(n,e,t){const s=[Da(n.shape),...Aa(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},o=[Da(e),...Aa(e)],a=new ON(o,s),l=!0,u=[s],d=t.runWebGLProgram(a,[r],n.dtype,u,l);return{dataId:d.dataId,shape:e,dtype:d.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:o}=s,a=t,l=oe(r.shape),u=jg(o,l),d=oe(u);O(l===d,()=>`The new shape (${u}) has ${d} elements and the old shape (${r.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`);const p=a.texData.get(r.dataId);return p.isPacked&&!$d(r.shape,u)&&!(p.texture!==null&&$d(p.shape,u))?O6(r,u,a):(a.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}const D6={kernelName:Wp,backendName:"webgl",kernelFunc:ge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xw{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:a}=e;this.outputShape=[r,a];const l=Math.floor(s/4)*4,u=s%4;let d="sumValue += dot(values, ones);";if(t!=null){const f=1/t;d=`sumValue += dot(values * ${No(f)?f.toPrecision(2):f}, ones);`}let p="";o%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${l};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${d}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${d}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${d}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A6{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:a}=e;this.outputShape=[r,a];let l="0.0",u="";t==="prod"?l="1.0":t==="min"?(l="1.0 / 1e-20",u="min"):t==="max"&&(l="-1.0 / 1e-20",u="max");let d=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?d="sumValue":t==="prod"?d="prodValue":t==="all"?d="allValue":t==="any"&&(d="anyValue");const p=Math.floor(s/4)*4,f=s%4;let m=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,g="vec4";t==="all"?(l="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,g="bvec4"):t==="any"&&(l="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,g="bvec4");let x="";o%s>0&&(x=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${l};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${x}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${l});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${p};
        if (${f===1}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${f===2}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${f===3}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${d});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F6(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=zf(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Uo(n,e,t,s){const r=F6(n.shape);let o=n;for(let a=0;a<r.length;a++){const{inSize:l,windowSize:u,outSize:d}=r[a];let p,f;t==="mean"?p=a===0?new Xw({windowSize:u,inSize:l,batchSize:n.shape[0],outSize:d},l):new Xw({windowSize:u,inSize:l,batchSize:n.shape[0],outSize:d}):p=new A6({windowSize:u,inSize:l,batchSize:n.shape[0],outSize:d},t),f=o,o=s.runWebGLProgram(p,[o],e),f.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(f)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class P6{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[t[a]];this.outputShape=s,this.rank=s.length;const r=Ze(this.rank),o=L6(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function L6(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V6{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let p=0;p<s.length;p++)s[p]=e[t[p]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Ze(this.rank),o=_N("rc",this.rank),a=new Array(this.rank);for(let p=0;p<t.length;p++)a[t[p]]=o[p];const l=`vec2(${a.slice(-2).join()})`,u=`++${o[this.rank-1]} < ${s[this.rank-1]}`,d=`getChannel(getA(${a.join()}), ${l})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${d};
      if(${u}) {
        result[1] = ${d};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${d};
        if(${u}) {
          result[3] = ${d};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jf(n,e,t){const s=J().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new V6(n.shape,e):new P6(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B6(n,e,t,s){const r=e,o=n.shape.length,a=Me(r,n.shape);let l=a;const u=wt(l,o),d=u!=null;let p=n;d&&(p=jf(n,u,s),l=bt(l.length,o)),Ut("sum",l,o);const[f,m]=Wt(p.shape,l);let g=f;t&&(g=It(f,a));const x=oe(m),v=oe(n.shape)/x,b=ge({inputs:{x:p},attrs:{shape:[v,x]},backend:s}),C=vf(n.dtype),I=Uo(b,C,"sum",s),N=ge({inputs:{x:I},attrs:{shape:g},backend:s});return s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(I),d&&s.disposeIntermediateTensorInfo(p),N}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qf(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s;return B6(r,o,a,t)}const M6={kernelName:Qp,backendName:"webgl",kernelFunc:qf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ln(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:o}=s,a=t,l=r.shape.length,u=new Array(l);for(let p=0;p<u.length;p++)u[p]=r.shape[o[p]];let d;if(a.shouldExecuteOnCPU([r])){const f=a.texData.get(r.dataId).values,m=J0(f,r.shape,r.dtype,o,u);d=a.makeTensorInfo(u,r.dtype);const g=a.texData.get(d.dataId);g.values=m}else d=jf(r,o,a);return d}const z6={kernelName:ya,backendName:"webgl",kernelFunc:ln};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VN=1e3;function Sd({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:o=null,preluActivationWeights:a=null,leakyreluAlpha:l=0,activation:u=null}){const d=n.shape.length,p=e.shape.length,f=t?n.shape[d-2]:n.shape[d-1],m=s?e.shape[p-1]:e.shape[p-2],g=t?n.shape[d-1]:n.shape[d-2],x=s?e.shape[p-2]:e.shape[p-1],w=n.shape.slice(0,-2),v=e.shape.slice(0,-2),b=oe(w),C=oe(v),N=Le(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,x]);O(f===m,()=>`Error in matMul: inner shapes (${f}) and (${m}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const R=t?[b,f,g]:[b,g,f],D=s?[C,x,m]:[C,m,x],F=ge({inputs:{x:n},backend:r,attrs:{shape:R}}),V=ge({inputs:{x:e},backend:r,attrs:{shape:D}}),P=[F,V],A=Math.max(b,C),T=t?F.shape[1]:F.shape[2],W=o!=null,j=a!=null,Y=u==="leakyrelu",Q=u!=null?tl(u,!0):null,Z=W||j||Y||Q!=null;let ne;if((g===1||x===1)&&T>VN&&Z===!1){let K=F,X=V;t&&(K=ln({inputs:{x:F},backend:r,attrs:{perm:[0,2,1]}}),P.push(K)),s&&(X=ln({inputs:{x:V},backend:r,attrs:{perm:[0,2,1]}}),P.push(X));const L=x!==1,H=x===1;let re=K;L&&(re=ge({inputs:{x:K},backend:r,attrs:{shape:[A,T,1]}}),P.push(re));const ae=x===1?2:1;let ie=X;H&&(ie=ge({inputs:{x:X},backend:r,attrs:{shape:[A,1,T]}}),P.push(ie));const ue=tx({inputs:{a:re,b:ie},backend:r});ne=qf({inputs:{x:ue},backend:r,attrs:{axis:ae,keepDims:!0}}),P.push(ue)}else{const K=fn(n.dtype,e.dtype),X=new LN(R,D,[A,g,x],t,s,W,Q,j,Y),L=[F,V];if(o!=null&&L.push(o),j&&L.push(a),Y){const H=r.makeTensorInfo([],"float32",ar(l,"float32"));L.push(H),P.push(H)}ne=r.runWebGLProgram(X,L,K)}const U=ge({inputs:{x:ne},backend:r,attrs:{shape:N}});P.push(ne);for(const K of P)r.disposeIntermediateTensorInfo(K);return U}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W6(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o,bias:a,preluActivationWeights:l}=e,{transposeA:u,transposeB:d,activation:p,leakyreluAlpha:f}=s;return Sd({a:r,b:o,transposeA:u,transposeB:d,backend:t,bias:a,preluActivationWeights:l,leakyreluAlpha:f,activation:p})}const U6={kernelName:Bi,backendName:"webgl",kernelFunc:W6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yw="return abs(x);";function G6(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const o=t.texData.get(s.dataId),a=EN(o.values);return t.makeTensorInfo(s.shape,s.dtype,a)}let r;return J().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Fr(s.shape,Yw):r=new Ts(s.shape,Yw),t.runWebGLProgram(r,[s],s.dtype)}const H6={kernelName:Ed,backendName:"webgl",kernelFunc:G6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j6=ns+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,q6=Be({opSnippet:j6}),K6={kernelName:rl,backendName:"webgl",kernelFunc:q6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X6=ns+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Y6=Be({opSnippet:X6}),Q6={kernelName:ol,backendName:"webgl",kernelFunc:Y6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qw="return a + b;",Z6=Ht({opSnippet:Qw,packedOpSnippet:Qw,supportsComplex:!0,cpuKernelImpl:lH}),J6={kernelName:Fa,backendName:"webgl",kernelFunc:Z6};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ej{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((o,a)=>`T${a}`);const s=[];this.variableNames.forEach(o=>{s.push(`float v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tj{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((o,a)=>`T${a}`);const s=[];this.variableNames.forEach(o=>{s.push(`vec4 v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rd(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Rn({inputs:{x:s[0]},backend:t});if(s.length>J().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(s.length/2),d=rd({inputs:s.slice(0,u),backend:t}),p=rd({inputs:s.slice(u),backend:t});return rd({inputs:[d,p],backend:t})}const r=s.map(u=>u.dtype).reduce((u,d)=>fn(u,d)),o=s.map(u=>u.shape),l=J().getBool("WEBGL_PACK")?new tj(s[0].shape,o):new ej(s[0].shape,o);return t.runWebGLProgram(l,s,r)}const nj={kernelName:Rd,backendName:"webgl",kernelFunc:rd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,l=r.shape.length,u=Me(o,r.shape);let d=u;const p=wt(d,l);let f=r;p!=null&&(f=ln({inputs:{x:r},backend:t,attrs:{perm:p}}),d=bt(d.length,l)),Ut("all",d,l);const[m,g]=Wt(f.shape,d),x=oe(g),w=ge({inputs:{x:f},backend:t,attrs:{shape:[-1,x]}}),v=Uo(w,w.dtype,"all",t);let b;if(a){const C=It(m,u);b=ge({inputs:{x:v},backend:t,attrs:{shape:C}})}else b=ge({inputs:{x:v},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(v),p!=null&&t.disposeIntermediateTensorInfo(f),b}const rj={kernelName:_d,backendName:"webgl",kernelFunc:sj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,l=r.shape.length,u=Me(o,r.shape);let d=u;const p=wt(d,l);let f=r;p!=null&&(f=ln({inputs:{x:r},backend:t,attrs:{perm:p}}),d=bt(d.length,l)),Ut("any",d,l);const[m,g]=Wt(f.shape,d),x=oe(g),w=ge({inputs:{x:f},backend:t,attrs:{shape:[-1,x]}}),v=Uo(w,w.dtype,"any",t);let b;if(a){const C=It(m,u);b=ge({inputs:{x:v},backend:t,attrs:{shape:C}})}else b=ge({inputs:{x:v},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(v),p!=null&&t.disposeIntermediateTensorInfo(f),b}const aj={kernelName:Od,backendName:"webgl",kernelFunc:oj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ij{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:o,outSize:a}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[o,a];const l=t==="max"?">":"<",u=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${l} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lj{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,O(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],a=Math.ceil(o/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const l=this.outputShape,u=l.length,d=Ze(u),p=on("coords",u);let f,m;if(a===1){m=u+1;const V=Ze(m);f=`
        ${V} sourceLocR = ${V}(${p.join()}, 0);
        ++${p[u-1]};
        ${V} sourceLocG = ${V}(${p.join()}, 0);
        ++${p[u-2]};
        ${V} sourceLocA = ${V}(${p.join()}, 0);
        --${p[u-1]};
        ${V} sourceLocB = ${V}(${p.join()}, 0);
        --${p[u-2]};`}else m=u,f=`
        ${d} sourceLocR = coords;
        ++${p[u-1]};
        ${d} sourceLocG = coords;
        ++${p[u-2]};
        ${d} sourceLocA = coords;
        --${p[u-1]};
        ${d} sourceLocB = coords;
        --${p[u-2]};`;const g=["x","y","z","w","u","v"].slice(0,m),x="."+g[m-1],w=g.map(V=>"int "+V),v=on("sourceLocR",m-1).concat("inIdx.r"),b=on("sourceLocG",m-1).concat("inIdx.g"),C=on("sourceLocB",m-1).concat("inIdx.b"),I=on("sourceLocA",m-1).concat("inIdx.a"),N=s==="max"?"greaterThan":"lessThan",R=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${C.join()}),
                             getBestIndicesAChannel(${I.join()})));`,D=`vec4(
            getAChannel(${v.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${C.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${I.join()}) : 0.)`,F=r?"":`
      float getBestIndicesAChannel(${w.join()}) {
        return getChannel(getBestIndicesA(${g.join()}),
                                          vec2(${g.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${w.join()}) {
        return getChannel(getA(${g.join()}),
                               vec2(${g.slice(-2).join()}));
      }
      ${F}
      void main() {
        ${d} coords = getOutputCoords();
        bool hasNextCol = ${p[u-1]} < ${l[u-1]-1};
        bool hasNextRow = ${p[u-2]} < ${l[u-2]-1};
        ${f}
        ivec4 srcIdx = ivec4(sourceLocR${x}, sourceLocG${x},
          sourceLocB${x}, sourceLocA${x}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${D};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${R}
          vec4 candidate = ${D};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${N}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BN(n,e,t,s=null){let r=e.shape[0],o=e.shape[1];s!=null&&(r=s.shape[0],o=s.shape[1]);const a=zf(o),l={windowSize:a,inSize:o,batchSize:r,outSize:Math.ceil(o/a)},u=new ij(l,t,s==null),d=[e];s!=null&&d.push(s);const p=n.runWebGLProgram(u,d,"int32");if(p.shape[1]===1)return p;const f=BN(n,e,t,p);return n.disposeIntermediateTensorInfo(p),f}function MN(n,e,t,s=null){const r=s!=null?s.shape:e.shape,o=r[r.length-1],a=zf(o),l=new lj(r,a,t,s==null),u=s==null?[e]:[e,s],d=n.runWebGLProgram(l,u,"int32");if(d.shape.length===e.shape.length){const p=MN(n,e,t,d);return n.disposeIntermediateTensorInfo(d),p}return d}function zN(n,e,t,s){const r=[t];if(Ut("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!J().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],a=n.texData.get(e.dataId),l=a!==null&&a.isPacked;let u=e;l&&(u=n.unpackTensor(e),o.push(u));const[d,p]=Wt(u.shape,r),f=oe(p),m=ge({inputs:{x:u},backend:n,attrs:{shape:[-1,f]}});o.push(m);const g=BN(n,m,s);o.push(g);const x=ge({inputs:{x:g},backend:n,attrs:{shape:d}});return o.forEach(w=>n.disposeIntermediateTensorInfo(w)),x}return MN(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let a=Me(o,r.shape);const l=wt(a,r.shape.length);let u=r;const d=[];l!=null&&(u=ln({inputs:{x:r},backend:t,attrs:{perm:l}}),d.push(u),a=bt(a.length,u.shape.length)),Ut("argMax",[a[0]],u.shape.length);const p=zN(t,u,a[0],"max");return d.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const cj={kernelName:Dd,backendName:"webgl",kernelFunc:uj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let a=Me(o,r.shape);const l=wt(a,r.shape.length);let u=r;const d=[];l!=null&&(u=ln({inputs:{x:r},backend:t,attrs:{perm:l}}),d.push(u),a=bt(a.length,u.shape.length)),Ut("argMin",[a[0]],u.shape.length);const p=zN(t,u,a[0],"min");return d.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const pj={kernelName:Ad,backendName:"webgl",kernelFunc:dj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fj=ns+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,hj=Be({opSnippet:fj}),mj={kernelName:al,backendName:"webgl",kernelFunc:hj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gj=ns+"return log(x + sqrt(x * x + 1.0));",yj=Be({opSnippet:gj}),xj={kernelName:il,backendName:"webgl",kernelFunc:yj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vj=ns+`
  return atan(x);
`,wj=Be({opSnippet:vj}),bj={kernelName:ll,backendName:"webgl",kernelFunc:wj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $j=ex+`
  return atan(a, b);
`,Sj=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Wo+`
  return result;
`,Cj=Ht({opSnippet:$j,packedOpSnippet:Sj}),kj={kernelName:cl,backendName:"webgl",kernelFunc:Cj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nj=ns+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Ij=Be({opSnippet:Nj}),Tj={kernelName:ul,backendName:"webgl",kernelFunc:Ij};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nl{constructor(e,t,s,r=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,l=e.strideHeight,u=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,f=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const w=t==="avg",v=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,b=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let C="0.0";if(w||(C="-1.0 / 1e-20"),s){const V=">=";this.userCode=`
        const ivec2 strides = ivec2(${l}, ${u});
        const ivec2 pads = ivec2(${g}, ${x});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${f};
              wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${p}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${V} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?o?v:b:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const I="max";let N=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(N="avgValue / max(count, 1.0)");const R=Math.floor(a/4)*4,D=a%4,F=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${g}, ${x});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${f};
            wR += ${d}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${R}; wC += 4) {
            int xC = xCCorner + wC * ${p};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              getValue(batch, xR, xC + 3 * ${p}, d)
            );

            ${F}
          }

          int xC = xCCorner + ${R};
          if (${D===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${D===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${D===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              initializationValue
            );

            ${F}
          }
        }
        setOutput(${N});
      }
    `}}class nx{constructor(e,t,s,r=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,l=e.strideDepth,u=e.strideHeight,d=e.strideWidth,p=e.dilationDepth,f=e.dilationHeight,m=e.dilationWidth,g=e.effectiveFilterDepth,x=e.effectiveFilterHeight,w=e.effectiveFilterWidth,v=e.padInfo.front,b=e.padInfo.top,C=e.padInfo.left;this.outputShape=e.outShape;const I=t==="avg";let N="0.0";if(I||(N="-1.0 / 1e-20"),s){const A=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${l}, ${u}, ${d});
        const ivec3 pads = ivec3(${v}, ${b}, ${C});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${g};
              wD += ${p}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${x};
                wR += ${f}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${w};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${A} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${x} * ${w} +
                      wR * ${w} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const R="max";let D=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(D="avgValue / max(count, 1.0)");const F=Math.floor(a/4)*4,V=a%4,P=`
      if (${I}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${R}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${l}, ${u}, ${d});
      const ivec3 pads = ivec3(${v}, ${b}, ${C});
      const float initializationValue = ${N};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${N});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${g};
            wD += ${p}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${x};
            wR += ${f}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${F}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${P}
            }

            int xC = xCCorner + ${F};
            if (${V===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${P}
            } else if (${V===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${P}
            } else if (${V===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${P}
            }
          }
        }
        setOutput(${D});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ej(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Cu(r,"avgPool");const{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=s,d=1;O(Yt(a,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const p=es(r.shape,o,a,d,l,u);if(p.filterWidth===1&&p.filterHeight===1&&Qe(p.inShape,p.outShape))return Rn({inputs:{x:r},backend:t});const f=new nl(p,"avg",!1);return t.runWebGLProgram(f,[r],"float32")}const Rj={kernelName:Fd,backendName:"webgl",kernelFunc:Ej};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _j(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u,dataFormat:d}=s,p=[1,1,1],f=ir(r.shape,o,a,p,l,u,d),m=new nx(f,"avg",!1);return t.runWebGLProgram(m,[r],"float32")}const Oj={kernelName:Pd,backendName:"webgl",kernelFunc:_j};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dj{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=u-1-e.padInfo.top,f=d-1-e.padInfo.left,m=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${p}, ${f});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${d};
            wC+= ${l}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class Aj{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,a=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,d=e.dilationHeight,p=e.dilationWidth,f=e.effectiveFilterDepth,m=e.effectiveFilterHeight,g=e.effectiveFilterWidth,x=f-1-e.padInfo.front,w=m-1-e.padInfo.top,v=g-1-e.padInfo.left,b=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${x}, ${w}, ${v});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${d}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${g};
                wC += ${p}) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fj(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,a=o,{filterSize:l,strides:u,pad:d,dimRoundingMode:p}=s,f=[1,1,1],m=ir(a.shape,l,u,f,d,p),g=new Aj(m);return t.runWebGLProgram(g,[r],a.dtype)}const Pj={kernelName:Zg,backendName:"webgl",kernelFunc:Fj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lj(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,a=o;Cu([r,o],"avgPoolGrad");const{filterSize:l,strides:u,pad:d}=s,p=es(a.shape,l,u,1,d),f=new Dj(p);return t.runWebGLProgram(f,[r],a.dtype)}const Vj={kernelName:Qg,backendName:"webgl",kernelFunc:Lj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bj(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o}=e,{transposeA:a,transposeB:l}=s;return Sd({a:r,b:o,transposeA:a,transposeB:l,backend:t})}const Mj={kernelName:Ld,backendName:"webgl",kernelFunc:Bj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zj{constructor(e,t,s,r,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Le(e,t),Le(e,s);let l="0.0";r!=null&&(Le(e,r),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let u="1.0";o!=null&&(Le(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${l};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wj{constructor(e,t,s,r,o,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Le(e,t),Le(e,s);let l="vec4(0.0)";r!=null&&(Le(e,r),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let u="vec4(1.0)";o!=null&&(Le(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${l};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uj=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:o,offset:a,scale:l}=n;O(r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(l==null||r.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);const d=[s,r,o];let p=null;a!=null&&(p=a.shape,d.push(a));let f=null;l!=null&&(f=l.shape,d.push(l));const m=J().getBool("WEBGL_PACK_NORMALIZATION")?new Wj(s.shape,r.shape,o.shape,p,f,u):new zj(s.shape,r.shape,o.shape,p,f,u);return e.runWebGLProgram(m,d,d[0].dtype)},Gj={kernelName:dp,backendName:"webgl",kernelFunc:Uj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hj{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Ze(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=jj(this.rank);let r;const o=e.map((a,l)=>`sourceLoc.${Mg[l]} = start[${l}] + coords.${Mg[l]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const Mg=["x","y","z","w","u","v"];function jj(n){if(n===1)return"sourceLoc";if(n<=6)return Mg.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qj{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Ze(this.rank),s=on("coords",this.rank),r=on("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${o})`,l=`
      result.x = ${a};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,d=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((p,f)=>`start[${f}]`).join()});`:e.map((p,f)=>`${r[f]} = ${s[f]} + start[${f}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${d}
        vec4 result = vec4(0.);
        ${l}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kj(n,e,t,s){const r=s.texData.get(n.dataId),o=s.makeTensorInfo(t,n.dtype),a=s.texData.get(o.dataId);Object.assign(a,r),a.refCount=1,a.shape=t,a.dtype=n.dtype;let l=f0(e,Ie(n.shape));r.slice&&(l+=r.slice.flatOffset),a.slice={flatOffset:l,origDataId:r.slice&&r.slice.origDataId||n.dataId};const u=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,u+1),o}function ja(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,size:a}=s,[l,u]=h0(r,o,a);if(c0(r,l,u),oe(u)===0)return t.makeTensorInfo(u,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const f=t.texData.get(r.dataId),m=MH(f.values,l,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,m)}const{isPacked:d}=t.texData.get(r.dataId),p=p0(r.shape,l,u);if(d||!p){const f=J().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qj(u):new Hj(u),m=[l];return t.runWebGLProgram(f,[r],r.dtype,m)}return t.uploadToGPU(r.dataId),Kj(r,l,u,t)}const Xj={kernelName:Yp,backendName:"webgl",kernelFunc:ja};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yj=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,crops:a}=s;O(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const l=o.reduce((C,I)=>C*I),u=vu(r.shape,o,l),d=wu(u.length,o.length),p=bu(r.shape,o,l),f=v0(a,o.length),m=w0(p,a,o.length),g=[],x=ge({inputs:{x:r},backend:t,attrs:{shape:u}}),w=ln({inputs:{x},backend:t,attrs:{perm:d}}),v=ge({inputs:{x:w},backend:t,attrs:{shape:p}}),b=ja({inputs:{x:v},backend:t,attrs:{begin:f,size:m}});return g.push(x),g.push(w),g.push(v),g.forEach(C=>t.disposeIntermediateTensorInfo(C)),b},Qj={kernelName:Vd,backendName:"webgl",kernelFunc:Yj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:a}=s,l=t.readSync(r.dataId),u=t.readSync(o.dataId),d=TN(l,u,o.dtype,o.shape,a);return t.makeTensorInfo([a],o.dtype,d)}const Jj={kernelName:Bd,backendName:"webgl",kernelFunc:Zj};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e5=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,t5=`
  return float(int(a.r) & int(b.r));
`;function n5(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,o=J().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=J().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||a===1){const u=t.texData.get(s.dataId).values,d=t.texData.get(r.dataId).values,[p,f]=cH(s.shape,r.shape,u,d,s.dtype),m=t.makeTensorInfo(f,s.dtype),g=t.texData.get(m.dataId);return g.values=p,m}let l;return o?l=new Ga(e5,s.shape,r.shape,!1):l=new Po(t5,s.shape,r.shape),t.runWebGLProgram(l,[s,r],s.dtype)}const s5={kernelName:dl,backendName:"webgl",kernelFunc:n5};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r5(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,o=t.readSync(s.dataId),a=t.readSync(r.dataId),l=Le(Array.from(o),Array.from(a));return t.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const o5={kernelName:Md,backendName:"webgl",kernelFunc:r5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a5="return float(a != b);",WN=Ht({opSnippet:a5,cpuKernelImpl:_H,dtype:"bool"}),i5={kernelName:Wl,backendName:"webgl",kernelFunc:WN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nu(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Rn({inputs:{x:r.complexTensorInfos.real},backend:t})}const l5={kernelName:zp,backendName:"webgl",kernelFunc:Nu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u5="return float(int(x));";function c5(n,e){const t=new Ts(n.shape,u5),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zg(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return Rn({inputs:{x:r},backend:t});const a=Wr(r.shape),l=zg({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),u=Zr({inputs:{real:l,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(l),u}if(r.dtype==="complex64"){const a=Nu({inputs:{input:r},backend:t}),l=zg({inputs:{x:a},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(a),l}if(!qg(r.dtype,o)){const a=Rn({inputs:{x:r},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(t.shouldExecuteOnCPU([r])){const a=t.texData.get(r.dataId).values,[l,u,d]=dH(a,r.shape,r.dtype,o);return t.makeTensorInfo(l,u,d)}if(o==="int32")return c5(r,t);if(o==="bool"){const a=t.makeTensorInfo([],"bool",Dt("bool",1)),u=WN({inputs:{a:r,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${o}`)}const d5={kernelName:pl,backendName:"webgl",kernelFunc:zg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zw="return ceil(x);",p5=Be({opSnippet:Zw,packedOpSnippet:Zw,cpuKernelImpl:pH}),f5={kernelName:fl,backendName:"webgl",kernelFunc:p5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h5{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m5{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:o,clipValueMax:a}=s;let l;J().getBool("WEBGL_PACK_CLIP")?l=new m5(r.shape):l=new h5(r.shape);const u=[[o],[a]];return t.runWebGLProgram(l,[r],r.dtype,u)}const y5={kernelName:hl,backendName:"webgl",kernelFunc:g5};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x5{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jw(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function v5(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),o=new x5(s.shape),a=[Jw(s,r.complexTensorInfos.real),Jw(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(o,a,a[0].dtype)}const w5={kernelName:Wd,backendName:"webgl",kernelFunc:v5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b5{constructor(e){this.outputShape=[],this.outputShape=Rs(e,1),this.variableNames=e.map((a,l)=>`T${l}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const l=t[a-1];s.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${l}));`)}const r=t.length,o=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $5{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Rs(e,t);const s=this.outputShape,r=s.length,o=Ze(r),a=on("coords",r),l=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((w,v)=>`T${v}`);const u=new Array(e.length-1);u[0]=e[0][t];for(let w=1;w<u.length;w++)u[w]=u[w-1]+e[w][t];const d=l[t],p=l.slice(-2),f=l.join();let m=`if (${d} < ${u[0]}) {
        return getChannel(
            getT0(${f}), vec2(${p.join()}));
        }`;for(let w=1;w<u.length;w++){const v=u[w-1];m+=`
        if (${d} < ${u[w]}  && ${d} >= ${u[w-1]}) {
          return getChannel(
            getT${w}(${qc(l,d,v)}),
            vec2(${qc(p,d,v)}));
        }`}const g=u.length,x=u[u.length-1];m+=`
        return getChannel(
          getT${g}(${qc(l,d,x)}),
          vec2(${qc(p,d,x)}));`,this.userCode=`
      float getValue(${l.map(w=>"int "+w)}) {
        ${m}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${s[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${s[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${s[r-2]} &&
            ${a[r-1]} < ${s[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function qc(n,e,t){const s=n.indexOf(e);return n.map((o,a)=>a===s?`${o} - ${t}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kf(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Rn({inputs:{x:r.complexTensorInfos.imag},backend:t})}const S5={kernelName:mp,backendName:"webgl",kernelFunc:Kf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Li(n,e,t){const s=n[0].dtype;if(s==="complex64"){const g=n.map(C=>Nu({inputs:{input:C},backend:t})),x=n.map(C=>Kf({inputs:{input:C},backend:t})),w=Li(g,e,t),v=Li(x,e,t),b=Zr({inputs:{real:w,imag:v},backend:t});return g.forEach(C=>t.disposeIntermediateTensorInfo(C)),x.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(v),b}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const g=n.map(N=>{const D=[-1,oe(N.shape.slice(e))];return ge({inputs:{x:N},backend:t,attrs:{shape:D}})}),x=g.map(N=>({vals:t.readSync(N.dataId),shape:N.shape})),w=Rs(g.map(N=>N.shape),1),v=g[0].shape[0]===1,b=fH(x,w,s,v),C=Rs(n.map(N=>N.shape),e),I=t.makeTensorInfo(C,s,b);return g.forEach(N=>t.disposeIntermediateTensorInfo(N)),I}const o=n.filter(g=>oe(g.shape)>0),a=J().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(o.length===1){const g=a?new Ts(n[0].shape,_r):new Fr(n[0].shape,_r);return t.runWebGLProgram(g,n,s)}const l=J().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>l){const g=[];for(let w=0;w<o.length;w+=l){const v=o.slice(w,w+l);g.push(Li(v,e,t))}const x=Li(g,e,t);for(const w of g)t.disposeIntermediateTensorInfo(w);return x}if(a){const g=new $5(o.map(x=>x.shape),e);return t.runWebGLProgram(g,o,s)}const{tensors2D:u,outShape:d}=C5(o,e,t),p=new b5(u.map(g=>g.shape)),f=t.runWebGLProgram(p,u,s);u.forEach(g=>t.disposeIntermediateTensorInfo(g));const m=ge({inputs:{x:f},attrs:{shape:d},backend:t});return t.disposeIntermediateTensorInfo(f),m}function C5(n,e,t){const s=Rs(n.map(o=>o.shape),e);return{tensors2D:n.map(o=>ge({inputs:{x:o},attrs:{shape:[-1,oe(o.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UN(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,o=Me(r,e[0].shape)[0],a=e.map(d=>d.shape);g0(a,o);const l=Rs(e.map(d=>d.shape),o);if(oe(l)===0)return t.makeTensorInfo(l,e[0].dtype,[]);const u=e.filter(d=>oe(d.shape)>0);return u.length===1?Rn({inputs:{x:u[0]},backend:t}):Li(u,o,t)}const k5={kernelName:Ud,backendName:"webgl",kernelFunc:UN};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GN{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,l=e.padInfo.left,u=e.strideHeight,d=e.strideWidth,p=e.dilationHeight,f=e.dilationWidth,m=e.filterHeight,g=e.filterWidth,x=Math.floor(e.inChannels/4)*4,w=e.inChannels%4,v=e.dataFormat==="channelsLast",b=v?1:2,C=v?2:3,I=v?3:1;let N="",R="";s&&(r?N=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?N=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:N=`
          float activation(float x) {
            ${s}
          }
        `,R="result = activation(result);");const D=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${N}

      const ivec2 strides = ivec2(${u}, ${d});
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${I}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${C}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${p};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${g}; wC++) {
            int xC = xCCorner + wC * ${f};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${x}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${v}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${w===1}) {

              if (${v}) {
                dotProd +=
                    getX(batch, xR, xC, ${x}) *
                    getW(wR, wC, ${x}, d2);
              } else {
                dotProd +=
                    getX(batch, ${x}, xR, xC) *
                    getW(wR, wC, ${x}, d2);
              }

            } else if (${w===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${x}, d2),
                getW(wR, wC, ${x} + 1, d2)
              );

              if (${v}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${x}),
                  getX(batch, xR, xC, ${x} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${x}, xR, xC),
                  getX(batch, ${x} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${w===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${x}, d2),
                getW(wR, wC, ${x} + 1, d2),
                getW(wR, wC, ${x} + 2, d2)
              );

              if (${v}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${x}),
                  getX(batch, xR, xC, ${x} + 1),
                  getX(batch, xR, xC, ${x} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${x}, xR, xC),
                  getX(batch, ${x} + 1, xR, xC),
                  getX(batch, ${x} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${D}
        ${R}
        setOutput(result);
      }
    `}}class N5{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,o=e.strideDepth,a=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,d=e.dilationHeight,p=e.dilationWidth,f=e.filterDepth,m=e.filterHeight,g=e.filterWidth,x=Math.floor(e.inChannels/4)*4,w=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${a}, ${l});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${f}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${d};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${g}; wC++) {
              int xC = xCCorner + wC * ${p};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${x}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${w===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${x}) *
                  getW(wF, wR, wC, ${x}, d2);
              } else if (${w===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${x}),
                  getX(batch, xF, xR, xC, ${x} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${x}, d2),
                  getW(wF, wR, wC, ${x} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${w===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${x}),
                  getX(batch, xF, xR, xC, ${x} + 1),
                  getX(batch, xF, xR, xC, ${x} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${x}, d2),
                  getW(wF, wR, wC, ${x} + 1, d2),
                  getW(wF, wR, wC, ${x} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HN{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Qt(this.outputShape.length);const a=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,f=p;let m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<p;v++)m+=`
           vec4 xTexelC${v*2};
           int xTexelC${v*2}Ready;
           vec4 xTexelC${v*2+1};
           int xTexelC${v*2+1}Ready;
           vec4 xC${v};`;m+=`
     for (int r = 0; r < ${d}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let v=0;v<p;v++)m+=`
           xTexelC${v*2} = vec4(0.0);
           xTexelC${v*2}Ready = 0;
           xTexelC${v*2+1} = vec4(0.0);
           xTexelC${v*2+1}Ready = 0;
           xC${v} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let v=0;v<(f+1)/2;v++){const b=v*2;if(m+=`
           xC = xCCorner + ${b*u};
           `,l===1){if(b<p&&(a%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,u===1&&b>0?m+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<p)){const C=a%2===0?Id(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${C};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,u>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:m+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):C===1?m+=`
                     xC${b+1} = xTexelC${b};
                     `:m+=`
                     xCOffset = xC + ${C};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<p&&(a%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<p&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<p&&(m+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<p&&(m+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<p&&(m+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let g="",x="";s&&(r?g=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:o?g=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:g=`vec4 activation(vec4 x) {
           ${s}
         }`,x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${g}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${w}
         ${x}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I5{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Qt(this.outputShape.length);const{dataFormat:s}=t,r=un(),o=s==="channelsLast",a=o?1:2,l=o?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let d="";for(let p=0;p<=1;p++)for(let f=0;f<=1;f++)d+=`
          blockIndex = rc.z + ${f};
          pos = rc.y + ${p};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${l}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${p*2+f}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${p*2+f}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${d}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cd(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function jN({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const u=n.shape,d=s.texData.get(n.dataId),p=t.inChannels,f=u[0]*u[1]*u[2],m=t.outChannels,g=t.dataFormat==="channelsLast",x=!1,w=!1;let v;const b=[];if(o!=null){const N=Cd(o.shape,g);N!=null&&(o=ge({inputs:{x:o},backend:s,attrs:{shape:N}}),b.push(o))}if(r!=null){const N=Cd(r.shape,g);N!=null&&(r=ge({inputs:{x:r},backend:s,attrs:{shape:N}}),b.push(r))}if(!((f===1||m===1)&&p>VN)&&d.isPacked&&g&&d.texture!=null&&u[2]%2!==0&&Qe(d.shape.slice(-3),u.slice(-3))){const N=u[0]*u[1]*(u[2]+1),R={dataId:n.dataId,shape:[1,N,t.inChannels],dtype:n.dtype},D=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,O($d(d.shape,R.shape),()=>`packed reshape ${d.shape} to ${R.shape} isn't free`);const F=ge({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});b.push(F);const V=Sd({a:R,b:F,backend:s,transposeA:x,transposeB:w,bias:r,activation:l,preluActivationWeights:o,leakyreluAlpha:a}),P=s.texData.get(V.dataId);O(P.isPacked,()=>"batchMatMul result is expected to be packed"),d.shape=D,P.shape=t.outShape,v=Rn({inputs:{x:V},backend:s}),v.shape=t.outShape,b.push(V)}else{const N=t.outHeight*t.outWidth,R=ge({inputs:{x:n},backend:s,attrs:{shape:g?[t.batchSize,N,t.inChannels]:[t.batchSize,t.inChannels,N]}}),D=ge({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),F=Sd({a:g?R:D,b:g?D:R,transposeA:!g,transposeB:w,backend:s,bias:r,activation:l,preluActivationWeights:o,leakyreluAlpha:a});v=ge({inputs:{x:F},backend:s,attrs:{shape:t.outShape}}),b.push(R),b.push(D),b.push(F)}for(const N of b)s.disposeIntermediateTensorInfo(N);return v}function qN({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const{filterWidth:u,filterHeight:d,inChannels:p,outWidth:f,outHeight:m,dataFormat:g}=t,x=g==="channelsLast",w=u*d*p,v=m*f,b=[t.batchSize,w,v],C=!0,I=!1,N=[];if(o!=null){const U=Cd(o.shape,x);U!=null&&(o=ge({inputs:{x:o},backend:s,attrs:{shape:U}}),N.push(o))}if(r!=null){const U=Cd(r.shape,x);U!=null&&(r=ge({inputs:{x:r},backend:s,attrs:{shape:U}}),N.push(r))}const R=ge({inputs:{x:e},backend:s,attrs:{shape:[1,w,oe(e.shape)/w]}});N.push(R);const D=new I5(b,t),F=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],V=s.runWebGLProgram(D,[n],"float32",F),P=ge({inputs:{x:V},backend:s,attrs:{shape:b}});N.push(V),N.push(P);const A=r!=null,T=o!=null,W=l==="leakyrelu",j=l?tl(l,!0):null,Y=new LN(x?P.shape:R.shape,x?R.shape:P.shape,x?[t.batchSize,v,t.outChannels]:[t.batchSize,t.outChannels,v],C,I,A,j,T,W),Q=x?[P,R]:[R,P];if(r&&Q.push(r),T&&Q.push(o),W){const U=s.makeTensorInfo([],"float32",ar(a,"float32"));Q.push(U),N.push(U)}const Z=s.runWebGLProgram(Y,Q,"float32"),ne=ge({inputs:{x:Z},backend:s,attrs:{shape:t.outShape}});N.push(Z);for(const U of N)s.disposeIntermediateTensorInfo(U);return ne}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:l,dataFormat:u,dilations:d,dimRoundingMode:p}=s,f=lr(u),m=At(r.shape,o.shape,a,d,l,p,!1,f);let g;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))g=jN({x:r,filter:o,convInfo:m,backend:t});else if(m.strideWidth<=2&&f==="channelsLast"&&J().getBool("WEBGL_EXP_CONV")){const w=new HN(m),v=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];g=t.runWebGLProgram(w,[r,o],"float32",v)}else if(J().getBool("WEBGL_CONV_IM2COL"))g=qN({x:r,filter:o,convInfo:m,backend:t});else{const w=new GN(m);g=t.runWebGLProgram(w,[r,o],"float32")}const x=ge({inputs:{x:g},backend:t,attrs:{shape:m.outShape}});return t.disposeIntermediateTensorInfo(g),x}const E5={kernelName:Gd,backendName:"webgl",kernelFunc:T5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R5{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class _5{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=e.dataFormat==="channelsLast",l=t-1-e.padInfo.top,u=s-1-e.padInfo.left,d=a?1:2,p=a?2:3,f=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${f}];

        ivec2 dyCorner = ivec2(coords[${d}], coords[${p}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class O5{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.padInfo.front,a=e.padInfo.top,l=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${l};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class D5{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,a=e.strideHeight,l=e.strideWidth,u=t-1-e.padInfo.front,d=s-1-e.padInfo.top,p=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,pad:l,dataFormat:u,dimRoundingMode:d,filterShape:p}=s,f=lr(u),m=At(r.shape,p,a,1,l,d,!1,f),g=new R5(m);return t.runWebGLProgram(g,[r,o],"float32")}const F5={kernelName:Hd,backendName:"webgl",kernelFunc:A5};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class P5{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Qt(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,o=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L5(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{inputShape:a,strides:l,pad:u,dataFormat:d,dimRoundingMode:p}=s,f=lr(d),m=At(a,o.shape,l,1,u,p,!1,f);if(J().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&f==="channelsLast"){const g=[[m.strideHeight,m.strideWidth]],x=new P5(m);return t.runWebGLProgram(x,[r,o],"float32",g)}else{const g=new _5(m);return t.runWebGLProgram(g,[r,o],"float32")}}const V5={kernelName:jd,backendName:"webgl",kernelFunc:L5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:l,dilations:u}=s,d=qr(r.shape,o.shape,a,u,l),p=new N5(d);return t.runWebGLProgram(p,[r,o],"float32")}const M5={kernelName:qd,backendName:"webgl",kernelFunc:B5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,pad:l,filterShape:u}=s,d=qr(r.shape,u,a,1,l),p=new O5(d);return t.runWebGLProgram(p,[r,o],"float32")}const W5={kernelName:Jg,backendName:"webgl",kernelFunc:z5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U5(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{pad:a,strides:l,inputShape:u}=s,d=qr(u,o.shape,l,1,a),p=new D5(d);return t.runWebGLProgram(p,[r,o],"float32")}const G5={kernelName:Kd,backendName:"webgl",kernelFunc:U5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H5=Ha+`
  return cos(x);
`,j5=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Wo}
  return result;
`,q5=Be({opSnippet:H5,packedOpSnippet:j5}),K5={kernelName:ml,backendName:"webgl",kernelFunc:q5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X5=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Y5=Be({opSnippet:X5}),Q5={kernelName:gl,backendName:"webgl",kernelFunc:Y5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z5{constructor(e,t,s,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,l,u,d]=e,[p]=t,[f,m]=s;this.outputShape=[p,f,m,d];const g=r==="bilinear"?1:0,[x,w]=[`${l-1}.0`,`${u-1}.0`],[v,b,C]=f>1?[`${(l-1)/(f-1)}`,"(y2-y1) * height_ratio",`y1*${x} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${x}`],[I,N,R]=m>1?[`${(u-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${w} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${w}`];this.userCode=`
      const float height_ratio = float(${v});
      const float width_ratio = float(${I});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${N};

        float in_y = ${C};
        if( in_y < 0.0 || in_y > ${x} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${R};
        if( in_x < 0.0 || in_x > ${w} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${g} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J5=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:o,boxInd:a}=e,{cropSize:l,method:u,extrapolationValue:d}=s,p=new Z5(r.shape,o.shape,l,u,d);return t.runWebGLProgram(p,[r,o,a],"float32")},e8={kernelName:Qd,backendName:"webgl",kernelFunc:J5};var sl;(function(n){n.Prod="*",n.Sum="+"})(sl||(sl={}));class eb{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,a=this.op===sl.Prod?"1.0":"0.0",l=s?a:`getX(${tb(o,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let d="",p="";s?(d=r?`end != ${u-1}`:"end != 0",p=r?"end + 1":"end - 1"):(d=r?`end + pow2 < ${u}`:"end >= pow2",p=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ze(o)} coords = getOutputCoords();
        int end = ${nb(o,"coords",this.op)};
        float val = ${l};
        int pow2 = int(pow(2.0, index));
        if (${d}) {
          int idx = ${p};
          ${nb(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${tb(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function tb(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function nb(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KN(n,e,t,s,r,o){const a=e.shape.length,l=wt([s],a);let u=e;l!=null&&(u=ln({inputs:{x:e},backend:t,attrs:{perm:l}}));const d=bt(1,a)[0];if(d!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const p=u.shape[d];let f=Rn({inputs:{x:u},backend:t});for(let m=0;m<=Math.ceil(Math.log2(p))-1;m++){const g=new eb(n,u.shape,!1,o),x=[[m]],w=f;f=t.runWebGLProgram(g,[f],f.dtype,x),t.disposeIntermediateTensorInfo(w)}if(r){const m=new eb(n,u.shape,r,o),g=f;f=t.runWebGLProgram(m,[f],f.dtype),t.disposeIntermediateTensorInfo(g)}if(l!=null){const m=hu(l),g=ln({inputs:{x:f},backend:t,attrs:{perm:m}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(u),g}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:a,reverse:l}=s;return KN(sl.Prod,r,t,o,a,l)}const n8={kernelName:Xd,backendName:"webgl",kernelFunc:t8};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:a,reverse:l}=s;return KN(sl.Sum,r,t,o,a,l)}const r8={kernelName:Yd,backendName:"webgl",kernelFunc:s8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:a,binaryOutput:l}=s;if(r.shape.length===1){const u=t.readSync(r.dataId),d=t.readSync(o.dataId),p=TN(u,d,o.dtype,o.shape,a);return t.makeTensorInfo([a],o.dtype,p)}else if(r.shape.length===2){const u=t.bufferSync(r),d=t.bufferSync(o),p=uH(u,d,a,l);return t.makeTensorInfo(p.shape,o.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const a8={kernelName:Zd,backendName:"webgl",kernelFunc:o8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i8{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:o,dataFormat:a}=s,l=r.shape[0],u=a==="NHWC"?r.shape[1]:r.shape[2],d=a==="NHWC"?r.shape[2]:r.shape[3],p=a==="NHWC"?r.shape[3]:r.shape[1],f=u*o,m=d*o,g=p/(o*o),x=a==="NHWC"?[l,f,m,g]:[l,g,f,m],w=new i8(x,o,a);return t.runWebGLProgram(w,[r],r.dtype)}const u8={kernelName:Jd,backendName:"webgl",kernelFunc:l8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XN{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Qt(this.outputShape.length);const a=e.filterHeight,l=e.filterWidth,u=e.outChannels/e.inChannels;let d="",p="";s&&(r?d=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?d=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:d=`
          float activation(float x) {
            ${s}
          }
        `,p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${d}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${l}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${f}
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YN{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Qt(this.outputShape.length);const a=e.outChannels/e.inChannels,l=e.padInfo.left,u=e.strideWidth,d=e.dilationWidth,p=e.filterHeight,f=e.filterWidth,m=f;let g=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<f;b++)g+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;g+=`
    for (int r = 0; r < ${p}; r++) {
      `;for(let b=0;b<f;b++)g+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;g+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(m+1)/2;b++){const C=b*2;if(g+=`
          xC = xCCorner + ${C*d};
          `,u===1){if(C<f&&(l%2===1?(g+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }
              `,d===1&&C>0?g+=`
                xC${C} = vec4(xTexelC${C-2}.zw, xTexelC${C}.xy);
                `:g+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${C} = vec4(previous.zw, xTexelC${C}.xy);
                  } else {
                    xC${C} = vec4(0.0, 0.0, xTexelC${C}.xy);
                  }
                  `):g+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                xC${C} = xTexelC${C};
                `,C+1<f)){const I=l%2===0?Id(d):d;d%2===0&&l%2===1||d%2!==0&&l%2!==1?(g+=`
                  xCOffset = xC + imod(pads[1], 2) + ${I};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                    xTexelC${C+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${C+1}.zw = vec2(0.0);
                    }
                    xTexelC${C+1}Ready = 1;
                  }
                  `,d>1?g+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${C+1} = vec4(previous.zw, xTexelC${C+1}.xy);
                    } else {
                     xC${C+1} = vec4(0.0, 0.0, xTexelC${C+1}.xy);
                    }
                    `:g+=`
                    xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.xy);
                    `):I===1?g+=`
                    xC${C+1} = xTexelC${C};
                    `:g+=`
                    xCOffset = xC + ${I};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                      xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${C+1}.zw = vec2(0.0);
                      }
                      xTexelC${C+1}Ready = 1;
                    }

                    xC${C+1} = xTexelC${C+1};
                    `}}else C<f&&(l%2===1?(g+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${C+1}Ready == 0) {
                  xTexelC${C+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${C+1}.zw = vec2(0.0);
                  }
                  xTexelC${C+1}Ready = 1;
                }

                xC${C} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
              `,C+1<f&&(g+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${C+1} = vec4(xTexelC${C+1}.xy, final.xy);
                `)):(g+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                  xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C+1}.zw = vec2(0.);
                  }
                  xTexelC${C+1}Ready = 1;
                }

                xC${C} = vec4(
                  xTexelC${C}.xy, xTexelC${C+1}.xy);
              `,C+1<f&&(g+=`
                  xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
                `)));C<f&&(g+=`
            wTexel = getW(r, ${C}, d1, q);
            dotProd += xC${C} * vec4(wTexel.xz, wTexel.xz);
          `,C+1<f&&(g+=`
              wTexel = getW(r, ${C+1}, d1, q);
              dotProd += xC${C+1} * vec4(wTexel.xz, wTexel.xz);
            `))}g+=`
    }
  `,g+=`
      }
    `;let x="",w="";s&&(r?x=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?x=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:x=`vec4 activation(vec4 x) {
          ${s}
        }`,w="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${g}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${v}
        ${w}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:l,dilations:u,dimRoundingMode:d}=s;let p=u;p==null&&(p=[1,1]),O(Yt(a,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);const f=At(r.shape,o.shape,a,p,l,d,!0);let m;J().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1?m=new YN(f):m=new XN(f);const g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return t.runWebGLProgram(m,[r,o],"float32",g)}const d8={kernelName:ep,backendName:"webgl",kernelFunc:c8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p8{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class f8{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=t-1-e.padInfo.top,l=s-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,dilations:l,pad:u,dimRoundingMode:d,filterShape:p}=s,f=At(r.shape,p,a,l,u,d,!0),m=new p8(f);return t.runWebGLProgram(m,[r,o],"float32")}const m8={kernelName:tp,backendName:"webgl",kernelFunc:h8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g8(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{strides:a,dilations:l,pad:u,dimRoundingMode:d,inputShape:p}=s,f=At(p,o.shape,a,l,u,d,!0),m=new f8(f);return t.runWebGLProgram(m,[r,o],"float32")}const y8={kernelName:np,backendName:"webgl",kernelFunc:g8};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x8{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v8(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],o=oe(s.shape),a=ge({inputs:{x:s},backend:t,attrs:{shape:[o]}}),l=new x8(o),u=t.runWebGLProgram(l,[a],a.dtype),d=ge({inputs:{x:u},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),d}const w8={kernelName:sp,backendName:"webgl",kernelFunc:v8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b8{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:o,strideWidth:a,filterHeight:l,filterWidth:u,dilationHeight:d,dilationWidth:p}=e,{top:f,left:m}=r;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${a});
      const ivec2 pads = ivec2(${f}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${l}; h++) {
          int hIn = hBeg + h * ${d};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${p};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:l,dilations:u}=s,d=du(r.shape,o.shape,a,l,"NHWC",u);let p;const f=new b8(d);p=t.runWebGLProgram(f,[r,o],"float32");const m=ge({inputs:{x:p},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(p),m}const S8={kernelName:rp,backendName:"webgl",kernelFunc:$8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C8(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,o=e,{allDims:a,summedDims:l,idDims:u}=R0(r,o.length);O0(a.length,u,o);const{path:d,steps:p}=D0(l,u),f=p.length;let m=null,g=a.length;const x=[];for(let w=0;w<f;++w){for(const v of p[w]){const{permutationIndices:b,expandDims:C}=_0(g,u[v]);let I;A0(b)?I=o[v]:(I=ln({inputs:{x:o[v]},backend:t,attrs:{perm:b}}),x.push(I));const N=I.shape.slice();for(let R=0;R<C.length;++R)N.splice(C[R],0,1);Qe(I.shape,N)||(I=ge({inputs:{x:I},backend:t,attrs:{shape:N}}),x.push(I)),m===null?m=I:(m=tx({inputs:{a:I,b:m},backend:t}),x.push(m))}w<f-1&&(d[w]>=0&&(m=qf({inputs:{x:m},backend:t,attrs:{axis:d[w]-(a.length-g),keepDims:!1}}),x.push(m)),g--)}for(const w of x)w!==m&&t.disposeIntermediateTensorInfo(w);return m}const k8={kernelName:ap,backendName:"webgl",kernelFunc:C8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N8="return (x >= 0.0) ? x : (exp(x) - 1.0);",I8=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,T8=Be({opSnippet:N8,packedOpSnippet:I8}),E8={kernelName:xl,backendName:"webgl",kernelFunc:T8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R8="return (b >= 0.0) ? a : a * (b + 1.0);",_8=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,O8=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,o=J().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ga(_8,s.shape,r.shape):new Po(R8,s.shape,r.shape);return t.runWebGLProgram(o,[s,r],s.dtype)},D8={kernelName:ey,backendName:"webgl",kernelFunc:O8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A8=`
  return vec4(equal(a, b));
`,F8="return float(a == b);",P8=Ht({opSnippet:F8,packedOpSnippet:A8,dtype:"bool",cpuKernelImpl:hH}),L8={kernelName:wl,backendName:"webgl",kernelFunc:P8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V8=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${S0};
  float a1 = ${C0};
  float a2 = ${k0};
  float a3 = ${N0};
  float a4 = ${I0};
  float a5 = ${T0};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,B8=Be({opSnippet:V8}),M8={kernelName:vl,backendName:"webgl",kernelFunc:B8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z8=Ha+`
  return exp(x);
`,W8=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,QN=Be({opSnippet:z8,packedOpSnippet:W8,cpuKernelImpl:mH,dtype:"float32"}),U8={kernelName:bl,backendName:"webgl",kernelFunc:QN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wg(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:o}=e,a=o.shape.length,l=o.shape.slice();let u=r;return r<0&&(O(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+r+1),l.splice(u,0,1),ge({inputs:{x:o},backend:s,attrs:{shape:l}})}const G8={kernelName:ip,backendName:"webgl",kernelFunc:Wg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sb="return exp(x) - 1.0;",H8=Be({opSnippet:sb,packedOpSnippet:sb,cpuKernelImpl:gH}),j8={kernelName:$l,backendName:"webgl",kernelFunc:H8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rb{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const o=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=s?`${r}.0`:"1.0";let l;if(e==="real")l="return real * expR - imag * expI;";else if(e==="imag")l="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${l}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZN(n,e,t){const s=t.texData.get(n.dataId),r=oe(n.shape),o=n.shape[n.shape.length-1],a=r/o,l=ge({inputs:{x:n},backend:t,attrs:{shape:[a,o]}}),u=l.shape,d=new rb("real",u,e),p=new rb("imag",u,e),f=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:u},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:u}],m=t.runWebGLProgram(d,f,"float32"),g=t.runWebGLProgram(p,f,"float32"),x=Zr({inputs:{real:m,imag:g},backend:t});t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g);const w=ge({inputs:{x},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(x),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q8(n){const{inputs:e,backend:t}=n,{input:s}=e;return ZN(s,!1,t)}const K8={kernelName:lp,backendName:"webgl",kernelFunc:q8};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X8{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iu(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:o}=t;if(o=o||Vo(r),o==="string"){const a=xt(o,oe(s));return a.fill(r),e.makeTensorInfo(s,o,a)}else{const a=new X8(s,r),l=[[r]];return e.runWebGLProgram(a,[],o,l)}}const Y8={kernelName:up,backendName:"webgl",kernelFunc:Iu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q8{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z8={kernelName:cp,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new Q8(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ob="return floor(x);",J8=Be({opSnippet:ob,packedOpSnippet:ob,cpuKernelImpl:yH}),eq={kernelName:Sl,backendName:"webgl",kernelFunc:J8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tq=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,nq=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,sq=Ht({opSnippet:tq,packedOpSnippet:nq,dtype:"int32"}),rq={kernelName:Cl,backendName:"webgl",kernelFunc:sq};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oq{constructor(e){this.variableNames=["A"];const t=un(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aq{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=un(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iq={kernelName:id,backendName:"webgl",kernelFunc:lq};let ha,rg=J().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function lq(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:o}=s,a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,l=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,d]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],p=[d,u],f=[d,u,o];if(l||a){const w=J().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(ha==null||w!==rg)&&(rg=w,ha=document.createElement("canvas").getContext("2d",{willReadFrequently:rg})),ha.canvas.width=u,ha.canvas.height=d,ha.drawImage(r,0,0,u,d),r=ha.canvas}const m=t.makeTensorInfo(p,"int32");t.texData.get(m.dataId).usage=Mn.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(m.dataId),r);const g=J().getBool("WEBGL_PACK")?new aq(f):new oq(f),x=t.runWebGLProgram(g,[m],"int32");return t.disposeData(m.dataId),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uq(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:l}=e,{strides:u,pad:d,dataFormat:p,dilations:f,dimRoundingMode:m,activation:g,leakyreluAlpha:x}=s,w=lr(p),v=At(r.shape,o.shape,u,f,d,m,!1,w);let b;const C=[],I=a!=null,N=l!=null,R=g==="leakyrelu",D=()=>{const V=[r,o],P=(A,T)=>{if(T==="NCHW"&&A.shape.length===1&&A.shape[0]!==1){const W=ge({inputs:{x:A},backend:t,attrs:{shape:[A.shape[0],1,1]}});return C.push(W),W}return A};if(I&&V.push(P(a,p)),N&&V.push(P(l,p)),R){const A=t.makeTensorInfo([],"float32",ar(x,"float32"));V.push(A),C.push(A)}return V};if(v.filterHeight===1&&v.filterWidth===1&&v.dilationHeight===1&&v.dilationWidth===1&&v.strideHeight===1&&v.strideWidth===1&&(v.padInfo.type==="SAME"||v.padInfo.type==="VALID"))b=jN({x:r,filter:o,convInfo:v,backend:t,bias:a,activation:g,preluActivationWeights:l,leakyreluAlpha:x});else if(v.strideWidth<=2&&w==="channelsLast"&&J().getBool("WEBGL_EXP_CONV")){const V=g?tl(g,!0):null,P=new HN(v,I,V,N,R),A=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],T=D();b=t.runWebGLProgram(P,T,"float32",A)}else if(J().getBool("WEBGL_CONV_IM2COL"))b=qN({x:r,filter:o,convInfo:v,backend:t,bias:a,activation:g,preluActivationWeights:l,leakyreluAlpha:x});else{const V=g?tl(g,!1):null,P=new GN(v,I,V,N,R),A=D();b=t.runWebGLProgram(P,A,"float32")}const F=ge({inputs:{x:b},backend:t,attrs:{shape:v.outShape}});return C.push(b),C.forEach(V=>t.disposeIntermediateTensorInfo(V)),F}const cq={kernelName:Mi,backendName:"webgl",kernelFunc:uq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dq(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:l}=e,{strides:u,pad:d,dilations:p,dimRoundingMode:f,activation:m,leakyreluAlpha:g}=s,x=[];let w=p;w==null&&(w=[1,1]),O(Yt(u,w),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${w}'`);const v=At(r.shape,o.shape,u,w,d,f,!0),b=J().getBool("WEBGL_PACK_DEPTHWISECONV")&&v.strideWidth<=2&&v.outChannels/v.inChannels===1,C=m?tl(m,b):null,I=[r,o],N=a!=null,R=l!=null,D=m==="leakyrelu";if(N&&I.push(a),R&&I.push(l),D){const A=t.makeTensorInfo([],"float32",ar(g,"float32"));I.push(A),x.push(A)}let F;b?F=new YN(v,N,C,R,D):F=new XN(v,N,C,R,D);const V=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],P=t.runWebGLProgram(F,I,"float32",V);return x.forEach(A=>t.disposeIntermediateTensorInfo(A)),P}const pq={kernelName:zi,backendName:"webgl",kernelFunc:dq};class fq{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const o=Ze(s.length);let a=`
    int index;`;for(let l=0;l<this.sliceDim;l++)a+=`
          index = round(getIndices(coords[0], ${l}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[l]};
          flattenIndex += index * ${this.strides[l]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hq(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,o=r.shape,a=o[o.length-1],l=oe(s.shape),[u,d,p,f]=Mf(s,r),m=ge({inputs:{x:r},backend:t,attrs:{shape:[d,a]}}),g=ge({inputs:{x:s},backend:t,attrs:{shape:[oe(s.shape)/p,p]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const b=t.readSync(r.dataId),C=t.bufferSync(s),I=xH(b,C,s.dtype,d,a,p,f,s.shape,l);return t.makeTensorInfo(u,s.dtype,I.values)}const x=new fq(a,f,[d,p],s.shape),w=t.runWebGLProgram(x,[g,m],g.dtype),v=ge({inputs:{x:w},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(w),v}const mq={kernelName:fp,backendName:"webgl",kernelFunc:hq};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gq{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=Ze(this.rank),r=yq(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function yq(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:o}=e,{axis:a,batchDims:l}=s,u=Me(a,r.shape)[0];if(J().get("DEBUG")){const C=t.readSync(o.dataId),I=r.shape[u];for(let N=0;N<C.length;++N){const R=C[N];O(R<=I-1&&R>=0,()=>`GatherV2: the index value ${R} is not in [0, ${I-1}]`)}}const d=P0(r,o,u,l),p=oe(o.shape),f=[],m=ge({inputs:{x:r},backend:t,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),g=ge({inputs:{x:o},backend:t,attrs:{shape:[d.batchSize,p/d.batchSize]}});f.push(m),f.push(g);const x=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize];if(t.shouldExecuteOnCPU([r,o])||r.dtype==="string"){const C=t.bufferSync(g),I=t.bufferSync(m),N=vH(I,C,x);return f.forEach(R=>t.disposeIntermediateTensorInfo(R)),t.makeTensorInfo(d.outputShape,N.dtype,N.values)}const w=new gq(m.shape,x),v=t.runWebGLProgram(w,[m,g],m.dtype);f.push(v);const b=ge({inputs:{x:v},backend:t,attrs:{shape:d.outputShape}});return f.forEach(C=>t.disposeIntermediateTensorInfo(C)),b}const xq={kernelName:pp,backendName:"webgl",kernelFunc:JN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vq="return float(a > b);",wq=`
  return vec4(greaterThan(a, b));
`,bq=Ht({opSnippet:vq,packedOpSnippet:wq,cpuKernelImpl:wH,dtype:"bool"}),$q={kernelName:kl,backendName:"webgl",kernelFunc:bq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sq="return float(a >= b);",Cq=`
  return vec4(greaterThanEqual(a, b));
`,kq=Ht({opSnippet:Sq,packedOpSnippet:Cq,dtype:"bool",cpuKernelImpl:bH}),Nq={kernelName:Nl,backendName:"webgl",kernelFunc:kq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iq(n){const{inputs:e,backend:t}=n,{input:s}=e;return ZN(s,!0,t)}const Tq={kernelName:hp,backendName:"webgl",kernelFunc:Iq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eq="return float(!isnan(x) && !isinf(x));",Rq=Be({opSnippet:Eq,dtype:"bool"}),_q={kernelName:Tl,backendName:"webgl",kernelFunc:Rq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oq="return float(isinf(x));",Dq=Be({opSnippet:Oq,dtype:"bool"}),Aq={kernelName:El,backendName:"webgl",kernelFunc:Dq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fq="return float(isnan(x));",Pq=Be({opSnippet:Fq,dtype:"bool"}),Lq={kernelName:Rl,backendName:"webgl",kernelFunc:Pq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vq="return float(a < b);",Bq=`
  return vec4(lessThan(a, b));
`,Mq=Ht({opSnippet:Vq,packedOpSnippet:Bq,cpuKernelImpl:$H,dtype:"bool"}),zq={kernelName:_l,backendName:"webgl",kernelFunc:Mq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wq="return float(a <= b);",Uq=`
  return vec4(lessThanEqual(a, b));
`,Gq=Ht({opSnippet:Wq,packedOpSnippet:Uq,cpuKernelImpl:SH,dtype:"bool"}),Hq={kernelName:Ol,backendName:"webgl",kernelFunc:Gq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jq(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:o}=t,a=CH(s,r,o);return e.makeTensorInfo([a.length],"float32",a)}const qq={kernelName:yp,backendName:"webgl",kernelFunc:jq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kq=Ha+`
  return x < 0.0 ? 0./0. : log(x);
`,Xq=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Yq=Be({opSnippet:Kq,packedOpSnippet:Xq,cpuKernelImpl:kH}),Qq={kernelName:Dl,backendName:"webgl",kernelFunc:Yq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zq=Ha+`
  return log(1.0 + x);
`,Jq=Be({opSnippet:Zq}),eK={kernelName:Al,backendName:"webgl",kernelFunc:Jq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tK="return float(a >= 1.0 && b >= 1.0);",nK=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,sK=Ht({opSnippet:tK,packedOpSnippet:nK,dtype:"bool"}),rK={kernelName:Fl,backendName:"webgl",kernelFunc:sK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oK="return float(!(x >= 1.0));",aK=Be({opSnippet:oK}),iK={kernelName:Pl,backendName:"webgl",kernelFunc:aK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lK="return float(a >= 1.0 || b >= 1.0);",uK=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,cK=Ht({opSnippet:lK,packedOpSnippet:uK,dtype:"bool"}),dK={kernelName:Ll,backendName:"webgl",kernelFunc:cK};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pK{constructor(e,t,s,r,o){this.variableNames=["x"],this.outputShape=[];const a=t,l=e[3]-1;this.outputShape=e;let u;const d=`float(${s}) + float(${r}) * sum`;o===.5?u=`inversesqrt(${d})`:o===1?u=`1.0/(${d})`:u=`exp(log(${d}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${l}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fK{constructor(e,t,s,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,l=e[3]-1;this.outputShape=e;let u;const d=`float(${s}) + float(${r}) * sum`;o===.5?u=`inversesqrt(${d})`:o===1?u=`1.0/(${d})`:u=`exp(log(${d}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${l}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hK=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:o,bias:a,alpha:l,beta:u}=s,d=J().getBool("WEBGL_PACK_NORMALIZATION")?new fK(r.shape,o,a,l,u):new pK(r.shape,o,a,l,u);return t.runWebGLProgram(d,[r],r.dtype)},mK={kernelName:xp,backendName:"webgl",kernelFunc:hK};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gK{constructor(e,t,s,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${o})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yK=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:o,dy:a}=e,{depthRadius:l,bias:u,alpha:d,beta:p}=s,f=new gK(r.shape,l,u,d,p);return t.runWebGLProgram(f,[r,o,a],r.dtype)},xK={kernelName:ty,backendName:"webgl",kernelFunc:yK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vK(n,e,t,s){const r=oe(e),a=oe(n.shape)/r,l=ge({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),u=Uo(l,n.dtype,"max",s),d=ge({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(u),d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:o,keepDims:a}=s,l=r.shape.length,u=Me(o,r.shape);let d=u;const p=wt(d,l),f=p!=null,m=t.shouldExecuteOnCPU([r]);let g=r;if(f){if(m){const I=t.texData.get(g.dataId).values,N=new Array(l);for(let F=0;F<N.length;F++)N[F]=r.shape[p[F]];const R=J0(I,r.shape,r.dtype,p,N);g=t.makeTensorInfo(N,r.dtype);const D=t.texData.get(g.dataId);D.values=R}else g=jf(r,p,t);d=bt(d.length,l)}Ut("max",d,l);const[x,w]=Wt(g.shape,d);let v=x;a&&(v=It(x,u));let b;if(m){const I=t.texData.get(g.dataId).values,N=NH(I,oe(w),v,r.dtype);b=t.makeTensorInfo(v,r.dtype);const R=t.texData.get(b.dataId);R.values=N}else b=vK(g,w,v,t);return f&&t.disposeIntermediateTensorInfo(g),b}const wK={kernelName:vp,backendName:"webgl",kernelFunc:e2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bK=ex+`
  return max(a, b);
`,$K=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Wo+`
  return result;
`,SK=Ht({opSnippet:bK,packedOpSnippet:$K,cpuKernelImpl:IH}),CK={kernelName:Vl,backendName:"webgl",kernelFunc:SK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Cu(r,"maxPool");const{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=s,d=1;O(Yt(a,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const p=es(r.shape,o,a,d,l,u);if(p.filterWidth===1&&p.filterHeight===1&&Qe(p.inShape,p.outShape))return Rn({inputs:{x:r},backend:t});const f=new nl(p,"max",!1);return t.runWebGLProgram(f,[r],r.dtype)}const NK={kernelName:wp,backendName:"webgl",kernelFunc:kK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:d}=s,p=[1,1,1],f=ir(r.shape,o,a,p,l,d,u),m=new nx(f,"max",!1);return t.runWebGLProgram(m,[r],r.dtype)}const TK={kernelName:bp,backendName:"webgl",kernelFunc:IK};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EK{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,o=e.effectiveFilterHeight,a=e.effectiveFilterWidth,l=o-1-e.padInfo.top,u=a-1-e.padInfo.left,d=o*a-1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${d} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class RK{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=u-1-e.padInfo.front,m=d-1-e.padInfo.top,g=p-1-e.padInfo.left,x=u*d*p-1;this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${x} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${d} * ${p} +
                  wR * ${p} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _K(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,a=o,{filterSize:l,strides:u,pad:d,dimRoundingMode:p}=s,f=[1,1,1],m=ir(a.shape,l,u,f,d,p),g=new nx(m,"max",!0),x=t.runWebGLProgram(g,[a],a.dtype),w=new RK(m),v=t.runWebGLProgram(w,[r,x],a.dtype);return t.disposeIntermediateTensorInfo(x),v}const OK={kernelName:sy,backendName:"webgl",kernelFunc:_K};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DK(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o,output:a}=e,l=o;Cu([o,a],"maxPoolGrad");const{filterSize:u,strides:d,pad:p,dimRoundingMode:f}=s,m=es(l.shape,u,d,1,p,f),g=!0,x=new nl(m,"max",g),w=t.runWebGLProgram(x,[l],l.dtype),v=new EK(m),b=t.runWebGLProgram(v,[r,w],l.dtype);return t.disposeIntermediateTensorInfo(w),b}const AK={kernelName:ny,backendName:"webgl",kernelFunc:DK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FK(n,e,t,s){let r=new nl(t,"max",!1);const o=s.runWebGLProgram(r,[n],"float32");r=new nl(t,"max",!0,!0,e);const a=s.runWebGLProgram(r,[n],"float32");return[o,a]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PK={kernelName:$p,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:o,pad:a,includeBatchInIndex:l}=e,u=t;O(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const d=[1,1];O(Yt(o,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=es(s.shape,r,o,d,a),[f,m]=FK(s,l,p,u);return[f,m]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LK(n,e,t,s){const r=oe(e),a=oe(n.shape)/r,l=ge({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),u=Uo(l,"float32","mean",s),d=ge({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(u),d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VK={kernelName:Sp,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:o}=e,a=t,l=s.shape.length,u=Me(o,s.shape);let d=u;const p=wt(d,l),f=p!=null,m=a.shouldExecuteOnCPU([s]),g=[];let x=s;if(f){if(m){const N=a.texData.get(x.dataId).values,R=new Array(l);for(let V=0;V<R.length;V++)R[V]=s.shape[p[V]];const D=J0(N,s.shape,s.dtype,p,R);x=a.makeTensorInfo(R,s.dtype);const F=a.texData.get(x.dataId);F.values=D}else x=jf(s,p,a);g.push(x),d=bt(d.length,l)}Ut("sum",d,l);const[w,v]=Wt(x.shape,d);let b=w;r&&(b=It(w,u));const C=LK(x,v,b,a);for(const I of g)a.disposeIntermediateTensorInfo(I);return C}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,l=r.shape.length,u=Me(o,r.shape);let d=u;const p=wt(d,l);let f=r;p!=null&&(f=ln({inputs:{x:r},backend:t,attrs:{perm:p}}),d=bt(d.length,r.shape.length)),Ut("min",d,l);const[m,g]=Wt(f.shape,d),x=oe(g),w=ge({inputs:{x:f},backend:t,attrs:{shape:[-1,x]}}),v=Uo(w,w.dtype,"min",t);let b;if(a){const C=It(m,u);b=ge({inputs:{x:v},backend:t,attrs:{shape:C}})}else b=ge({inputs:{x:v},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(v),p!=null&&t.disposeIntermediateTensorInfo(f),b}const MK={kernelName:Cp,backendName:"webgl",kernelFunc:BK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zK=ex+`
  return min(a, b);
`,WK=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Wo+`
  return result;
`,UK=Ht({opSnippet:zK,packedOpSnippet:WK,cpuKernelImpl:TH}),GK={kernelName:Bl,backendName:"webgl",kernelFunc:UK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HK{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((p,f)=>p[0]+e[f]+p[1]);const r=e.length,o=Ze(r),a=t.map(p=>p[0]).join(","),l=t.map((p,f)=>p[0]+e[f]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),d=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${d};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${d};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${l});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${d};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${d};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jK{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((x,w)=>x[0]+e[w]+x[1]);const r=e.length,o=Ze(r),a=t.map(x=>x[0]).join(","),l=t.map((x,w)=>x[0]+e[w]).join(","),u=on("rc",r),d=on("source",r),p=`${u[r-1]} < ${this.outputShape[r-1]}`,f=r===1?"source":`vec2(${d.slice(-2).join()})`,m=s==="reflect"?0:1;let g="";if(r===1){const x=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;g=`
        ${o} rc = outputLoc;
        ${x}
        result[0] = getChannel(getX(${d.join()}), ${f});
        ${u[r-1]} += 1;
        if(${p}) {
          ${x}
          result[1] = getChannel(getX(${d.join()}), ${f});
        }
      `}else{const x=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;g=`
        ${o} rc = outputLoc;
        ${x}
        result[0] = getChannel(getX(${d.join()}), ${f});
        ${u[r-1]} += 1;
        if(${p}) {
          ${x}
          result[1] = getChannel(getX(${d.join()}), ${f});
        }
        rc = outputLoc;
        ${u[r-2]} += 1;
        if(${u[r-2]} < ${this.outputShape[r-2]}) {
          ${x}
          result[2] = getChannel(getX(${d.join()}), ${f});
          ${u[r-1]} += 1;
          if(${p}) {
            ${x}
            result[3] = getChannel(getX(${d.join()}), ${f});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${l});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qK=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:o}=t,a=J().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jK(s.shape,r,o):new HK(s.shape,r,o);return e.runWebGLProgram(a,[s],s.dtype)},KK={kernelName:kp,backendName:"webgl",kernelFunc:qK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XK=`if (b == 0.0) return NAN;
  return mod(a, b);`,YK=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Wo+`
  return result;
`,QK=Ht({opSnippet:XK,packedOpSnippet:YK}),ZK={kernelName:Ml,backendName:"webgl",kernelFunc:QK};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JK{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eX=`
if (a == b) {
  return 1.0;
};
return a / b;`,tX=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,t2=Ht({opSnippet:eX,packedOpSnippet:tX,checkOutOfBounds:!0}),nX={kernelName:yl,backendName:"webgl",kernelFunc:t2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ab="return a - b;",n2=Ht({opSnippet:ab,packedOpSnippet:ab,supportsComplex:!0,cpuKernelImpl:XH}),sX={kernelName:ru,backendName:"webgl",kernelFunc:n2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:o}=s,a=Me([o],r.shape),l=e2({inputs:{x:r},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),u=It(l.shape,a),d=ge({inputs:{x:l},backend:t,attrs:{shape:u}}),p=n2({inputs:{a:r,b:d},backend:t}),f=QN({inputs:{x:p},backend:t}),m=qf({inputs:{x:f},backend:t,attrs:{axis:a,keepDims:!1}}),g=ge({inputs:{x:m},backend:t,attrs:{shape:u}}),x=t2({inputs:{a:f,b:g},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),x}const rX={kernelName:ef,backendName:"webgl",kernelFunc:s2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oX(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:o,seed:a,normalized:l}=s,u=l?r:s2({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),d=u.shape[0],p=u.shape[1],f=new JK(d,p,o),m=[[a]],g=t.runWebGLProgram(f,[u],"int32",m);return l||t.disposeIntermediateTensorInfo(u),g}const aX={kernelName:Np,backendName:"webgl",kernelFunc:oX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iX=ns+`
  return -x;
`,lX=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function uX(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const o=t.texData.get(s.dataId),[a,l]=RH(o.values,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,a)}let r;return J().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Fr(s.shape,lX):r=new Ts(s.shape,iX),t.runWebGLProgram(r,[s],s.dtype)}const cX={kernelName:Ip,backendName:"webgl",kernelFunc:uX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dX=Pf;function pX(n){Vn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=s,d=t.readSync(r.dataId),p=t.readSync(o.dataId),{selectedIndices:f}=dX(d,p,a,l,u);return t.makeTensorInfo([f.length],"int32",new Int32Array(f))}const fX={kernelName:Tp,backendName:"webgl",kernelFunc:pX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hX=Lf;function mX(n){Vn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:l,scoreThreshold:u,padToMaxOutputSize:d}=s,p=t.readSync(r.dataId),f=t.readSync(o.dataId),{selectedIndices:m,validOutputs:g}=hX(p,f,a,l,u,d);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([g]))]}const gX={kernelName:Ep,backendName:"webgl",kernelFunc:mX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yX=Vf;function xX(n){Vn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:l,scoreThreshold:u,softNmsSigma:d}=s,p=t.readSync(r.dataId),f=t.readSync(o.dataId),m=a,g=l,x=u,w=d,{selectedIndices:v,selectedScores:b}=yX(p,f,m,g,x,w);return[t.makeTensorInfo([v.length],"int32",new Int32Array(v)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const vX={kernelName:Rp,backendName:"webgl",kernelFunc:xX};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wX{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bX=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:o,depth:a,onValue:l,offValue:u}=s,d=oe(r.shape),p=new wX(d,a,l,u),f=ge({inputs:{x:r},backend:t,attrs:{shape:[d]}}),m=t.runWebGLProgram(p,[f],o);t.disposeIntermediateTensorInfo(f);const g=[...r.shape,a],x=ge({inputs:{x:m},backend:t,attrs:{shape:g}});return t.disposeIntermediateTensorInfo(m),x},$X={kernelName:Op,backendName:"webgl",kernelFunc:bX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kd(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=Nu({inputs:{input:s},backend:t}),o=kd({inputs:{x:r},backend:t}),a=Kf({inputs:{input:s},backend:t}),l=kd({inputs:{x:a},backend:t}),u=Zr({inputs:{real:o,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}else return Iu({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const SX={kernelName:gf,backendName:"webgl",kernelFunc:kd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r2(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=Nu({inputs:{input:s},backend:t}),o=r2({inputs:{x:r},backend:t}),a=Kf({inputs:{input:s},backend:t}),l=kd({inputs:{x:a},backend:t}),u=Zr({inputs:{real:o,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}else return Iu({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const CX={kernelName:_p,backendName:"webgl",kernelFunc:r2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kX(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return Wg({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const o=e[0].shape,a=e[0].dtype;e.forEach(p=>{zt(o,p.shape,"All tensors passed to stack must have matching shapes"),O(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],u=e.map(p=>{const f=Wg({inputs:{input:p},backend:t,attrs:{dim:r}});return l.push(f),f}),d=UN({inputs:u,backend:t,attrs:{axis:r}});return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const NX={kernelName:Dp,backendName:"webgl",kernelFunc:kX};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IX{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((d,p)=>d[0]+e[p]+d[1]);const r=e.length,o=Ze(r),a=t.map(d=>d[0]).join(","),l=t.map((d,p)=>d[0]+e[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${l});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TX{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((w,v)=>w[0]+e[v]+w[1]);const r=e.length,o=Ze(r),a=t.map(w=>w[0]).join(","),l=t.map((w,v)=>w[0]+e[v]).join(","),u=on("rc",r),d=on("source",r),p=`${u[r-1]} < ${this.outputShape[r-1]}`,f=r===1?"source":`vec2(${d.slice(-2).join()})`,m=[`${o} rc = outputLoc;`,`${u[r-1]} += 1;
       if(${p}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${u[r-2]} += 1;
       if(${u[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${u[r-1]} += 1;
         if(${p}) {`],g=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let x="";for(let w=0,v=r===1?2:4;w<v;w++)x+=`
        ${m[w]}
        if (${g}) {
          result[${w}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${w}] = getChannel(getX(${d.join()}), ${f});
        }
      `;x+=r===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${l});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o2=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,constantValue:a}=s;if(oe(r.shape)===0){const d=o.map((p,f)=>p[0]+r.shape[f]+p[1]);return Iu({backend:t,attrs:{shape:d,value:a,dtype:r.dtype}})}const l=J().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TX(r.shape,o,a):new IX(r.shape,o,a),u=[[a]];return t.runWebGLProgram(l,[r],r.dtype,u)},EX={kernelName:Ap,backendName:"webgl",kernelFunc:o2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RX=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,_X=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Wo+`
  return result;
`,OX=Ht({opSnippet:RX,packedOpSnippet:_X}),DX={kernelName:Ul,backendName:"webgl",kernelFunc:OX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,l=r.shape.length,u=[],d=Me(o,r.shape);let p=d;const f=wt(p,l);let m=r;f!=null&&(m=ln({inputs:{x:r},backend:t,attrs:{perm:f}}),p=bt(p.length,l),u.push(m)),Ut("prod",p,l);let g;if(t.shouldExecuteOnCPU([m])){const x=t.texData.get(m.dataId).values,{outVals:w,outShape:v,outDtype:b}=OH(m.shape,m.dtype,x,p);g=t.makeTensorInfo(v,b,w)}else{const[x,w]=Wt(m.shape,p),v=oe(w),b=ge({inputs:{x:m},backend:t,attrs:{shape:[-1,v]}}),C=vf(r.dtype),I=Uo(b,C,"prod",t);g=ge({inputs:{x:I},backend:t,attrs:{shape:x}}),u.push(b),u.push(I)}if(a){u.push(g);const x=It(g.shape,d);g=ge({inputs:{x:g},backend:t,attrs:{shape:x}})}return u.forEach(x=>t.disposeIntermediateTensorInfo(x)),g}const FX={kernelName:Pp,backendName:"webgl",kernelFunc:AX};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PX(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:o,indices:a}=e,{outputRaggedRank:l}=s,u=r.map(b=>t.readSync(b.dataId)),d=r.map(b=>b.shape),p=t.readSync(o.dataId),f=t.readSync(a.dataId),[m,g,x]=DH(u,d,p,o.shape,o.dtype,f,a.shape,l),w=m.map(b=>t.makeTensorInfo([b.length],"int32",b)),v=t.makeTensorInfo(x,o.dtype,g);return w.concat([v])}const LX={kernelName:Lp,backendName:"webgl",kernelFunc:PX};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VX(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:o}=e,a=t.readSync(s.dataId),l=t.readSync(r.dataId),u=t.readSync(o.dataId),[d,p]=AH(a,s.shape,s.dtype,l,r.shape,u,o.shape),f=t.makeTensorInfo([d.length],"int32",d),m=t.makeTensorInfo([p.length],s.dtype,p);return[f,m]}const BX={kernelName:Vp,backendName:"webgl",kernelFunc:VX};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MX(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:o,defaultValue:a,rowPartitionTensors:l}=e,{rowPartitionTypes:u}=s,d=t.readSync(r.dataId),p=t.readSync(o.dataId),f=t.readSync(a.dataId),m=l.map(v=>t.readSync(v.dataId)),g=l.map(v=>v.shape),[x,w]=FH(d,r.shape,p,o.shape,o.dtype,f,a.shape,m,g,u);return t.makeTensorInfo(x,o.dtype,w)}const zX={kernelName:Bp,backendName:"webgl",kernelFunc:MX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a2=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:o,dtype:a}=t,l=PH(s,r,o,a);return e.makeTensorInfo([l.length],a,l)},WX={kernelName:Mp,backendName:"webgl",kernelFunc:a2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UX="return 1.0 / x;",GX=Be({opSnippet:UX}),HX={kernelName:Gl,backendName:"webgl",kernelFunc:GX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jX=ns+`
  return (x < 0.0) ? 0.0 : x;
`,qX=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,KX=Be({opSnippet:jX,packedOpSnippet:qX}),XX={kernelName:Hl,backendName:"webgl",kernelFunc:KX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YX=ns+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,QX=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ZX=Be({opSnippet:YX,packedOpSnippet:QX}),JX={kernelName:jl,backendName:"webgl",kernelFunc:ZX};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e7{constructor(e,t,s,r,o){this.variableNames=["A"],this.outputShape=[];const[a,l,u,d]=e;this.outputShape=[a,t,s,d];const p=[r&&t>1?l-1:l,r&&s>1?u-1:u],f=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;o?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/f[0]},
          ${p[1]/f[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t7{constructor(e,t,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,l,u,d]=e;this.outputShape=[a,t,s,d];const p=[r&&t>1?l-1:l,r&&s>1?u-1:u],f=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;o?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/f[0]},
          ${p[1]/f[1]},
          ${p[1]/f[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${d-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n7(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:l}=s,[u,d]=l,p=J().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new t7(r.shape,u,d,o,a):new e7(r.shape,u,d,o,a);return t.runWebGLProgram(p,[r],"float32")}const s7={kernelName:Gp,backendName:"webgl",kernelFunc:n7};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r7{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,a,l]=e,u=[s&&a>1?r-1:r,s&&l>1?o-1:o],d=[s&&a>1?a-1:a,s&&l>1?l-1:l],p=u[0]/d[0],f=u[1]/d[1],m=1/p,g=1/f,x=Math.ceil(m)*2+2,w=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${f});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${g});

        const int winHeight = int(${x});
        const int winWidth = int(${w});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o7(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:a}=s,l=new r7(o.shape,r.shape,a);return t.runWebGLProgram(l,[o],o.dtype)}const a7={kernelName:oy,backendName:"webgl",kernelFunc:o7};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i7{constructor(e,t,s,r,o){this.variableNames=["A"],this.outputShape=[];const[a,l,u,d]=e;this.outputShape=[a,t,s,d];const p=[r&&t>1?l-1:l,r&&s>1?u-1:u],f=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let g;o?g="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":g="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/f[0]},
          ${p[1]/f[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l7{constructor(e,t,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,l,u,d]=e;this.outputShape=[a,t,s,d];const p=[r&&t>1?l-1:l,r&&s>1?u-1:u],f=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let g;o?g="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":g="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/f[0]},
          ${p[1]/f[1]},
          ${p[1]/f[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${d-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u7(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:l}=s,[u,d]=l,p=J().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new l7(r.shape,u,d,o,a):new i7(r.shape,u,d,o,a);return t.runWebGLProgram(p,[r],r.dtype)}const c7={kernelName:Up,backendName:"webgl",kernelFunc:u7};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d7{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,a,l]=e,u=[s&&a>1?r-1:r,s&&l>1?o-1:o],d=[s&&a>1?a-1:a,s&&l>1?l-1:l],p=u[0]/d[0],f=u[1]/d[1],m=1/p,g=1/f,x=Math.ceil(m)*2+2,w=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${f});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${g});

        const int winHeight = int(${x});
        const int winWidth = int(${w});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${d[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${d[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p7(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:a}=s,l=new d7(o.shape,r.shape,a);return t.runWebGLProgram(l,[o],o.dtype)}const f7={kernelName:ry,backendName:"webgl",kernelFunc:p7};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h7{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=l=>t.indexOf(l)!==-1&&e[l]!==1?`${e[l]} - coords[${l}] - 1`:`coords[${l}]`,o=e.map((l,u)=>r(u)).join(","),a=Ze(s);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m7{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=on("rc",s),o=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,a=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,l=Ze(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${l} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(r.slice())};
          if(${o}){
            result.g = ${d(r.slice())};
          }
          if(${a}) {
            result.b = ${p(r.slice())};
            if(${o}) {
              result.a = ${f(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(x){return m(x)}function d(x){return x[s-1]="("+x[s-1]+" + 1)",m(x)}function p(x){return x[s-2]="("+x[s-2]+" + 1)",m(x)}function f(x){return x[s-1]="("+x[s-1]+" + 1)",x[s-2]="("+x[s-2]+" + 1)",m(x)}function m(x){const w=e.map((C,I)=>g(I,x)),v=w.join(","),b=w.slice(-2).join(",");return`getChannel(getX(${v}), vec2(${b}))`}function g(x,w){return t.indexOf(x)!==-1&&e[x]!==1?`${e[x]} - ${w[x]} - 1`:`${w[x]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:o}=s,a=r.shape.length,l=Me(o,r.shape);if(a===0)return Rn({inputs:{x:r},backend:t});const u=J().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new m7(r.shape,l):new h7(r.shape,l);return t.runWebGLProgram(u,[r],r.dtype)}const y7={kernelName:Hp,backendName:"webgl",kernelFunc:g7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x7{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let o="";typeof t=="number"?o=`float outputValue = ${t.toFixed(2)};`:o=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v7={kernelName:yf,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:o,center:a}=e,l=t,u=new x7(s.shape,o),[d,p]=x0(a,s.shape[1],s.shape[2]),f=[[d,p,Math.sin(r),Math.cos(r)]];return l.runWebGLProgram(u,[s],s.dtype,f)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w7=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,b7=Be({opSnippet:w7}),$7={kernelName:ql,backendName:"webgl",kernelFunc:b7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S7="return inversesqrt(x);",C7=Be({opSnippet:S7,cpuKernelImpl:LH}),k7={kernelName:Kl,backendName:"webgl",kernelFunc:C7};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sx{constructor(e,t,s,r,o,a,l=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const d=Ze(o.length),p=Ze(a.length);let f="";s===1?f="i":s===2&&(f="i, j");const m=`getIndices(${f})`;let g="";r===1?g="i":r===2&&(g="i, coords[1]");const x=`getUpdates(${g})`;let w="";u&&(w="coords[0], coords[1]");const v=`getDefaultValue(${w})`,b=t>1?"strides[j]":"strides";this.userCode=`
        ${d} strides = ${d}(${o});

        void main() {
          ${p} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${b};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${x};
              found = true;
            }
          }
          setOutput(mix(${v}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N7{constructor(e,t,s,r,o,a,l=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const d=Ze(o.length),p=Ze(a.length);let f="";s===1?f="i":s===2&&(f="i, j");const m=`getIndices(${f})`;let g="";r===1?g="i":r===2&&(g="i, coords[1]");const x=`getUpdates(${g})`;let w="";u&&(w="coords[0], coords[1]");const v=`getDefaultValue(${w})`,b=t>1?"strides[j]":"strides",C=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${d} strides = ${d}(${o});

        void main() {
          ${p} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${b};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${C};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${x};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${v}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I7(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:o}=e,{shape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:d,strides:p,outputSize:f}=Kr(o,r,a),m=[f/d,d];if(f===0)return t.makeTensorInfo(a,r.dtype);const g=ge({inputs:{x:r},backend:t,attrs:{shape:[u,l]}}),x=ge({inputs:{x:o},backend:t,attrs:{shape:[u,d]}}),w=t.makeTensorInfo([],"float32",new Float32Array([0]));let v;J().getBool("WEBGL_PACK")?v=new N7(u,l,g.shape.length,x.shape.length,p,m):v=new sx(u,l,g.shape.length,x.shape.length,p,m);const b=t.runWebGLProgram(v,[x,g,w],x.dtype),C=ge({inputs:{x:b},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(w),C}const T7={kernelName:jp,backendName:"webgl",kernelFunc:I7};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class E7{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const o="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,l=J().getNumber("WEBGL_VERSION")===2?o:a,u=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${l}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R7(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:o}=e,{side:a}=s,l=new E7(r.shape[0],r.shape[1],o.shape[1],a),u=[[r.shape[1]]];return t.runWebGLProgram(l,[r,o],"int32",u)}const _7={kernelName:Kp,backendName:"webgl",kernelFunc:R7};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O7{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,o;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)o="resRC",r="resRC";else{const l=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],d=[];for(let p=0;p<t.length;p++)d.push(`${l[p]}`),p<e&&u.push(`${l[p]}`);r=u.join(),o=d.join()}const a=Ze(s);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D7(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:o}=e,a=new O7(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(a,[s,r,o],fn(r.dtype,o.dtype))}const A7={kernelName:Xp,backendName:"webgl",kernelFunc:D7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F7=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${b0};
  float scale = ${$0};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,P7=Be({opSnippet:F7}),L7={kernelName:Xl,backendName:"webgl",kernelFunc:P7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V7=Ha+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,B7=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,M7=Be({opSnippet:V7,packedOpSnippet:B7,cpuKernelImpl:BH}),z7={kernelName:Jl,backendName:"webgl",kernelFunc:M7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W7=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,U7=Be({opSnippet:W7}),G7={kernelName:Zl,backendName:"webgl",kernelFunc:U7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H7=Ha+`
  return sin(x);
`,j7=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Wo}
  return result;
`,q7=Be({opSnippet:H7,packedOpSnippet:j7}),K7={kernelName:Yl,backendName:"webgl",kernelFunc:q7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X7=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Y7=Be({opSnippet:X7}),Q7={kernelName:Ql,backendName:"webgl",kernelFunc:Y7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z7=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,J7=Be({opSnippet:Z7}),e9={kernelName:eu,backendName:"webgl",kernelFunc:J7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t9=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,paddings:a}=s;O(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const l=o.reduce((b,C)=>b*C),u=[[0,0]];u.push(...a);for(let b=1+o.length;b<r.shape.length;++b)u.push([0,0]);const d=[],p=o2({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),f=vu(p.shape,o,l,!1),m=wu(f.length,o.length,!1),g=bu(p.shape,o,l,!1),x=ge({inputs:{x:p},backend:t,attrs:{shape:f}}),w=ln({inputs:{x},backend:t,attrs:{perm:m}}),v=ge({inputs:{x:w},backend:t,attrs:{shape:g}});return d.push(p),d.push(x),d.push(w),d.forEach(b=>t.disposeIntermediateTensorInfo(b)),v},n9={kernelName:Zp,backendName:"webgl",kernelFunc:t9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s9(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:o,defaultValue:a}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const l=t.readSync(s.dataId),u=t.readSync(r.dataId),d=t.readSync(o.dataId),p=t.readSync(a.dataId)[0],[f,m,g,x,w]=zH(l,s.shape,s.dtype,u,r.dtype,d,p);return[t.makeTensorInfo(m,s.dtype,f),t.makeTensorInfo([m[0]],r.dtype,g),t.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(v=>Number(v)))),t.makeTensorInfo([w.length],s.dtype,new Int32Array(w))]}const r9={kernelName:tf,backendName:"webgl",kernelFunc:s9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o9(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const a=Array.from(t.readSync(r.dataId)),l=t.readSync(s.dataId),u=Array.from(t.readSync(o.dataId)),[d,p,f]=WH(l,s.shape,s.dtype,a,u);return[t.makeTensorInfo(p,s.dtype,d),t.makeTensorInfo([f.length],o.dtype,new Int32Array(f))]}const a9={kernelName:nf,backendName:"webgl",kernelFunc:o9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i9(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const a=t.readSync(s.dataId),l=t.readSync(r.dataId),u=t.readSync(o.dataId),[d,p]=RN(a,s.shape,s.dtype,l,u,!0);return t.makeTensorInfo(p,s.dtype,d)}const l9={kernelName:sf,backendName:"webgl",kernelFunc:i9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u9(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const a=t.readSync(s.dataId),l=t.readSync(r.dataId),u=t.readSync(o.dataId),[d,p]=RN(a,s.shape,s.dtype,l,u);return t.makeTensorInfo(p,s.dtype,d)}const c9={kernelName:rf,backendName:"webgl",kernelFunc:u9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d9(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:o,defaultValue:a}=e,{outputShape:l}=s,{sliceRank:u,numUpdates:d,sliceSize:p,strides:f,outputSize:m}=Kr(o,r,l),g=!1;if(o.dtype==="string"){const b=t.bufferSync(r),C=t.bufferSync(o),I=tr(t.readSync(a.dataId)[0]),N=VH(b,C,l,m,p,d,u,f,I,g);return t.makeTensorInfo(l,N.dtype,N.values)}const x=new sx(d,u,r.shape.length,o.shape.length,f,[m,1],g),w=t.runWebGLProgram(x,[o,r,a],o.dtype),v=ge({inputs:{x:w},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(w),v}const p9={kernelName:of,backendName:"webgl",kernelFunc:d9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:o,axis:a}=s,l=Me(a,r.shape)[0],u=F0(r,o,l),d=r.shape.length,p=new Array(d).fill(0),f=r.shape.slice();return u.map(m=>{const g=[...f];g[l]=m;const x=ja({inputs:{x:r},backend:t,attrs:{begin:p,size:g}});return p[l]+=m,x})}const h9={kernelName:Jp,backendName:"webgl",kernelFunc:f9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ib="return sqrt(x);",m9=Be({opSnippet:ib,packedOpSnippet:ib,cpuKernelImpl:UH}),g9={kernelName:tu,backendName:"webgl",kernelFunc:m9};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y9="return x * x;",x9=Be({opSnippet:y9}),v9={kernelName:ay,backendName:"webgl",kernelFunc:x9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lb="return (a - b) * (a - b);",w9=Ht({opSnippet:lb,packedOpSnippet:lb}),b9={kernelName:nu,backendName:"webgl",kernelFunc:w9};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const o=t.readSync(r.dataId),a=rr(o),l=GH(a,"string",s);return t.makeTensorInfo(r.shape,"string",l)}const S9={kernelName:su,backendName:"webgl",kernelFunc:$9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C9({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=ns+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new Ts(s.shape,r);return t.runWebGLProgram(o,[s],s.dtype)}const k9={kernelName:lu,backendName:"webgl",kernelFunc:C9};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N9{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,o=Ze(s.length),a=Ze(s.length);let l="";if(r===1)l="coords * strides + begin";else{let u=0;l=s.map((d,p)=>(u++,s.length===1?`coords * strides[${p}] + begin[${p}]`:`coords[${u-1}] * strides[${p}] + begin[${p}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,end:a,strides:l,beginMask:u,endMask:d,ellipsisMask:p,newAxisMask:f,shrinkAxisMask:m}=s,{finalShapeSparse:g,finalShape:x,isIdentity:w,sliceDim0:v,isSimpleSlice:b,begin:C,end:I,strides:N}=m0(r.shape,o,a,l,u,d,p,f,m);let R;if(w)R=ge({inputs:{x:r},backend:t,attrs:{shape:x}});else if(v||b){O(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const F=d0(C,I,N),V=ja({inputs:{x:r},backend:t,attrs:{begin:C,size:F}});R=ge({inputs:{x:V},backend:t,attrs:{shape:x}}),t.disposeIntermediateTensorInfo(V)}else if(t.shouldExecuteOnCPU([r])){const V=t.readSync(r.dataId),P=Ae(r.shape,r.dtype,V),A=HH(g,P,N,C);R=t.makeTensorInfo(x,r.dtype,A.values)}else{const V=new N9(C,N,g);R=t.runWebGLProgram(V,[r],r.dtype)}const D=ge({inputs:{x:R},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(R),D}const T9={kernelName:af,backendName:"webgl",kernelFunc:I9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E9(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:o,leftPad:a,rightPad:l,padWidth:u,preserveShortSequences:d}=s,{data:p,dataSplits:f}=e,m=t.readSync(p.dataId),g=t.readSync(f.dataId),[x,w]=jH(m,g,r,o,a,l,u,d);return[t.makeTensorInfo([x.length],"string",x),t.makeTensorInfo(f.shape,"int32",w)]}const R9={kernelName:lf,backendName:"webgl",kernelFunc:E9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _9(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:o,delimiter:a}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const l=t.readSync(o.dataId),u=t.readSync(a.dataId)[0],[d,p,f]=qH(l,u,r),m=p.length;return[t.makeTensorInfo([m,2],"int32",d),t.makeTensorInfo([m],"string",p),t.makeTensorInfo([2],"int32",new Int32Array(f))]}const O9={kernelName:uf,backendName:"webgl",kernelFunc:_9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D9(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.readSync(o.dataId),l=KH(a,r);return t.makeTensorInfo(o.shape,"int32",l)}const A9={kernelName:cf,backendName:"webgl",kernelFunc:D9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F9="return tan(x);",P9=Be({opSnippet:F9}),L9={kernelName:ou,backendName:"webgl",kernelFunc:P9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V9=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,B9=Be({opSnippet:V9}),M9={kernelName:au,backendName:"webgl",kernelFunc:B9};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z9(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:o,updates:a}=e,{sliceRank:l,numUpdates:u,sliceSize:d,strides:p,outputSize:f}=Kr(a,o,r.shape),m=[f/d,d];if(f===0)return t.makeTensorInfo(r.shape,o.dtype);const g=ge({inputs:{x:o},backend:t,attrs:{shape:[u,l]}}),x=ge({inputs:{x:a},backend:t,attrs:{shape:[u,d]}}),w=ge({inputs:{x:r},backend:t,attrs:{shape:m}}),v=new sx(u,l,g.shape.length,x.shape.length,p,m,!1,!0),b=t.runWebGLProgram(v,[x,g,w],w.dtype),C=ge({inputs:{x:b},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(b),C}const W9={kernelName:qp,backendName:"webgl",kernelFunc:z9};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U9{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[a]*t[a];this.outputShape=s,this.rank=s.length;const r=Ze(this.rank),o=G9(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function G9(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:o}=s;if(r.dtype==="string"||r.shape.length>5){const u=t.readSync(r.dataId),d=r.dtype==="string"?u.map(m=>tr(m)):u,p=Ae(r.shape,r.dtype,d),f=YH(p,o);return t.makeTensorInfo(f.shape,f.dtype,f.values)}const a=new U9(r.shape,o);return t.runWebGLProgram(a,[r],r.dtype)}const H9={kernelName:iu,backendName:"webgl",kernelFunc:i2};class j9{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class q9{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mo(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function ub(n){let e=1;for(;e<n;)e*=2;return e}function K9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:o,sorted:a}=s,l=J().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=J().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),d=r.shape,p=d[d.length-1];if(t.shouldExecuteOnCPU([r])||p<l||o>u){const A=t.readSync(r.dataId),[T,W]=QH(A,d,r.dtype,o,a);return[t.makeTensorInfo(T.shape,T.dtype,T.values),t.makeTensorInfo(W.shape,W.dtype,W.values)]}if(o===0)return d[d.length-1]=0,[t.makeTensorInfo(d,r.dtype,[]),t.makeTensorInfo(d,"int32",[])];if(p===1)return[r,Iu({attrs:{shape:d,dtype:"int32",value:0},backend:t})];const f=t.texData.get(r.dataId),m=f!==null&&f.isPacked,g=m?t.unpackTensor(r):r,w=oe(d)/p,v=ge({inputs:{x:g},attrs:{shape:[w,p]},backend:t});m&&mo(t,g);const b=ub(o),C=ub(p);let I=null;const N=()=>I===null?[v,v]:[v,I],R=(A,T,W)=>{const j=N(),Y=new j9(W),Z=[[p],[I===null?1:0],[Number.NEGATIVE_INFINITY],[A],[T]],ne=I;I=t.runWebGLProgram(Y,j,"int32",Z),mo(t,ne)};for(let A=1;A<b;A*=2){const T=A*2;for(let W=A;W>=1;W/=2)R(T,W,[w,C])}for(let A=C;A>b;A/=2){const T=N(),W=new q9([w,A/2]),Y=[[p],[I===null?1:0],[b]],Q=I;I=t.runWebGLProgram(W,T,"int32",Y),mo(t,Q);const Z=b/2,ne=Z*2;for(let U=Z;U>=1;U/=2)R(ne,U,I.shape)}let D=I;I=ja({inputs:{x:I},backend:t,attrs:{begin:0,size:[w,o]}}),mo(t,D);let F=JN({inputs:{x:v,indices:I},backend:t,attrs:{axis:1,batchDims:1}});mo(t,v);const V=d.slice(0,-1);V.push(o),D=I,I=ge({inputs:{x:I},attrs:{shape:V},backend:t}),mo(t,D);const P=F;return F=ge({inputs:{x:F},attrs:{shape:V},backend:t}),mo(t,P),[F,I]}const X9={kernelName:df,backendName:"webgl",kernelFunc:K9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y9{constructor(e,t,s,r,o,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const l=s==="nearest"?1:2;let u;switch(r){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${l} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q9(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:o}=e,{interpolation:a,fillMode:l,fillValue:u,outputShape:d}=s,[p,f,m,g]=r.shape,[x,w]=d??[f,m],v=[p,x,w,g],b=new Y9(f,m,a,l,u,v);return t.runWebGLProgram(b,[r,o],"float32")}const Z9={kernelName:pf,backendName:"webgl",kernelFunc:Q9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J9(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:o}=e;Cu(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(o.dataId),{outputValues:l,outputShape:u,indices:d}=ZH(a,r,o.shape,o.dtype);return[s.makeTensorInfo(u,o.dtype,l),s.makeTensorInfo([d.length],"int32",d)]}const eY={kernelName:ff,backendName:"webgl",kernelFunc:J9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tY(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const a=r,l=a.shape.length,u=r.shape[o],d=new Array(l-1);let p=0;for(let w=0;w<l;w++)w!==o&&(d[p++]=a.shape[w]);const f=[],m=new Array(l).fill(0),g=a.shape.slice();g[o]=1;const x=new Array(u);for(let w=0;w<x.length;w++){m[o]=w;const v=ja({inputs:{x:a},backend:t,attrs:{begin:m,size:g}}),b=ge({inputs:{x:v},backend:t,attrs:{shape:d}});x[w]=b,f.push(v)}return f.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const nY={kernelName:hf,backendName:"webgl",kernelFunc:tY};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sY{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,o=e.inSize,a=e.numSegments,l=a*Math.ceil(o/s);this.outputShape=[r,l];const u="0.0",d="sumValue",p=Math.floor(s/4)*4,f=s%4,m=`
        sumValue += dot(values, segFilter);
    `;let g="";o%s>0&&(g=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let x="";o%s>0&&(x=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${x}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${p};
        if (${f===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${f===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${f===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${d});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:o}=e,{numSegments:a}=s,l=r.shape.length,u=[];let d=0;const p=wt([d],l);let f=r;p!=null&&(f=ln({inputs:{x:r},backend:t,attrs:{perm:p}}),u.push(f),d=bt(1,l)[0]);const m=tk(f.shape,d,a),g=oe([f.shape[d]]),x=ge({inputs:{x:f},backend:t,attrs:{shape:[-1,g]}});u.push(x);const w=vf(r.dtype),v=(N,R,D,F,V)=>{const P=N.shape[0],A=N.shape[1],T=ek(A,V),W={windowSize:T,inSize:A,batchSize:P,numSegments:V},j=new sY(W,R),Y=t.compileAndRun(j,[N,D],F);if(u.push(Y),Y.shape[1]===V)return Y;const Q=a2({backend:t,attrs:{start:0,stop:V,step:1,dtype:"float32"}}),Z=i2({inputs:{x:Q},backend:t,attrs:{reps:[A/T]}});return u.push(Q),u.push(Z),v(Y,R,Z,F,V)},b=v(x,"unsortedSegmentSum",o,w,a),C=ge({inputs:{x:b},backend:t,attrs:{shape:m}});let I=C;if(p!=null){u.push(C);const N=hu(p);I=ln({inputs:{x:I},backend:t,attrs:{perm:N}})}return u.forEach(N=>t.disposeIntermediateTensorInfo(N)),I}const oY={kernelName:mf,backendName:"webgl",kernelFunc:rY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aY=[U6,H6,K6,Q6,J6,nj,rj,aj,cj,pj,mj,xj,bj,kj,Tj,Rj,Oj,Pj,Vj,Mj,Gj,Qj,Jj,s5,o5,d5,f5,y5,N6,w5,k5,E5,F5,V5,M5,W5,G5,K5,Q5,e8,n8,r8,a8,u8,d8,m8,y8,w8,S8,k8,E8,D8,L8,M8,U8,G8,j8,K8,Y8,Z8,eq,rq,iq,cq,pq,mq,xq,$q,Nq,k6,Tq,S5,_q,Aq,Lq,T6,zq,Hq,qq,Qq,eK,rK,iK,dK,mK,xK,wK,CK,NK,TK,OK,AK,PK,VK,MK,GK,KK,ZK,aX,_6,cX,fX,gX,vX,i5,$X,CX,NX,EX,DX,R6,FX,LX,BX,zX,WX,l5,nX,HX,XX,JX,D6,s7,a7,c7,f7,y7,v7,$7,k7,T7,_7,A7,L7,z7,G7,K7,Q7,Xj,rX,e9,n9,r9,a9,l9,c9,p9,h9,g9,v9,b9,S9,k9,T9,R9,O9,A9,sX,M6,L9,M9,W9,H9,X9,Z9,z6,eY,nY,oY,SX];for(const n of aY)xf(n);function iY(){const[n,e]=og.useState(null),[t,s]=og.useState([]),r=async o=>{var l;const a=(l=o.target.files)==null?void 0:l[0];if(a){const u=URL.createObjectURL(a);e(u);const d=new Image;d.src=u,d.onload=async()=>{const m=(await(await WL.load()).detect(d)).filter(g=>g.score>.5);s(m),console.log("Filtered Predictions:",m)}}};return Ns.jsxs("div",{className:"App",children:[Ns.jsx("h1",{children:"Object Detection"}),Ns.jsx("input",{type:"file",accept:"image/*",onChange:r}),n&&Ns.jsx("img",{src:n,alt:"Uploaded",style:{maxWidth:"100%"}}),Ns.jsxs("div",{children:[Ns.jsx("h2",{children:"Predictions:"}),Ns.jsx("ul",{children:t.map((o,a)=>Ns.jsxs("li",{children:[o.class," - ",Math.round(o.score*100),"%"]},a))})]})]})}pT.createRoot(document.getElementById("root")).render(Ns.jsx(og.StrictMode,{children:Ns.jsx(iY,{})}));
